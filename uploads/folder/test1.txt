import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'dashboard_screen.dart' as dash;
import 'menu.dart' as menu;
import 'report.dart' as report;
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter/services.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'add_product_screen.dart';
import '../services/statement_service.dart';
import '../services/auth_service.dart';
import '../services/cities_service.dart';
import 'dart:async';
import '../network/order_service.dart';
import '../utils/custom_snackbar.dart';
import '../config/api_config.dart';
import 'package:google_fonts/google_fonts.dart';
import 'order_list_screen.dart';
import 'ageing_report_screen.dart' as ageing_report;
import 'courier_insights_screen.dart' as courier_insights;
import 'courier_performance_screen.dart' as courier_performance;
import 'package:dio/dio.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'dart:convert';

class OrderItem {
  final String name;
  final String sku;
  final String refCode;
  final int qty;
  final double price;
  final String productCode;
  final String variationId;
  final String productId;
  final String locationId;
  final double weight;
  OrderItem({
    required this.name,
    required this.sku,
    required this.refCode,
    required this.qty,
    required this.price,
    required this.productCode,
    required this.variationId,
    required this.productId,
    required this.locationId,
    required this.weight,
  });
}

class CreateOrderScreen extends StatefulWidget {
  final String? from;
  const CreateOrderScreen({Key? key, this.from}) : super(key: key);

  @override
  State<CreateOrderScreen> createState() => _CreateOrderScreenState();
}

class _CreateOrderScreenState extends State<CreateOrderScreen> {
  final List<OrderItem> _orders = [];
  final Set<int> _expandedOrders = {};
  bool _isDialogOpen = false;
  String selectedCountry = 'Pakistan';
  String? selectedCity;
  List<String> cityList = [];
  String selectedPaymentType = 'COD';
  final List<String> paymentTypes = ['COD', 'JazzCash', 'EasyPaisa', 'CC'];

  final AuthService _authService = Get.find<AuthService>();
  bool _isSaving = false;
  
  List<Map<String, dynamic>> _platforms = [];
  Map<String, dynamic>? _selectedPlatform;


  String _platformSearch = '';
  
  final List<GlobalKey<_OrderFieldState>> _orderFieldKeys = List.generate(9, (_) => GlobalKey<_OrderFieldState>());
  
  final List<TextEditingController> _controllers = List.generate(9, (_) => TextEditingController());
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  List<Map<String, dynamic>> cityListData = [];
  
  Set<int> _missingRequiredFields = {};

  @override
  void initState() {
    super.initState();
    _fetchCities();
    _fetchPlatforms();
  }

  Future<void> _fetchCities() async {
    try {
      
      final cachedCities = CitiesService.getCachedCities();
      if (cachedCities != null) {
        List<String> cities = [];
        List<Map<String, dynamic>> cityObjs = [];
        cityObjs = List<Map<String, dynamic>>.from(cachedCities);
        
       
        
        
        // Use consistent field names - try both 'name' and 'city_name'
        cities = cachedCities.map<String>((c) => 
          (c['city_name'] ?? c['name'] ?? '').toString()
        ).where((c) => c.isNotEmpty).toList();
        
        setState(() {
          cityList = cities;
          cityListData = cityObjs;
          if (cityList.isNotEmpty) selectedCity = cityList.first;
        });
        return;
      }
      
      
      final countryId = 1;
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
        data: {"country_id": countryId},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<String> cities = [];
        List<Map<String, dynamic>> cityObjs = [];
        if (data is List) {
          cityObjs = List<Map<String, dynamic>>.from(data);
          cities = data.map<String>((c) => c['city_name']?.toString() ?? '').where((c) => c.isNotEmpty).toList();
          
          // Debug: Print API city structure
          if (data.isNotEmpty) {
            
          }
        } else if (data is Map && data['payload'] is List) {
          cityObjs = List<Map<String, dynamic>>.from(data['payload']);
          cities = (data['payload'] as List)
              .map<String>((c) => c['city_name']?.toString() ?? '')
              .where((c) => c.isNotEmpty)
              .toList();
          
          // Debug: Print API payload city structure
          if ((data['payload'] as List).isNotEmpty) {
            
          }
        }
        setState(() {
          cityList = cities;
          cityListData = cityObjs;
          if (cityList.isNotEmpty) selectedCity = cityList.first;
        });
      }
    } catch (e) {
      
    }
  }

  Future<void> _fetchPlatforms() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        return;
      }
      final service = StatementService();
      final platformData = await service.fetchShopNames(acno);
      
      final filtered = platformData.where((e) => (e['platform_name']?.toString() ?? '').isNotEmpty).toList();
      setState(() {
        _platforms = filtered;
      });
    } catch (e) {
      
    }
  }

  void _addOrder(OrderItem item) {
    setState(() {
      
      final existingIndex = _orders.indexWhere((existingItem) => 
        existingItem.sku == item.sku && 
        existingItem.productId == item.productId &&
        existingItem.locationId == item.locationId
      );
      
      if (existingIndex != -1) {
        
        final existingItem = _orders[existingIndex];
        final newQuantity = existingItem.qty + item.qty;
        final newTotalPrice = (existingItem.price * existingItem.qty) + (item.price * item.qty);
        final newAveragePrice = newTotalPrice / newQuantity;
        
        _orders[existingIndex] = OrderItem(
          name: existingItem.name,
          sku: existingItem.sku,
          refCode: existingItem.refCode,
          qty: newQuantity,
          price: newAveragePrice,
          productCode: existingItem.productCode,
          variationId: existingItem.variationId,
          productId: existingItem.productId,
          locationId: existingItem.locationId,
          weight: existingItem.weight,
        );
      } else {
        
        _orders.add(item);
      }
      
      
      final totalWeight = _orders.fold<double>(0, (sum, orderItem) => sum + (orderItem.weight * orderItem.qty));
      _controllers[6].text = totalWeight.toStringAsFixed(2);
    });
  }

  void _showSelectPlatformDialog(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        String search = '';
        List<Map<String, dynamic>> filteredPlatforms = _platforms;
        return StatefulBuilder(
          builder: (context, setState) {
            filteredPlatforms = _platforms.where((p) => (p['platform_name']?.toString().toLowerCase() ?? '').contains(search.toLowerCase())).toList();
            return Container(
              decoration: const BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(20),
                  topRight: Radius.circular(20),
                ),
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  
                  Container(
                    margin: const EdgeInsets.only(top: 8),
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                      color: Colors.grey[300],
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                  
                  Flexible(
                    child: AnimationLimiter(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.all(20),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: AnimationConfiguration.toStaggeredList(
                              duration: const Duration(milliseconds: 400),
                              childAnimationBuilder: (widget) => SlideAnimation(
                                verticalOffset: 30.0,
                                child: FadeInAnimation(
                                  child: widget,
                                ),
                              ),
                              children: [
                                const Text('Select Platform', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                                const SizedBox(height: 12),
                                TextField(
                                  decoration: InputDecoration(
                                    hintText: 'Search',
                                    prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                                  ),
                                  onChanged: (val) {
                                    setState(() {
                                      search = val;
                                    });
                                  },
                                ),
                                const SizedBox(height: 12),
                                SizedBox(
                                            height: 300,
                                            child: filteredPlatforms.isEmpty
                                                ? const Center(child: Text('No platforms found.', style: TextStyle(color: Colors.grey)))
                                                : ListView.separated(
                                                    itemCount: filteredPlatforms.length,
                                                    separatorBuilder: (_, __) => Container(
                                                      height: 1,
                                                      color: Colors.black.withOpacity(0.08),
                                                      margin: const EdgeInsets.symmetric(horizontal: 8),
                                                    ),
                                                    itemBuilder: (context, i) {
                                                      final platform = filteredPlatforms[i];
                                                      final platformName = platform['website_name']?.toString().isNotEmpty == true
                                                          ? platform['website_name'].toString()
                                                          : (platform['platform_name']?.toString() ?? 'Unknown Platform');
                                                      return ListTile(
                                                        title: Text(
                                                          platformName,
                                                          style: const TextStyle(
                                                            color: Colors.black,
                                                            fontWeight: FontWeight.normal,
                                                          ),
                                                        ),
                                                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                                        onTap: () async {
                                                          
                                                          bool isDifferentPlatform = _selectedPlatform == null || 
                                                              _selectedPlatform!['id'] != platform['id'];
                                                          
                                                          
                                                          if (isDifferentPlatform && _orders.isNotEmpty) {
                                                            final shouldProceed = await showDialog<bool>(
                                                              context: context,
                                                              builder: (BuildContext context) {
                                                                return AlertDialog(
                                                                  title: const Text('Switch Platform'),
                                                                  content: const Text('Switching to a different platform will clear all existing products. Do you want to continue?'),
                                                                  actions: [
                                                                    TextButton(
                                                                      onPressed: () => Navigator.of(context).pop(false),
                                                                      child: const Text('Cancel'),
                                                                    ),
                                                                    TextButton(
                                                                      onPressed: () => Navigator.of(context).pop(true),
                                                                      child: const Text('Continue'),
                                                                    ),
                                                                  ],
                                                                );
                                                              },
                                                            );
                                                            
                                                            if (shouldProceed != true) {
                                                              return; 
                                                            }
                                                          }
                                                          
                                                          this.setState(() {
                                                            _selectedPlatform = platform;
                                                            
                                                            if (isDifferentPlatform && _orders.isNotEmpty) {
                                                              _orders.clear();
                                                              
                                                              _controllers[8].text = '';
                                                            }
                                                          });
                                                          Navigator.of(context).pop();
                                                          _showAddProductScreen(context);
                                                        },

                                                      );
                                                    },
                                                  ),
                                          ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }

  void _showAddProductScreen(BuildContext context) async {
    final platformId = int.tryParse(_selectedPlatform?['platform_id']?.toString() ?? '');
    final customerPlatformId = _selectedPlatform?['id'] != null
        ? int.tryParse(_selectedPlatform?['id']?.toString() ?? '')
        : null;
    
    // Preload product suggestions for better performance
    if (platformId != null) {
      final acno = _authService.getCurrentAcno();
      if (acno != null) {
        // Preload in background without blocking UI
        Future.microtask(() async {
          try {
            final service = StatementService();
            await service.fetchProductSuggestions(
              acno: acno,
              platformId: platformId,
              customerPlatformId: customerPlatformId,
            ).timeout(const Duration(seconds: 60)); // Increased timeout to 30 seconds
          } catch (e) {
            // Ignore preload errors, they won't affect the main functionality
            if (e.toString().contains('TimeoutException')) {
              print('Preload timeout: Product suggestions took longer than expected');
            } else {
              print('Preload failed: $e');
            }
          }
        });
      }
    }
    
    final result = await Navigator.push<OrderItem>(
      context,
      MaterialPageRoute(
        builder: (_) => AddProductScreen(
          platformId: platformId,
          customerPlatformId: customerPlatformId,
          existingOrderItems: _orders, 
        ),
      ),
    );
    if (result is OrderItem) {
      _addOrder(result);
    }
  }

  Future<bool?> showDeleteProductDialog(BuildContext context) {
    return showModalBottomSheet<bool>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: MediaQuery.of(context).size.width,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: Color(0xFFF5F5F7),
                    shape: BoxShape.circle,
                  ),
                  padding: EdgeInsets.all(32),
                  child: SvgPicture.asset(
                    'assets/Delete.svg',
                    width: MediaQuery.of(context).size.width * 0.064,
                    height: MediaQuery.of(context).size.width * 0.064,
                    color: Color(0xFF007AFF),
                  ),
                ),
                SizedBox(height: 24),
                Text(
                  'Are you Sure?',
                  style: TextStyle(
                    fontFamily: 'SF Pro Display',
                    fontWeight: FontWeight.w700,
                    fontSize: MediaQuery.of(context).size.width * 0.045, 
                    color: Colors.black,
                  ),
                ),
                SizedBox(height: 8),
                Text(
                  'You want to delete this product',
                  style: TextStyle(
                    fontFamily: 'SF Pro Display',
                    fontWeight: FontWeight.w400,
                    fontSize: MediaQuery.of(context).size.width * 0.035, 
                    color: Color(0xFF8E8E93),
                  ),
                ),
                SizedBox(height: 28),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Color(0xFFF2F2F7),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: Text(
                          'No',
                          style: TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w500,
                            fontSize: MediaQuery.of(context).size.width * 0.035, 
                            color: Colors.black,
                          ),
                        ),
                      ),
                    ),
                    SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(true),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Color(0xFF007AFF),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: Text(
                          'Yes',
                          style: TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w500,
                            fontSize: MediaQuery.of(context).size.width * 0.035, 
                            color: Colors.white,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Future<void> showSuccessDialog(BuildContext context) {
    return showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: MediaQuery.of(context).size.width,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: Color(0xFFF5F5F7),
                    shape: BoxShape.circle,
                  ),
                  padding: EdgeInsets.all(32),
                  child: Icon(Icons.check_circle_outline, color: Color(0xFF007AFF), size: MediaQuery.of(context).size.width * 0.064), 
                ),
                SizedBox(height: 24),
                Text(
                  'Deleted!',
                  style: TextStyle(
                    fontFamily: 'SF Pro Display',
                    fontWeight: FontWeight.w700,
                    fontSize: MediaQuery.of(context).size.width * 0.045, 
                    color: Colors.black,
                  ),
                ),
                SizedBox(height: 8),
                Text(
                  'Product has been deleted successfully.',
                  style: TextStyle(
                    fontFamily: 'SF Pro Display',
                    fontWeight: FontWeight.w400,
                    fontSize: MediaQuery.of(context).size.width * 0.035, 
                    color: Color(0xFF8E8E93),
                  ),
                ),
                SizedBox(height: 28),
                SizedBox(
                  width: MediaQuery.of(context).size.width,
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Color(0xFF007AFF),
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                      padding: EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: Text(
                      'OK',
                      style: TextStyle(
                        fontFamily: 'SF Pro Display',
                        fontWeight: FontWeight.w500,
                        fontSize: MediaQuery.of(context).size.width * 0.035, 
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }



  Future<void> _createOrder() async {
    if (_orders.isEmpty) {
      customSnackBar('Error', 'Please add at least one product');
      return;
    }
    
    bool hasError = false;
    for (final key in _orderFieldKeys) {
      final state = key.currentState;
      if (state != null && !state.validate()) {
        hasError = true;
      }
    }
    if (hasError) {
      setState(() {}); 
      return;
    }
    try {
      
      final remarks = _controllers[8].text.trim();
      final shippingCharges = double.tryParse(_controllers[7].text.trim()) ?? 0;
      
      final weight = _orders.fold<double>(0, (sum, orderItem) => sum + (orderItem.weight * orderItem.qty));
      final orderRef = _controllers[3].text.trim();
      final acno = _authService.getCurrentAcno();
      
      final platformId = int.tryParse(_selectedPlatform?['platform_id']?.toString() ?? '0') ?? 0;
      final customerPlatformId = int.tryParse(_selectedPlatform?['id']?.toString() ?? '0') ?? 0;
 
      final storeName = _selectedPlatform?['website_name']?.toString() ?? '';
      final dio = Dio();
      final paymentMethodId = selectedPaymentType == 'CC' ? 2 : 1;
      
      final shipperName = "DEMO";
      final shipperEmail = "demo@gmail.com";
      final shipperContact = "none";
      final shipperAddress = "Demo address";
      final billingName = "DEMO";
      final billingEmail = "demo@gmail.com";
      final billingContact = "none";
      final billingAddress = "Demo address";
      final orderDate = DateTime.now().toIso8601String().split('T')[0];
      
      // Aggregate order items by product identity to ensure a single line per product
      final Map<String, Map<String, dynamic>> aggregated = {};
      for (final item in _orders) {
        final key = '${item.productId}|${item.variationId}|${item.locationId}|${item.sku}|${item.productCode}';
        if (!aggregated.containsKey(key)) {
          aggregated[key] = {
            'name': item.name,
            'sku': item.sku,
            'refCode': item.refCode,
            'qty': item.qty,
            'totalAmount': item.price * item.qty,
            'productCode': item.productCode,
            'variationId': int.tryParse(item.variationId) ?? 0,
            'productId': int.tryParse(item.productId) ?? 0,
            'locationId': int.tryParse(item.locationId) ?? 0,
          };
        } else {
          final agg = aggregated[key]!;
          agg['qty'] = (agg['qty'] as int) + item.qty;
          agg['totalAmount'] = (agg['totalAmount'] as double) + (item.price * item.qty);
        }
      }
      // Build detail list with unit price (base price) and aggregated quantity
      final List<Map<String, dynamic>> detail = aggregated.values.map((agg) {
        final int qty = agg['qty'] as int;
        final double totalAmount = (agg['totalAmount'] as double);
        // For API, amount should be base price (unit price), not total amount
        final double basePrice = totalAmount / qty;
        return {
          "id": agg['productId'],
          "product_code": agg['productCode'],
          "product_name": agg['name'],
          "quantity": qty,
          "amount": basePrice,
          "image_url": "none",
          "refcode": agg['refCode'],
          "variation": "XL",
          "sku_code": agg['sku'],
          "discount_amount": 0,
          "variation_id": agg['variationId'],
          "product_id": agg['productId'],
          "location_id": agg['locationId'],
        };
      }).toList();
      
      final cityName = selectedCity ?? '';
      final selectedCityObj = cityListData.firstWhere(
        (c) => (c['city_name'] ?? c['name'] ?? '') == cityName,
        orElse: () => <String, dynamic>{},
      );
      
      
      
      final originCountryId = 1; 
      final originProvinceId = int.tryParse(selectedCityObj['province_id']?.toString() ?? '') ?? 1;
      final originCityId = int.tryParse(selectedCityObj['id']?.toString() ?? '') ?? 1;
      final destinationCountryId = 1; 
      final destinationProvinceId = int.tryParse(selectedCityObj['province_id']?.toString() ?? '') ?? 1;
      final destinationCityId = int.tryParse(selectedCityObj['id']?.toString() ?? '') ?? 1;
      
  
      final piece = _orders.fold<int>(0, (sum, item) => sum + item.qty);
      final orderAmount = _orders.fold<double>(0, (sum, item) => sum + (item.qty * item.price)) + shippingCharges;
      
      final consigneeName = _controllers[0].text.trim();
      final consigneeEmail = _controllers[1].text.trim();
      final consigneeContact = _controllers[2].text.trim();
      final consigneeAddress = _controllers[4].text.trim();
      final cnicNumber = "32323-2381822-3"; 
      
      final token = await _authService.getApiKey();
      
      final body = [
        {
          "acno": acno ?? "OR-00009",
          "shipper_name": "DEMO",
          "shipper_address": "Demo address",
          "shipper_email": "demo@gmail.com",
          "shipper_contact": "none",
          "billingperson_name": "DEMO",
          "billingperson_address": "Demo address",
          "billingperson_email": "demo@gmail.com",
          "billingperson_contact": "none",
          "consignee_name": consigneeName,
          "consignee_address": consigneeAddress,
          "consignee_email": consigneeEmail,
          "consignee_contact": consigneeContact,
          "consignee_latitude": 0,
          "consignee_longitude": 0,
          "cnic_number": cnicNumber,
          "origin_country_id": originCountryId,
          "city_name": cityName,
          "origin_province_id": originProvinceId,
          "origin_city_id": originCityId,
          "destination_country_id": destinationCountryId,
          "destination_province_id": destinationProvinceId,
          "destination_city_id": destinationCityId,
          "piece": piece,
          "weight": weight,
          "order_amount": orderAmount,
          "order_ref": orderRef,
          "detail": detail,
          "platform_id": platformId,
          "store_name": storeName,
          "payment_method_id": paymentMethodId,
          "remarks": remarks,
          "shipping_charges": shippingCharges,
          "order_date": orderDate,
          "customer_platform_id": customerPlatformId
        }
      ];
      
    
      
      
     
      
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderCreateEndpoint),
        data: body,
        options: Options(headers: {
          'Content-Type': 'application/json',
          if (token != null && token.isNotEmpty) 'Authorization': 'Bearer $token',
        }),
      );
      
      if (response.statusCode == 200 && (response.data['status'] == 1 || response.data['success'] == true)) {
        
        await _showOrderSuccessDialog();
        
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => CreateOrderScreen()),
        );
        return;
      } else {
        customSnackBar('Error','Failed to create order');
      }
    } catch (e) {
      print('--- DEBUG: ERROR CAUGHT IN ORDER CREATE ---');
      print(e);
      customSnackBar('Error', 'Failed to create order: ${e.toString()}');
    }
  }

  @override
  Widget build(BuildContext context) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: [SystemUiOverlay.top, SystemUiOverlay.bottom]);

    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: false, 
      extendBody: true,
      appBar: AppBar(
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () {
            if (widget.from == 'menu') {
              Get.offAll(() => menu.MenuScreen());
            } else if (widget.from == 'order_list') {
              Get.offAll(() => OrderListScreen());
            } else if (widget.from == 'ageing_report') {
              Get.offAll(() => ageing_report.AgeingReportScreen());
            } else if (widget.from == 'courier_insights') {
              Get.offAll(() => courier_insights.CourierInsightsScreen());
            } else if (widget.from == 'courier_performance') {
              Get.offAll(() => courier_performance.CourierPerformanceScreen());
            } else if (widget.from == 'quick_edit') {
              Get.offAll(() => OrderListScreen());
            } else if (widget.from == 'create_cn') {
              Get.offAll(() => OrderListScreen());
            } else {
              Navigator.of(context).maybePop();
            }
          },
        ),
        title: const Text(
          'Create Order',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            return SingleChildScrollView(
              padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom + 24),
              child: ConstrainedBox(
                constraints: BoxConstraints(minHeight: constraints.maxHeight),
                child: IntrinsicHeight(
                  child: AnimationLimiter(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: AnimationConfiguration.toStaggeredList(
                        duration: const Duration(milliseconds: 600),
                        childAnimationBuilder: (widget) => SlideAnimation(
                          verticalOffset: 50.0,
                          child: FadeInAnimation(
                            child: widget,
                          ),
                        ),
                        children: [
                          if (_orders.isNotEmpty)
                            Padding(
                              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                              child: Column(
                                children: _orders.asMap().entries.map((entry) {
                                  final i = entry.key;
                                  final order = entry.value;
                                  return Container(
                                    margin: const EdgeInsets.only(bottom: 8),
                                    decoration: BoxDecoration(
                                      color: const Color(0xFFF8F9FA),
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    child: ExpansionTile(
                                      backgroundColor: Colors.transparent,
                                      collapsedBackgroundColor: Colors.transparent,
                                      tilePadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 1), 
                                      childrenPadding: const EdgeInsets.only(bottom: 12),
                                      shape: const Border(),
                                      collapsedShape: const Border(),
                                      title: Row(
                                        children: [
                                          Expanded(
                                            child: Text(
                                              order.name,
                                              style: GoogleFonts.inter(
                                                fontWeight: FontWeight.w500,
                                                fontSize: 14,
                                                color: const Color(0xFF212529),
                                              ),
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                          ),
                                        ],
                                      ),
                                      children: [
                                        Padding(
                                          padding: const EdgeInsets.symmetric(horizontal: 16),
                                          child: Column(
                                            crossAxisAlignment: CrossAxisAlignment.start,
                                            children: [
                                              
                                             
                                              _buildProductDetailRow('SKU', order.sku),
                                              const SizedBox(height: 8),
                                              _buildProductDetailRow('REF-Code', order.refCode),
                                              const SizedBox(height: 8),
                                              _buildProductDetailRow('QTY', order.qty.toString()),
                                              const SizedBox(height: 8),
                                              _buildProductDetailRow('Price', '${order.price.toStringAsFixed(2)}'),
                                              const SizedBox(height: 8),
                                              _buildProductDetailRow('Subtotal', '${(order.qty * order.price).toStringAsFixed(2)}'),
                                              const SizedBox(height: 12),
                                              
                                              Row(
                                                children: [
                                                  SizedBox(
                                                    width: 80,
                                                    child: Text(
                                                      'Action',
                                                      style: GoogleFonts.inter(
                                                        fontWeight: FontWeight.w600,
                                                        fontSize: 14,
                                                        color: const Color(0xFF495057),
                                                      ),
                                                    ),
                                                  ),
                                                  const SizedBox(width: 16),
                                                  GestureDetector(
                                                    onTap: () async {
                                                      setState(() => _isDialogOpen = true);
                                                      final confirm = await showDeleteProductDialog(context);
                                                      setState(() => _isDialogOpen = false);
                                                      if (confirm == true) {
                                                        setState(() {
                                                          _orders.removeAt(i);
                                                          
                                                          final totalWeight = _orders.fold<double>(0, (sum, orderItem) => sum + (orderItem.weight * orderItem.qty));
                                                          _controllers[6].text = totalWeight.toStringAsFixed(2);
                                                        });
                                                      }
                                                    },
                                                    child: Row(
                                                      children: [
                                                        SvgPicture.asset(
                                                          'assets/Delete.svg',
                                                          width: 16,
                                                          height: 16,
                                                                                                                  ),
                                                        const SizedBox(width: 8),
                                                        Text(
                                                          'Delete',
                                                          style: GoogleFonts.inter(
                                                            fontWeight: FontWeight.w500,
                                                            fontSize: 14,
                                                            color: Colors.black,
                                                          ),
                                                        ),
                                                      ],
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            ],
                                          ),
                                        ),
                                      ],
                                    ),
                                  );
                                }).toList(),
                              ),
                            ),
                          
                          _orders.isEmpty
                              ? Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                  child: OutlinedButton(
                                    onPressed: () => _showSelectPlatformDialog(context),
                                    style: OutlinedButton.styleFrom(
                                      backgroundColor: const Color(0xFFF5F5F7),
                                      side: BorderSide.none,
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                                      padding: const EdgeInsets.symmetric(vertical: 12),
                                    ),
                                    child: Row(
                                      mainAxisAlignment: MainAxisAlignment.center,
                                      children: [
                                        Text(
                                          _selectedPlatform != null 
                                              ? 'Add Product'
                                              : 'Please add Product',
                                          style: const TextStyle(
                                            fontFamily: 'SF Pro Display',
                                            fontWeight: FontWeight.w500,
                                            fontSize: 16,
                                            color: Color(0xFF222222),
                                          ),
                                        ),
                                        const SizedBox(width: 8),
                                        const Icon(Icons.add_circle_outline, color: Color(0xFF222222), size: 22),
                                      ],
                                    ),
                                  ),
                                )
                              : Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                                  child: Row(
                                    children: [
                                      const Text(
                                        'Customer Detail',
                                        style: TextStyle(
                                          fontFamily: 'SF Pro Display',
                                          fontWeight: FontWeight.w600,
                                          fontSize: 20,
                                          color: Colors.black,
                                        ),
                                      ),
                                      const Spacer(),
                                      IconButton(
                                        icon: const Icon(Icons.add_circle_outline, color: Color(0xFF222222), size: 22),
                                        onPressed: () => _showSelectPlatformDialog(context),
                                      ),
                                    ],
                                  ),
                                ),
                          
                          if (_orders.isEmpty)
                            Padding(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              child: const Align(
                                alignment: Alignment.centerLeft,
                                child: Text(
                                  'Customer Detail',
                                  style: TextStyle(
                                    fontFamily: 'SF Pro Display',
                                    fontWeight: FontWeight.w700,
                                    fontSize: 16,
                                    color: Colors.black,
                                  ),
                                ),
                              ),
                            ),
                          const SizedBox(height: 2),
                          Form(
                            key: _formKey,
                            child: Padding(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              child: Column(
                                children: [
                                  _OrderField(key: _orderFieldKeys[0], controller: _controllers[0], hint: 'Full Name', isRequired: true, showRedBorderAndLabel: _missingRequiredFields.contains(0)),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[1], controller: _controllers[1], hint: 'Email', isRequired: false, keyboardType: TextInputType.emailAddress, prefixIcon: Icons.email_outlined, fieldType: 'email'),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[2], controller: _controllers[2], hint: 'Phone No', keyboardType: TextInputType.phone, isRequired: true, prefixIcon: Icons.phone_outlined, fieldType: 'phone', showRedBorderAndLabel: _missingRequiredFields.contains(2)),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[3], controller: _controllers[3], hint: 'Order Reference Code', isRequired: true, prefixIcon: Icons.confirmation_number_outlined, showRedBorderAndLabel: _missingRequiredFields.contains(3)),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[4], controller: _controllers[4], hint: 'Address', isRequired: true, prefixIcon: Icons.location_on_outlined, showRedBorderAndLabel: _missingRequiredFields.contains(4)),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[5], controller: _controllers[5], hint: 'Landmark', isRequired: false, prefixIcon: Icons.landscape_outlined),
                                  const SizedBox(height: 8),
                                  
                                  Padding(
                                    padding: const EdgeInsets.symmetric(vertical: 4),
                                    child: Material(
                                      elevation: 1.5,
                                      shadowColor: Colors.black12,
                                      borderRadius: BorderRadius.circular(12),
                                      child: TextFormField(
                                        enabled: false,
                                        controller: TextEditingController(text: selectedCountry),
                                        style: GoogleFonts.poppins(fontSize: 13, color: Colors.black), 
                                        decoration: InputDecoration(
                                          labelText: 'Country',
                                          labelStyle: GoogleFonts.poppins(fontWeight: FontWeight.w500, fontSize: 13, color: Colors.grey[700]),
                                          filled: true,
                                          fillColor: const Color(0xFFF5F5F7),
                                          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 18),
                                          border: OutlineInputBorder(borderRadius: BorderRadius.circular(12), borderSide: BorderSide.none),
                                          isDense: true,
                                        ),
                                      ),
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                                  
                                  GestureDetector(
                                          onTap: () async {
                                            final selected = await showModalBottomSheet<String>(
                                              context: context,
                                              isScrollControlled: true,
                                              backgroundColor: Colors.transparent,
                                              builder: (context) => _CitySearchDialog(
                                                cities: cityList,
                                                initialCity: selectedCity,
                                              ),
                                            );
                                            if (selected != null) {
                                              setState(() {
                                                selectedCity = selected;
                                              });
                                            }
                                          },
                                          child: Container(
                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                            decoration: BoxDecoration(
                                              color: const Color(0xFFF5F5F7),
                                              borderRadius: BorderRadius.circular(14),
                                              border: Border.all(color: Colors.transparent, width: 0), 
                                              boxShadow: [
                                                BoxShadow(
                                                  color: Colors.grey.withOpacity(0.08),
                                                  blurRadius: 8,
                                                  offset: Offset(0, 2),
                                                ),
                                              ],
                                            ),
                                            child: Row(
                                              children: [
                                                Expanded(
                                                  child: Text(
                                                    (selectedCity == null || selectedCity == '' || selectedCity == 'Select City')
                                                        ? 'Select City'
                                                        : selectedCity!,
                                                    style: TextStyle(
                                                      fontSize: 15,
                                                      color: (selectedCity == null || selectedCity == '' || selectedCity == 'Select City')
                                                          ? Colors.grey
                                                          : Colors.black,
                                                    ),
                                                    overflow: TextOverflow.ellipsis,
                                                  ),
                                                ),
                                                Icon(Icons.keyboard_arrow_down_rounded, color: (selectedCity == null || selectedCity == '' || selectedCity == 'Select City') ? Colors.grey : Color(0xFF222222)),
                                              ],
                                            ),
                                          ),
                                        ),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[6], controller: _controllers[6], hint: 'Weight', keyboardType: TextInputType.number, isRequired: false, prefixIcon: Icons.scale_outlined, enabled: false),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[7], controller: _controllers[7], hint: 'Shipping Charges', keyboardType: TextInputType.number, isRequired: false, prefixIcon: Icons.local_shipping_outlined),
                                  const SizedBox(height: 8),
                                  
                                  GestureDetector(
                                    onTap: () async {
                                      final selected = await showModalBottomSheet<String>(
                                        context: context,
                                        isScrollControlled: true,
                                        backgroundColor: Colors.transparent,
                                        builder: (context) => _PaymentTypeDialog(
                                          paymentTypes: ['COD', 'JazzCash', 'EasyPaisa', 'CC'],
                                          selectedPaymentType: selectedPaymentType,
                                        ),
                                      );
                                      if (selected != null) {
                                        setState(() {
                                          selectedPaymentType = selected;
                                        });
                                      }
                                    },
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                      decoration: BoxDecoration(
                                        color: const Color(0xFFF5F5F7),
                                        borderRadius: BorderRadius.circular(14),
                                        border: Border.all(color: Colors.transparent, width: 0), 
                                        boxShadow: [
                                          BoxShadow(
                                            color: Colors.grey.withOpacity(0.08),
                                            blurRadius: 8,
                                            offset: Offset(0, 2),
                                          ),
                                        ],
                                      ),
                                      child: Row(
                                        children: [
                                          Expanded(
                                            child: Text(
                                              selectedPaymentType,
                                              style: TextStyle(
                                                fontSize: 15,
                                                color: Colors.black,
                                              ),
                                              overflow: TextOverflow.ellipsis,
                                            ),
                                          ),
                                          Icon(
                                            Icons.keyboard_arrow_down_rounded,
                                            color: Color(0xFF222222),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                  const SizedBox(height: 8),
                                  _OrderField(key: _orderFieldKeys[8], controller: _controllers[8], hint: 'Remarks', isRequired: false, prefixIcon: Icons.notes_outlined),
                                ],
                              ),
                            ),
                          ),
                          const SizedBox(height: 16),
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 16),
                            child: SizedBox(
                              width: MediaQuery.of(context).size.width,
                              height: 48,
                              child: ElevatedButton(
                                onPressed: _isSaving
                                    ? null
                                    : () async {
                                        
                                        if (_orders.isEmpty) {
                                          customSnackBar('Error', 'Please add at least one product');
                                          return;
                                        }
                                        
                                        if (_controllers[0].text.trim().isEmpty || 
                                            _controllers[2].text.trim().isEmpty || 
                                            _controllers[3].text.trim().isEmpty || 
                                            _controllers[4].text.trim().isEmpty) { 
                                          setState(() {
                                            _missingRequiredFields = {
                                              if (_controllers[0].text.trim().isEmpty) 0,
                                              if (_controllers[2].text.trim().isEmpty) 2,
                                              if (_controllers[3].text.trim().isEmpty) 3,
                                              if (_controllers[4].text.trim().isEmpty) 4,
                                            };
                                          });
                                          customSnackBar('Error', 'Please fill required fields');
                                          return;
                                        }
                                        
                                        if (!_formKey.currentState!.validate()) {
                                          setState(() {}); 
                                          customSnackBar('Error', 'Please correct invalid fields');
                                          return;
                                        }
                                        setState(() { _isSaving = true; });
                                        await _createOrder();
                                        setState(() { _isSaving = false; });
                                      },
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Color(0xFF007AFF),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(10),
                                  ),
                                  elevation: 0,
                                ),
                                child: _isSaving
                                    ? const SizedBox(
                                        width: 24,
                                        height: 24,
                                        child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
                                      )
                                    : const Text(
                                        'Create Order',
                                        style: TextStyle(
                                          fontFamily: 'SF Pro Display',
                                          fontWeight: FontWeight.w600,
                                          fontSize: 16,
                                          color: Colors.white,
                                        ),
                                      ),
                              ),
                            ),
                          ),
                          const SizedBox(height: 32), 
                          SafeArea(child: SizedBox()),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      bottomNavigationBar: _isDialogOpen ? null : AppBottomBar(
        selectedIndex: 1,
        onHomeTap: () {
          Get.offAll(() => dash.DashboardScreen());
        },
        onMenuTap: () {
          Get.offAll(() => menu.MenuScreen());
        },
        onReportsTap: () {
          Get.to(() => report.ReportsScreen(from: 'create_order'));
        },
        onOrderListTap: () => Get.offAll(() => OrderListScreen(from: 'create_order')),
      ),
    );
  }

  
  Future<void> _showOrderSuccessDialog() async {
    
    SystemSound.play(SystemSoundType.click);
    
    return showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return TweenAnimationBuilder<double>(
          duration: const Duration(milliseconds: 800),
          tween: Tween(begin: 0.0, end: 1.0),
          builder: (context, value, child) {
            return Transform.scale(
              scale: 0.8 + (0.2 * value),
              child: Opacity(
                opacity: value,
                child: Dialog(
                  backgroundColor: Colors.transparent,
                  child: Container(
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(20),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.1),
                          blurRadius: 20,
                          offset: const Offset(0, 10),
                        ),
                      ],
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        
                        TweenAnimationBuilder<double>(
                          duration: const Duration(milliseconds: 600),
                          tween: Tween(begin: 0.0, end: 1.0),
                          builder: (context, circleValue, child) {
                            return Container(
                              width: 80,
                              height: 80,
                              decoration: BoxDecoration(
                                color: const Color(0xFF007AFF).withOpacity(circleValue),
                                shape: BoxShape.circle,
                              ),
                              child: Center(
                                child: TweenAnimationBuilder<double>(
                                  duration: const Duration(milliseconds: 400),
                                  tween: Tween(begin: 0.0, end: 1.0),
                                  builder: (context, checkValue, child) {
                                    return Transform.scale(
                                      scale: checkValue,
                                      child: const Icon(
                                        Icons.check,
                                        color: Colors.white,
                                        size: 40,
                                      ),
                                    );
                                  },
                                ),
                              ),
                            );
                          },
                        ),
                        const SizedBox(height: 24),
                        
                        TweenAnimationBuilder<double>(
                          duration: const Duration(milliseconds: 400),
                          tween: Tween(begin: 0.0, end: 1.0),
                          builder: (context, textValue, child) {
                            return Opacity(
                              opacity: textValue,
                              child: Transform.translate(
                                offset: Offset(0, 20 * (1 - textValue)),
                                child: const Text(
                                  'Order Created Successfully!',
                                  style: TextStyle(
                                    fontSize: 20,
                                    fontWeight: FontWeight.bold,
                                    color: Colors.black,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                              ),
                            );
                          },
                        ),
                        const SizedBox(height: 16),
                        
                        TweenAnimationBuilder<double>(
                          duration: const Duration(milliseconds: 400),
                          tween: Tween(begin: 0.0, end: 1.0),
                          builder: (context, subtitleValue, child) {
                            return Opacity(
                              opacity: subtitleValue,
                              child: Transform.translate(
                                offset: Offset(0, 20 * (1 - subtitleValue)),
                                child: const Text(
                                  'Your order has been created and is being processed.',
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                              ),
                            );
                          },
                        ),
                        const SizedBox(height: 32),
                        
                        TweenAnimationBuilder<double>(
                          duration: const Duration(milliseconds: 400),
                          tween: Tween(begin: 0.0, end: 1.0),
                          builder: (context, buttonValue, child) {
                            return Opacity(
                              opacity: buttonValue,
                              child: Transform.translate(
                                offset: Offset(0, 20 * (1 - buttonValue)),
                                child: SizedBox(
                                  width: double.infinity,
                                  child: ElevatedButton(
                                    onPressed: () {
                                      Navigator.of(context).pop();
                                    },
                                    style: ElevatedButton.styleFrom(
                                      backgroundColor: const Color(0xFF007AFF),
                                      foregroundColor: Colors.white,
                                      padding: const EdgeInsets.symmetric(vertical: 16),
                                      shape: RoundedRectangleBorder(
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      elevation: 0,
                                    ),
                                    child: const Text(
                                      'OK',
                                      style: TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.w600,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  
  Widget _buildProductDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SizedBox(
          width: 80,
          child: Text(
            label,
            style: GoogleFonts.inter(
              fontWeight: FontWeight.w600,
              fontSize: 14,
              color: const Color(0xFF495057),
            ),
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(
              fontWeight: FontWeight.w400,
              fontSize: 14,
              color: value.isEmpty ? const Color(0xFF6C757D) : const Color(0xFF212529),
            ),
          ),
        ),
      ],
    );
  }

  
  Widget _orderDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 15)),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }
}

class _OrderField extends StatefulWidget {
  final String hint;
  final TextInputType? keyboardType;
  final bool isRequired;
  final TextEditingController? controller;
  final IconData? prefixIcon;
  final IconData? suffixIcon;
  final String? fieldType; 
  final bool showRedBorderAndLabel;
  final bool enabled;
  const _OrderField({Key? key, required this.hint, this.keyboardType, this.isRequired = false, this.controller, this.prefixIcon, this.suffixIcon, this.fieldType, this.showRedBorderAndLabel = false, this.enabled = true}) : super(key: key);

  @override
  State<_OrderField> createState() => _OrderFieldState();
}

class _OrderFieldState extends State<_OrderField> {
  TextEditingController get _controller => widget.controller ?? _internalController;
  final TextEditingController _internalController = TextEditingController();
  bool _showError = false;
  String? _errorText;

  @override
  void initState() {
    super.initState();
  }

  bool validate() {
    if (!widget.isRequired) return true;
    final value = _controller.text.trim();
    bool isValid = value.isNotEmpty;
    String? errorText;
    if (isValid && widget.fieldType == 'email') {
      final emailRegex = RegExp(r"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}");
      if (!emailRegex.hasMatch(value)) {
        isValid = false;
        errorText = 'Invalid email';
      }
    }
    if (isValid && widget.fieldType == 'phone') {
      final phoneRegex = RegExp(r"^(\+\d{1,3}[- ]?)?\d{10,15}$");
      if (!phoneRegex.hasMatch(value)) {
        isValid = false;
        errorText = 'Invalid phone number';
      }
    }
    setState(() {
      _showError = !isValid;
      _errorText = errorText;
    });
    return isValid;
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4), 
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Material(
            elevation: 1.5,
            shadowColor: Colors.black12,
            borderRadius: BorderRadius.circular(12),
            child: TextFormField(
              controller: _controller,
              keyboardType: widget.keyboardType,
              enabled: widget.enabled,
              style: GoogleFonts.poppins(fontSize: 13, color: widget.enabled ? Colors.black : Colors.grey[600]), 
              decoration: InputDecoration(
                labelText: widget.isRequired ? widget.hint + ' *' : widget.hint,
                labelStyle: GoogleFonts.poppins(
                  fontWeight: FontWeight.w500,
                  fontSize: 13,
                  color: widget.showRedBorderAndLabel ? Colors.red : (widget.enabled ? Colors.grey[700] : Colors.grey[500]),
                ),
                filled: true,
                fillColor: widget.enabled ? const Color(0xFFF5F5F7) : Colors.grey[200],
                contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(color: widget.showRedBorderAndLabel ? Colors.red : (_showError ? Colors.red : Colors.transparent), width: widget.showRedBorderAndLabel || _showError ? 1.5 : 1),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(color: widget.showRedBorderAndLabel ? Colors.red : (_showError ? Colors.red : Color(0xFF007AFF)), width: 2),
                ),
                disabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(color: Colors.transparent, width: 0),
                ),
              ),
              autovalidateMode: AutovalidateMode.onUserInteraction,
              
            ),
          ),
          if (_showError)
            Padding(
              padding: const EdgeInsets.only(left: 12, top: 4),
              child: Text(
                _errorText ?? 'Required',
                style: TextStyle(color: Colors.red, fontSize: 12, fontFamily: 'SF Pro Display'),
              ),
            ),
        ],
      ),
    );
  }
}

class _OrderDropdownField extends StatelessWidget {
  final String hint;
  final List<String> items;
  final String? value;
  final void Function(String?)? onChanged;
  final IconData? prefixIcon;
  const _OrderDropdownField({required this.hint, required this.items, this.value, this.onChanged, this.prefixIcon});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6), 
      child: Material(
        elevation: 1.5,
        shadowColor: Colors.black12,
        borderRadius: BorderRadius.circular(12),
        child: DropdownButtonFormField<String>(
          value: value,
          items: items.map((e) => DropdownMenuItem(
            value: e,
            child: Text(e, style: GoogleFonts.poppins(fontSize: 13)), 
          )).toList(),
          onChanged: onChanged,
          decoration: InputDecoration(
            labelText: hint,
            labelStyle: GoogleFonts.poppins(fontWeight: FontWeight.w500, fontSize: 13, color: Colors.grey[700]),
            prefixIcon: prefixIcon != null ? Icon(prefixIcon, color: Colors.grey[600]) : null,
            filled: true,
            fillColor: const Color(0xFFF5F5F7),
            contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10), 
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: Colors.transparent),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
            ),
            errorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: Colors.red, width: 1.5),
            ),
            focusedErrorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12),
              borderSide: BorderSide(color: Colors.red, width: 2),
            ),
          ),
          icon: const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
        ),
      ),
    );
  }
}

class _OrderDetailRow extends StatelessWidget {
  final String label;
  final String value;
  const _OrderDetailRow({required this.label, required this.value});
  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          Expanded(
            flex: 2,
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text(label, style: const TextStyle(fontWeight: FontWeight.w500, fontFamily: 'SF Pro Display', fontSize: 14)),
            ),
          ),
          Expanded(
            flex: 3,
            child: Align(
              alignment: Alignment.center,
              child: Text(value, style: const TextStyle(fontFamily: 'SF Pro Display', fontSize: 14)),
            ),
          ),
        ],
      ),
    );
  }
}

class _CitySearchDialog extends StatefulWidget {
  final List<String> cities;
  final String? initialCity;
  const _CitySearchDialog({Key? key, required this.cities, this.initialCity}) : super(key: key);

  @override
  State<_CitySearchDialog> createState() => _CitySearchDialogState();
}

class _CitySearchDialogState extends State<_CitySearchDialog> {
  late List<String> filteredCities;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredCities = widget.cities;
    searchController = TextEditingController();
    selected = widget.initialCity;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredCities = widget.cities.where((c) => c.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select City', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredCities.isEmpty
                              ? const Center(child: Text('No cities found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredCities.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final city = filteredCities[i];
                                    final isSelected = city == selected;
                                    return ListTile(
                                      title: Text(
                                        city,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(city);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _PaymentTypeDialog extends StatefulWidget {
  final List<String> paymentTypes;
  final String selectedPaymentType;
  const _PaymentTypeDialog({Key? key, required this.paymentTypes, required this.selectedPaymentType}) : super(key: key);

  @override
  State<_PaymentTypeDialog> createState() => _PaymentTypeDialogState();
}

class _PaymentTypeDialogState extends State<_PaymentTypeDialog> {
  late List<String> filteredPaymentTypes;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredPaymentTypes = widget.paymentTypes;
    searchController = TextEditingController();
    selected = widget.selectedPaymentType;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredPaymentTypes = widget.paymentTypes.where((p) => p.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select Payment Type', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredPaymentTypes.isEmpty
                              ? const Center(child: Text('No payment types found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredPaymentTypes.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final paymentType = filteredPaymentTypes[i];
                                    final isSelected = paymentType == selected;
                                    return ListTile(
                                      title: Text(
                                        paymentType,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(paymentType);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'dart:math' as math;
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../controllers/dashboard_controller.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'menu.dart';
import 'report.dart';
import 'package:fl_chart/fl_chart.dart';
import 'create_order.dart';
import 'order_list_screen.dart';
import 'notification_screen.dart';
import 'dashboard_notification_screen.dart';


import '../widgets/courier_logo_widget.dart';
import '../widgets/custom_date_selector.dart';
import '../widgets/snake_graph_widget.dart';
import '../models/courier_model.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../utils/Colors/color_resources.dart';

class DashboardScreen extends StatefulWidget {
  DashboardScreen({Key? key}) : super(key: key);

  @override
  State<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen> with WidgetsBindingObserver {
  late final DashboardController controller;
  
  // Static variable to preserve date range across screen navigations
  static DateTimeRange? _lastUserSelectedDateRange;
  
  final Rx<DateTimeRange> _currentDateRange = Rx<DateTimeRange>(
    _lastUserSelectedDateRange ?? DateTimeRange(
      start: DateTime.now().subtract(const Duration(days: 3)),
      end: DateTime.now(),
    ),
  );
  


  
  String _formatNumber(dynamic value) {
    if (value == null) return '0';
    
    
    String numStr = value.toString();
    
    
    List<String> parts = numStr.split('.');
    String integerPart = parts[0];
    String decimalPart = parts.length > 1 ? '.${parts[1]}' : '';
    
    
    String formattedInteger = '';
    for (int i = 0; i < integerPart.length; i++) {
      if (i > 0 && (integerPart.length - i) % 3 == 0) {
        formattedInteger += ',';
      }
      formattedInteger += integerPart[i];
    }
    
    return formattedInteger + decimalPart;
  }

  
  String _getDateRangeFormatted(DateTime start, DateTime end) {
    String format(DateTime d) =>
        '${d.day.toString().padLeft(2, '0')}-${d.month.toString().padLeft(2, '0')}-${d.year}';
    return '${format(start)} to ${format(end)}';
  }

  
  double _calculateAmplitude(double amount) {
    
    
    double baseAmplitude = 10.0;
    double scaleFactor = 0.0001;
    double additionalAmplitude = amount * scaleFactor;
    
    
    return math.min(baseAmplitude + additionalAmplitude, 25.0);
  }

  
  double _calculateFrequency(double amount) {
    
    
    double baseFrequency = 0.3;
    double scaleFactor = 0.00001;
    double additionalFrequency = amount * scaleFactor;
    
    
    return math.min(baseFrequency + additionalFrequency, 1.2);
  }




  @override
  void initState() {
    super.initState();
    
    // Register lifecycle observer
    WidgetsBinding.instance.addObserver(this);
    
    if (!Get.isRegistered<DashboardController>()) {
      try {
        Get.put(DashboardController());
      } catch (_) {
        Get.lazyPut<DashboardController>(() => DashboardController());
      }
    }
    controller = Get.find<DashboardController>();
    
    // Use preserved date range or default to last 4 days
    if (_lastUserSelectedDateRange != null) {
      _currentDateRange.value = _lastUserSelectedDateRange!;
      // Fetch data with the preserved date range
      _fetchDashboardDataWithRange(_lastUserSelectedDateRange!.start, _lastUserSelectedDateRange!.end);
    } else {
      // Only fetch default data if no preserved range exists
      _fetchDashboardData();
    }
    
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.white,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
      systemNavigationBarDividerColor: Colors.transparent,
    ));
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.white,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
      systemNavigationBarDividerColor: Colors.transparent,
    ));
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    
    // When app comes back into focus, restore the preserved date range
    if (state == AppLifecycleState.resumed) {
      if (_lastUserSelectedDateRange != null) {
        _currentDateRange.value = _lastUserSelectedDateRange!;
        // Refresh data with the preserved date range
        _fetchDashboardDataWithRange(_lastUserSelectedDateRange!.start, _lastUserSelectedDateRange!.end);
      }
    }
  }

  @override
  void dispose() {
    // Remove lifecycle observer
    WidgetsBinding.instance.removeObserver(this);
    
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.white,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
      systemNavigationBarDividerColor: Colors.transparent,
    ));
    super.dispose();
  }

  Future<void> _fetchDashboardData({bool forceRefresh = false}) async {
    
    final endDate = DateTime.now(); 
    final startDate = endDate.subtract(const Duration(days: 3));
    
    await _fetchDashboardDataWithRange(startDate, endDate, forceRefresh: forceRefresh);
  }

  Future<void> _fetchDashboardDataWithRange(DateTime startDate, DateTime endDate, {bool forceRefresh = false}) async {
    final startStr = '${startDate.year}-${startDate.month.toString().padLeft(2, '0')}-${startDate.day.toString().padLeft(2, '0')}';
    final endStr = '${endDate.year}-${endDate.month.toString().padLeft(2, '0')}-${endDate.day.toString().padLeft(2, '0')}';
    
    
    
    
    _currentDateRange.value = DateTimeRange(start: startDate, end: endDate);
    
    await controller.fetchDashboardData(startDate: startStr, endDate: endStr, forceRefresh: forceRefresh);
  }

  @override
  Widget build(BuildContext context) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: [SystemUiOverlay.top, SystemUiOverlay.bottom]);

    return ConnectivityWrapper(
      showOfflineUI: true,
      child: AnnotatedRegion<SystemUiOverlayStyle>(
        value: const SystemUiOverlayStyle(
          statusBarColor: Colors.white,
          statusBarIconBrightness: Brightness.dark,
          statusBarBrightness: Brightness.light,
          systemNavigationBarColor: Colors.white,
          systemNavigationBarIconBrightness: Brightness.dark,
          systemNavigationBarDividerColor: Colors.transparent,
        ),
        child: Scaffold(
      extendBody: true,
      extendBodyBehindAppBar: false,
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        surfaceTintColor: Colors.white,
        elevation: 0,
        foregroundColor: Colors.white,
        automaticallyImplyLeading: false,
        systemOverlayStyle: SystemUiOverlayStyle.dark,
        title: SvgPicture.asset(
          'assets/Frame.svg',
          width: 50,
          height: 30,
          color: Color(0xFF007AFF),
        ),
        actions: [
                        IconButton(
              icon: SvgPicture.asset(
    'assets/Calender.svg', 
    width: 24,
    height: 24,
     
  ),
              onPressed: () async {
                
                final picked = await showModalBottomSheet<DateTimeRange>(
                  context: context,
                  isScrollControlled: true,
                  backgroundColor: Colors.transparent,
                  builder: (context) => Container(
                    width: MediaQuery.of(context).size.width,
                    height: MediaQuery.of(context).size.height * 0.6,
                    decoration: const BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                    ),
                    child: CustomDateSelector(
                      initialStartDate: _currentDateRange.value.start,
                      initialEndDate: _currentDateRange.value.end,
                    ),
                  ),
                );
                if (picked != null) {
                  await _fetchDashboardDataWithRange(picked.start, picked.end);
                }
              },
            ),
          ],
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
        ),
      ),
      body: SafeArea(
        child: Obx(() {
          if (controller.isLoading.value) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  
                  Container(
                    width: 80,
                    height: 80,
                    child: Stack(
                      children: [
                        
                        Center(
                          child: SizedBox(
                            width: 60,
                            height: 60,
                            child: CircularProgressIndicator(
                              strokeWidth: 3,
                              valueColor: AlwaysStoppedAnimation<Color>(
                                Color(0xFF007AFF).withOpacity(0.3),
                              ),
                            ),
                          ),
                        ),
                        
                        Center(
                          child: SizedBox(
                            width: 40,
                            height: 40,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(
                                Color(0xFF007AFF),
                              ),
                            ),
                          ),
                        ),
                        
                        Center(
                          child: TweenAnimationBuilder<double>(
                            duration: Duration(milliseconds: 1000),
                            tween: Tween(begin: 0.0, end: 1.0),
                            builder: (context, value, child) {
                              return Transform.scale(
                                scale: 0.5 + (0.5 * value),
                                child: Container(
                                  width: 12,
                                  height: 12,
                                  decoration: BoxDecoration(
                                    color: Color(0xFF007AFF),
                                    shape: BoxShape.circle,
                                  ),
                                ),
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                  SizedBox(height: 24),
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  SizedBox(height: 16),
                  Text(
                    '',
                    style: GoogleFonts.inter(
                      fontSize: 14,
                      color: Colors.grey[600],
                    ),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            );
          }
          
          if (controller.error.value.isNotEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline_rounded, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text(
                    '',
                    style: GoogleFonts.inter(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                      color: Colors.grey,
                    ),
                  ),
                  SizedBox(height: 8),
                  Text(
                    controller.error.value,
                    style: GoogleFonts.inter(
                      fontSize: 14,
                      color: Colors.grey,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: _fetchDashboardData,
                    child: Text('Retry'),
                  ),
                ],
              ),
            );
          }
          
          return RefreshIndicator(
            onRefresh: () async {
              await _fetchDashboardData(forceRefresh: true);
            },
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: AnimationLimiter(
                child: Padding(
                  padding: EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 600),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 50.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              'Dashboard',
                              style: GoogleFonts.inter(
                                fontSize: 24,
                                fontWeight: FontWeight.bold,
                                color: Colors.black,
                              ),
                            ),
                            Obx(() {
                              final range = _currentDateRange.value;
                              final today = DateTime.now();
                              final isEndDateToday = range.end.year == today.year && 
                                                   range.end.month == today.month && 
                                                   range.end.day == today.day;
                              
                              String displayText;
                              if (isEndDateToday) {
                                final days = range.end.difference(range.start).inDays + 1;
                                displayText = 'Last $days Days';
                              } else {
                                displayText = _getDateRangeFormatted(range.start, range.end);
                              }
                              
                              return Container(
                                padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                                decoration: BoxDecoration(
                                  color: Color(0xFFE8F4FD),
                                  borderRadius: BorderRadius.circular(20),
                                ),
                                child: Text(
                                  displayText,
                                  style: GoogleFonts.poppins(
                                    color: Color(0xFF007AFF),
                                    fontSize: isEndDateToday ? 12 : 10,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              );
                            }),
                          ],
                        ),
                        SizedBox(height: 20),

                        
                        Container(
                          width: MediaQuery.of(context).size.width, 
                          padding: EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Current Outstandings',
                                style: GoogleFonts.inter(
                                  fontSize: 14,
                                  color: Color(0xFF666666),
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              SizedBox(height: 2),
                              Row(
                                children: [
                                  Expanded(
                                    child: Obx(() => Text(
                                      'PKR ${_formatNumber(controller.totalCurrentOutstanding.value)}',
                                      style: GoogleFonts.inter(
                                        fontSize: 20,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.black,
                                      ),
                                    )),
                                  ),
                                  SizedBox(
                                    width: 100,
                                    height: 50,
                                    child: Obx(() => CustomPaint(
                                      painter: SineWavePainter(
                                        color: const Color(0xFF007AFF),
                                        amplitude: _calculateAmplitude(controller.totalCurrentOutstanding.value),
                                        frequency: _calculateFrequency(controller.totalCurrentOutstanding.value),
                                      ),
                                      size: const Size(100, 50),
                                    )),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                        SizedBox(height: 20),

                        // Total Outstanding Card
                        Container(
                          width: MediaQuery.of(context).size.width,
                          padding: EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Total Outstanding',
                                style: GoogleFonts.inter(
                                  fontSize: 14,
                                  color: Color(0xFF666666),
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                              SizedBox(height: 2),
                              Row(
                                children: [
                                  Expanded(
                                    child: Obx(() => Text(
                                      'PKR ${_formatNumber(controller.totalOutstanding.value)}',
                                      style: GoogleFonts.inter(
                                        fontSize: 20,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.black,
                                      ),
                                    )),
                                  ),
                                  SizedBox(
                                    width: 100,
                                    height: 50,
                                    child: Obx(() => CustomPaint(
                                      painter: SineWavePainter(
                                        color: const Color(0xFF007AFF),
                                        amplitude: _calculateAmplitude(controller.totalOutstanding.value),
                                        frequency: _calculateFrequency(controller.totalOutstanding.value),
                                      ),
                                      size: const Size(100, 50),
                                    )),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                        SizedBox(height: 20),

                        
                        Container(
                          width: MediaQuery.of(context).size.width, 
                          padding: EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'Orders',
                                      style: TextStyle(
                                        fontSize: 12,
                                        color: Color(0xFF666666),
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    SizedBox(height: 4),
                                    Obx(() => Text(
                                      controller.orders.value.toString(),
                                      style: GoogleFonts.inter(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.black,
                                      ),
                                    )),
                                  ],
                                ),
                              ),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'Revenue',
                                      style: TextStyle(
                                        fontSize: 12,
                                        color: Color(0xFF666666),
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    SizedBox(height: 4),
                                    Obx(() => Text(
                                      'PKR ${_formatNumber(controller.revenue.value)}',
                                      style: GoogleFonts.inter(
                                        fontSize: 14,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.black,
                                      ),
                                    )),
                                  ],
                                ),
                              ),
                              SizedBox(width: 16),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'Product Sold',
                                      style: TextStyle(
                                        fontSize: 12,
                                        color: Color(0xFF666666),
                                        fontWeight: FontWeight.w500,
                                      ),
                                    ),
                                    SizedBox(height: 4),
                                    Obx(() => Text(
                                      controller.productsSold.value.toString(),
                                      style: GoogleFonts.inter(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold,
                                        color: Colors.black,
                                      ),
                                    )),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                        SizedBox(height: 20),

                        
                        Obx(() {
                          final courierPaymentData = controller.courierPaymentData;
                          final isLoading = controller.isLoading.value;
                          
                          
                          
                          if (isLoading) {
                            return Column(
                              children: [
                                Container(
                                  padding: EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: Color(0xFFF3F3F3),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Row(
                                    children: [
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Container(
                                              width: 100,
                                              height: 14,
                                              decoration: BoxDecoration(
                                                color: Colors.grey[300],
                                                borderRadius: BorderRadius.circular(4),
                                              ),
                                            ),
                                            SizedBox(height: 8),
                                            Container(
                                              width: 80,
                                              height: 20,
                                              decoration: BoxDecoration(
                                                color: Colors.grey[300],
                                                borderRadius: BorderRadius.circular(4),
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                      SizedBox(width: 8),
                                      Container(
                                        width: 96,
                                        height: 60,
                                        decoration: BoxDecoration(
                                          color: Colors.grey[300],
                                          borderRadius: BorderRadius.circular(4),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                SizedBox(height: 16),
                                Container(
                                  padding: EdgeInsets.all(16),
                                  decoration: BoxDecoration(
                                    color: Color(0xFFF3F3F3),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Row(
                                    children: [
                                      Expanded(
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Container(
                                              width: 100,
                                              height: 14,
                                              decoration: BoxDecoration(
                                                color: Colors.grey[300],
                                                borderRadius: BorderRadius.circular(4),
                                              ),
                                            ),
                                            SizedBox(height: 8),
                                            Container(
                                              width: 80,
                                              height: 20,
                                              decoration: BoxDecoration(
                                                color: Colors.grey[300],
                                                borderRadius: BorderRadius.circular(4),
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                      SizedBox(width: 8),
                                      Container(
                                        width: 96,
                                        height: 60,
                                        decoration: BoxDecoration(
                                          color: Colors.grey[300],
                                          borderRadius: BorderRadius.circular(4),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ],
                            );
                          }
                          
                          if (courierPaymentData.isEmpty) {
                            
                            return Column(
                              children: [
                                PaymentCard(
                                  title: 'Pending Payment',
                                  amount: 'Rs. 0',
                                  shipment: '0',
                                ),
                                SizedBox(height: 16),
                                PaymentCard(
                                  title: 'Pending Payment',
                                  amount: 'Rs. 0',
                                  shipment: '0',
                                ),
                              ],
                            );
                          }
                          
                          
                          return Column(
                            children: courierPaymentData.map((courier) {
                               
                               
                               return Padding(
                                 padding: EdgeInsets.only(bottom: 16),
                                 child: PaymentCard(
                                   title: 'Pending Payment',
                                   amount: 'Rs. ${_formatNumber(courier.pendingPayment)}',
                                   shipment: '${courier.shipments}',
                                   logoUrl: courier.logo,
                                   pngUrl: courier.png,
                                   courierName: courier.courierName,
                                 ),
                               );
                             }).toList(),
                          );
                        }),
                        SizedBox(height: 20),

                        
                        Text(
                          'Order Status',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.black,
                          ),
                        ),
                        SizedBox(height: 12),
                        Container(
                          width: MediaQuery.of(context).size.width, 
                          padding: EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [

                              Center(
                                child: SizedBox(
                                  width: 180,
                                  height: 180,
                                  child: Obx(() {
                                    final statusData = controller.orderStatusSummary;
                                    
                                    
                                    if (statusData.isEmpty) {
                                      return Column(
                                        mainAxisAlignment: MainAxisAlignment.center,
                                        children: [
                                          Text(
                                            'No Data',
                                            style: TextStyle(
                                              fontSize: 14,
                                              color: Color(0xFF8E8E93),
                                              fontWeight: FontWeight.w400,
                                            ),
                                          ),
                                          Text(
                                            '0',
                                            style: TextStyle(
                                              fontSize: 28,
                                              fontWeight: FontWeight.bold,
                                              color: Colors.black,
                                            ),
                                          ),
                                        ],
                                      );
                                    }
                                    
                                    
                                    final allowedStatuses = [
                                      'Booked',
                                      'Arrived at Courier Facility',
                                      'In Transit',
                                      'Delivered',
                                    ];
                                    
                                    
                                    final dynamicColors = [
                                      Color(0xFF007AFF), 
                                      Color(0xFFFFD1DC), 
                                      Color(0xFFFFD60A), 
                                      Color(0xFFA3FFB0), 
                                    ];
                                    
                                    
                                    final filteredStatuses = statusData.where((item) => 
                                      allowedStatuses.contains(item.name)
                                    ).toList();
                                    
                                    
                                    filteredStatuses.sort((a, b) => 
                                      allowedStatuses.indexOf(a.name).compareTo(allowedStatuses.indexOf(b.name))
                                    );
                                    
                                    final sections = <PieChartSectionData>[];
                                    int totalShownStatuses = 0;
                                    
                                    for (int i = 0; i < filteredStatuses.length; i++) {
                                      final item = filteredStatuses[i];
                                      
                                      final statusIndex = allowedStatuses.indexOf(item.name);
                                      final color = dynamicColors[statusIndex % dynamicColors.length];
                                      
                                      sections.add(
                                        PieChartSectionData(
                                          color: color,
                                          value: item.quantity.toDouble(),
                                          radius: 24,
                                          showTitle: false,
                                        ),
                                      );
                                      totalShownStatuses += item.quantity;
                                    }
                                    return Stack(
                                      alignment: Alignment.center,
                                      children: [
                                        PieChart(
                                          PieChartData(
                                            sections: sections,
                                            centerSpaceRadius: 48,
                                            sectionsSpace: 0,
                                            startDegreeOffset: -90,
                                            borderData: FlBorderData(show: false),
                                          ),
                                        ),
                                        Column(
                                          mainAxisAlignment: MainAxisAlignment.center,
                                          children: [
                                            Text(
                                              'Total',
                                              style: TextStyle(
                                                fontSize: 14,
                                                color: Color(0xFF8E8E93),
                                                fontWeight: FontWeight.w400,
                                              ),
                                            ),
                                            Text(
                                              totalShownStatuses.toString(),
                                              style: TextStyle(
                                                fontSize: 28,
                                                fontWeight: FontWeight.bold,
                                                color: Colors.black,
                                              ),
                                            ),
                                          ],
                                        ),
                                      ],
                                    );
                                  }),
                                ),
                              ),
                              SizedBox(height: 16),
                              
                              Obx(() {
                                final statusData = controller.orderStatusSummary;
                                
                                if (statusData.isEmpty) {
                                  return Column(
                                    children: [
                                      _StatusRow(
                                        color: Color(0xFF007AFF),
                                        label: 'No Data',
                                        value: '0',
                                      ),
                                    ],
                                  );
                                }
                                
                                final statusOrder = [
                                      'Booked',
                                      'Arrived at Courier Facility',
                                      'In Transit',
                                      'Delivered',
                                    ];
                                final statusColors = {
                                  'Booked': Color(0xFF007AFF), 
                                  'Arrived': Color(0xFFFFD1DC), 
                                  'Arrived at Courier Facility': Color(0xFFFFD1DC), 
                                  'In Transit': Color(0xFFFFD600), 
                                  'Delivered': Color(0xFFA3FFB0), 
                                };
                                final filtered = statusData.where((item) => statusOrder.contains(item.name)).toList();
                                
                                // Sort by status order instead of quantity to maintain consistent display order
                                filtered.sort((a, b) => statusOrder.indexOf(a.name).compareTo(statusOrder.indexOf(b.name)));
                                return Column(
                                  children: filtered.map((item) {
                                    final color = statusColors[item.name] ?? Colors.grey;
                                    return Padding(
                                      padding: EdgeInsets.only(bottom: 8),
                                      child: _StatusRow(
                                        color: color,
                                        label: item.name,
                                        value: '${item.quantity}',
                                      ),
                                    );
                                  }).toList(),
                                );
                              }),
                            ],
                          ),
                        ),
                        SizedBox(height: 24),
                        Text(
                          'Order Status Summary',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.black,
                          ),
                        ),
                        SizedBox(height: 12),
                        Container(
                          width: MediaQuery.of(context).size.width, 
                          padding: EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Obx(() {
                                final statusData = controller.orderStatusSummary;
                                
                                
                                if (statusData.isEmpty) {
                                  return Column(
                                    children: [
                                      Text('No order status data available'),
                                      SizedBox(height: 8),
                                      Row(
                                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                        children: [
                                          Text(
                                            'Total Orders:',
                                            style: TextStyle(
                                              fontSize: 15,
                                              color: Color(0xFF8E8E93),
                                              fontWeight: FontWeight.w700,
                                            ),
                                          ),
                                          Text(
                                            '0',
                                            style: TextStyle(
                                              fontSize: 18,
                                              color: Colors.black,
                                              fontWeight: FontWeight.w700,
                                            ),
                                          ),
                                        ],
                                      ),
                                      SizedBox(height: 4),
                                      Row(
                                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                        children: [
                                          Text(
                                            'Total Amount:',
                                            style: TextStyle(
                                              fontSize: 15,
                                              color: Color(0xFF8E8E93),
                                              fontWeight: FontWeight.w400,
                                            ),
                                          ),
                                          Obx(() => Text(
                                            'Rs ${_formatNumber(controller.totalAmount.value)}',
                                            style: TextStyle(
                                              fontSize: 16,
                                              color: Colors.black,
                                              fontWeight: FontWeight.w700,
                                            ),
                                          )),
                                        ],
                                      ),
                                    ],
                                  );
                                }
                                
                                return Column(
                                  children: [
                                    ...statusData.map((item) {
                                      final progress = controller.totalOrders.value > 0 
                                          ? item.quantity / controller.totalOrders.value 
                                          : 0.0;
                                      
                                      return Padding(
                                        padding: const EdgeInsets.only(bottom: 16),
                                        child: _OrderStatusSummaryRow(
                                          label: item.name,
                                          progress: progress,
                                          amount: 'Rs. ${_formatNumber(item.amount)}',
                                          count: '${item.quantity}',
                                        ),
                                      );
                                    }),
                                    SizedBox(height: 8),
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'Total Orders:',
                                          style: TextStyle(
                                            fontSize: 15,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        ),
                                        Obx(() => Text(
                                          '${controller.totalOrders.value}',
                                          style: TextStyle(
                                            fontSize: 18,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        )),
                                      ],
                                    ),
                                    SizedBox(height: 4),
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'Total Amount:',
                                          style: TextStyle(
                                            fontSize: 15,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        ),
                                        Obx(() => Text(
                                          'Rs ${_formatNumber(controller.totalAmount.value)}',
                                          style: TextStyle(
                                            fontSize: 16,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        )),
                                      ],
                                    ),
                                  ],
                                );
                              }),
                            ],
                          ),
                        ),
                        SizedBox(height: 24),
                        Text(
                          'Failed Attempt',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.black,
                          ),
                        ),
                        SizedBox(height: 12),
                        Container(
                          width: MediaQuery.of(context).size.width, 
                          padding: EdgeInsets.all(20),
                          decoration: BoxDecoration(
                            color: Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Obx(() {
                                final failedData = controller.failedStatusSummary;
                                
                                
                                if (failedData.isEmpty) {
                                  return Column(
                                    children: [
                                      Text('No failed attempt data available'),
                                      SizedBox(height: 8),
                                      Row(
                                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                        children: [
                                          Text(
                                            'Total Failed Attempt:',
                                            style: TextStyle(
                                              fontSize: 15,
                                              color: Colors.black,
                                              fontWeight: FontWeight.w700,
                                            ),
                                          ),
                                          Obx(() => Text(
                                            '${controller.totalFailedOrders.value}',
                                            style: TextStyle(
                                              fontSize: 18,
                                              color: Colors.black,
                                              fontWeight: FontWeight.w700,
                                            ),
                                          )),
                                        ],
                                      ),
                                      SizedBox(height: 4),
                                      Row(
                                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                        children: [
                                          Text(
                                            'Total Amount:',
                                            style: TextStyle(
                                              fontSize: 15,
                                              color: Colors.black,
                                              fontWeight: FontWeight.w700,
                                            ),
                                          ),
                                          Obx(() => Text(
                                            'Rs ${_formatNumber(controller.totalFailedAmount.value)}',
                                            style: TextStyle(
                                              fontSize: 16,
                                              color: Colors.black,
                                              fontWeight: FontWeight.w700,
                                            ),
                                          )),
                                        ],
                                      ),
                                    ],
                                  );
                                }
                                
                                return Column(
                                  children: [
                                    ...failedData.map((item) {
                                      final progress = controller.totalFailedOrders.value > 0 
                                          ? item.quantity / controller.totalFailedOrders.value 
                                          : 0.0;
                                      
                                      return Padding(
                                        padding: const EdgeInsets.only(bottom: 16),
                                        child: _FailedAttemptRow(
                                          label: item.name,
                                          progress: progress,
                                          amount: 'Rs. ${_formatNumber(item.amount)}',
                                          count: '${item.quantity}',
                                        ),
                                      );
                                    }),
                                    SizedBox(height: 8),
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'Total Failed Attempt:',
                                          style: TextStyle(
                                            fontSize: 15,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        ),
                                        Obx(() => Text(
                                          '${controller.totalFailedOrders.value}',
                                          style: TextStyle(
                                            fontSize: 18,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        )),
                                      ],
                                    ),
                                    SizedBox(height: 4),
                                    Row(
                                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                      children: [
                                        Text(
                                          'Total Amount:',
                                          style: TextStyle(
                                            fontSize: 15,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        ),
                                        Obx(() => Text(
                                          'Rs ${_formatNumber(controller.totalFailedAmount.value)}',
                                          style: TextStyle(
                                            fontSize: 16,
                                            color: Colors.black,
                                            fontWeight: FontWeight.w700,
                                          ),
                                        )),
                                      ],
                                    ),
                                  ],
                                );
                              }),
                            ],
                          ),
                        ),
                        SizedBox(height: 24),
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                      ],
                    ),
                  ),
                ),
              ),
            ),
          );
        }),
      ),
      bottomNavigationBar: AppBottomBar(
        selectedIndex: 0,
        onHomeTap: () {
          
        },
        onOrderListTap: () => Get.to(() => const OrderListScreen(from: 'dashboard')),
        onReportsTap: () {
          Get.to(() => const ReportsScreen(from: 'dashboard'));
        },
        onMenuTap: () {
          Get.to(() => const MenuScreen());
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => const CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
    )),
    );
  }
}

class MetricCard extends StatelessWidget {
  final String title;
  final String value;

  const MetricCard({
    Key? key,
    required this.title,
    required this.value,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Color(0xFFF3F3F3),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: TextStyle(
              fontSize: 12,
              color: Color(0xFF666666),
              fontWeight: FontWeight.w500,
            ),
          ),
          SizedBox(height: 8),
          Text(
            value,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: Colors.black,
            ),
          ),
        ],
      ),
    );
  }
}

class PaymentCard extends StatelessWidget {
  final String title;
  final String amount;
  final String shipment;
  final String? logoUrl;
  final String? pngUrl;
  final String? courierName;

  const PaymentCard({
    Key? key,
    required this.title,
    required this.amount,
    required this.shipment,
    this.logoUrl,
    this.pngUrl,
    this.courierName,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: MediaQuery.of(context).size.width, 
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Color(0xFFF3F3F3),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                crossAxisAlignment: CrossAxisAlignment.start,
            children: [
                  Expanded(
                    flex: 2,
                    child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: TextStyle(
                      fontSize: 14,
                      color: Color(0xFF666666),
                      fontWeight: FontWeight.w500,
                    ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                  ),
                  SizedBox(height: 4),
                  Text(
                    amount,
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                      color: Colors.black,
                    ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
        ),
                ],
              ),
                  ),
                  SizedBox(width: 8),
                  Flexible(
                    child: CourierLogoWidget(
                      logoUrl: logoUrl,
                      pngUrl: pngUrl,
                      courierId: null, 
                      accountTitle: null, 
                      width: 96,
                      height: 60,
                    ),
                  ),
            ],
          ),
          SizedBox(height: 12),
          Container(
            height: 1,
            color: Color(0xFFE0E0E0),
            margin: EdgeInsets.symmetric(vertical: 8),
          ),
          Row(
            children: [
              Text(
                'Shipment: ',
                style: TextStyle(
                  fontSize: 14,
                  color: Color(0xFF666666),
                ),
              ),
              Expanded(
                child: Text(
                shipment,
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.bold,
                  color: Colors.black,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class ChartPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Color(0xFF007AFF)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final path = Path();
    
    
    final points = [
      Offset(0, size.height * 0.7),
      Offset(size.width * 0.2, size.height * 0.5),
      Offset(size.width * 0.4, size.height * 0.3),
      Offset(size.width * 0.6, size.height * 0.6),
      Offset(size.width * 0.8, size.height * 0.2),
      Offset(size.width, size.height * 0.4),
    ];

    path.moveTo(points[0].dx, points[0].dy);
    for (int i = 1; i < points.length; i++) {
      path.lineTo(points[i].dx, points[i].dy);
    }

    canvas.drawPath(path, paint);
    
    
    final dotPaint = Paint()
      ..color = Color(0xFF007AFF)
      ..style = PaintingStyle.fill;
    
    for (final point in points) {
      canvas.drawCircle(point, 3, dotPaint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
} 



const TextStyle _legendTextStyle = TextStyle(
  fontSize: 14,
  color: Colors.black,
  fontWeight: FontWeight.w400,
);
const TextStyle _legendValueStyle = TextStyle(
  fontSize: 14,
  color: Colors.black,
  fontWeight: FontWeight.w700,
);

class _LegendDot extends StatelessWidget {
  final Color color;
  const _LegendDot({required this.color});
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 10,
      height: 10,
      decoration: BoxDecoration(
        color: color,
        shape: BoxShape.circle,
      ),
    );
  }
} 

class _StatusRow extends StatelessWidget {
  final Color color;
  final String label;
  final String value;
  const _StatusRow({
    required this.color,
    required this.label,
    required this.value,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        _LegendDot(color: color),
        SizedBox(width: 10),
        Expanded(
          child: Text(
            label,
            style: TextStyle(
              fontSize: 14,
              color: Colors.black,
              fontWeight: FontWeight.w400,
            ),
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontSize: 14,
            color: Colors.black,
            fontWeight: FontWeight.w700,
          ),
        ),
      ],
    );
  }
} 

class _OrderStatusSummaryRow extends StatelessWidget {
  final String label;
  final double progress;
  final String amount;
  final String count;

  const _OrderStatusSummaryRow({
    required this.label,
    required this.progress,
    required this.amount,
    required this.count,
  });

  @override
  Widget build(BuildContext context) {
    
    final isZeroValues = (amount.contains('Rs. 0') || amount.contains('0')) && count == '0';
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: Text(
                label,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.black,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            
            if (!isZeroValues) ...[
              Text(
                amount,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.black,
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(width: 8),
              Text('|', style: TextStyle(fontSize: 14, color: Colors.grey)),
              SizedBox(width: 8),
              Text(
                count,
                style: TextStyle(
                  fontSize: 14,
                  color: Color(0xFF8E8E93),
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ],
        ),
        SizedBox(height: 4),
        
        ClipRRect(
          borderRadius: BorderRadius.circular(4),
          child: LinearProgressIndicator(
            value: progress,
            minHeight: 6,
            backgroundColor: Colors.white,
            valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF007AFF)),
          ),
        ),
      ],
    );
  }
} 

class _FailedAttemptRow extends StatelessWidget {
  final String label;
  final double progress;
  final String amount;
  final String count;

  const _FailedAttemptRow({
    required this.label,
    required this.progress,
    required this.amount,
    required this.count,
  });

  @override
  Widget build(BuildContext context) {
    
    final isZeroValues = (amount.contains('Rs. 0') || amount.contains('0')) && count == '0';
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: Text(
                label,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.black,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            
            if (!isZeroValues) ...[
              Text(
                amount,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.black,
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(width: 8),
              Text('|', style: TextStyle(fontSize: 14, color: Colors.grey)),
              SizedBox(width: 8),
              Text(
                count,
                style: TextStyle(
                  fontSize: 14,
                  color: Color(0xFF8E8E93),
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ],
        ),
        SizedBox(height: 4),
        
        ClipRRect(
          borderRadius: BorderRadius.circular(4),
          child: LinearProgressIndicator(
            value: progress,
            minHeight: 6,
            backgroundColor: Colors.white,
            valueColor: AlwaysStoppedAnimation<Color>(Color(0xFFFF5A5F)),
          ),
        ),
      ],
    );
  }
} 

class _AnimatedDots extends StatefulWidget {
  @override
  State<_AnimatedDots> createState() => _AnimatedDotsState();
}

class _AnimatedDotsState extends State<_AnimatedDots>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late List<Animation<double>> _animations;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );
    
    _animations = List.generate(3, (index) {
      return Tween<double>(
        begin: 0.0,
        end: 1.0,
      ).animate(CurvedAnimation(
        parent: _controller,
        curve: Interval(
          index * 0.2,
          (index + 1) * 0.2,
          curve: Curves.easeInOut,
        ),
      ));
    });
    
    _controller.repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(3, (index) {
        return AnimatedBuilder(
          animation: _animations[index],
          builder: (context, child) {
            return Transform.scale(
              scale: 0.5 + (0.5 * _animations[index].value),
              child: Container(
                width: 6,
                height: 6,
                margin: EdgeInsets.symmetric(horizontal: 2),
                decoration: BoxDecoration(
                  color: Color(0xFF007AFF),
                  shape: BoxShape.circle,
                ),
              ),
            );
          },
        );
      }),
    );
  }
} 

class SineWavePainter extends CustomPainter {
  final Color color;
  final double amplitude;
  final double frequency;

  SineWavePainter({
    required this.color,
    required this.amplitude,
    required this.frequency,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final path = Path();
    final centerY = size.height / 2;
    
    
    path.moveTo(0, centerY);
    
    for (double x = 0; x <= size.width; x++) {
      final y = centerY + amplitude * math.sin(frequency * x * math.pi / 50);
      path.lineTo(x, y);
    }

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../models/courier_account.dart';
import '../services/courier_service.dart';
import '../services/auth_service.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../utils/custom_snackbar.dart';
import 'courier_companies_screen.dart';
import 'create_order.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:dio/dio.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;

class AddCourierCompanyScreen extends StatefulWidget {
  final CourierAccount? courierAccount;
  final bool isEdit;
  const AddCourierCompanyScreen({Key? key, this.courierAccount, this.isEdit = false}) : super(key: key);

  @override
  State<AddCourierCompanyScreen> createState() => _AddCourierCompanyScreenState();
}

class _AddCourierCompanyScreenState extends State<AddCourierCompanyScreen> {
  final _formKey = GlobalKey<FormState>();
  String? selectedCourier;
  String? selectedCourierId; 
  String? selectedStatus;
  bool isDefault = false;
  bool obscurePassword = true;
  bool obscureApiKey = true;
  bool isLoadingCouriers = true;
  bool _showCourierError = false;
  bool _showApiKeyError = false;
  bool _showStatusError = false;

  final TextEditingController accountTitleController = TextEditingController();
  final TextEditingController accountNoController = TextEditingController();
  final TextEditingController userController = TextEditingController();
  final TextEditingController passwordController = TextEditingController();
  final TextEditingController apiKeyController = TextEditingController();

  List<Map<String, dynamic>> couriers = [];
  List<String> courierLabels = [];
  String? selectedCourierLabel;
  final List<String> statuses = ['Active', 'Inactive'];
  final CourierService _courierService = CourierService();
  final AuthService _authService = Get.find<AuthService>();

  @override
  void initState() {
    super.initState();
    
    if (!widget.isEdit) {
      _loadUserDataAndFetchCouriers();
    }
    
    if (widget.isEdit) {
      _loadUserDataAndFetchCouriers();
    }
  }

  Future<void> _loadUserDataAndFetchCouriers() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await _loadCouriers();
  }

  Future<void> _loadCouriers() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        customSnackBar('Error', 'User not logged in');
        return;
      }
      
      final courierData = await _courierService.getAllAvailableCouriers(acno);
      couriers = courierData;
      
      courierLabels = couriers.map(_courierDisplayLabel).where((s) => s.isNotEmpty).toList();
      setState(() {
        isLoadingCouriers = false;
      });
      
      if (widget.isEdit && widget.courierAccount != null) {
        _populateFormForEdit();
        setState(() {});
      }
    } catch (e) {
      setState(() {
        isLoadingCouriers = false;
      });
      customSnackBar('Error', 'Failed to load couriers');
    }
  }

  void _populateFormForEdit() {
    final c = widget.courierAccount!;
    
    final courierName = c.courierName;
    final courierData = couriers.firstWhere(
      (courier) => _courierDisplayLabel(courier) == courierName,
      orElse: () => {},
    );
    if (courierData.isNotEmpty) {
      selectedCourier = courierData['name'] ?? courierData['courier_name'] ?? '';
      selectedCourierId = courierData['id']?.toString() ?? '';
      selectedCourierLabel = courierName;
    } else {
      selectedCourier = c.courierName;
      selectedCourierId = c.courierId;
      selectedCourierLabel = courierName;
    }
    accountTitleController.text = c.accountTitle;
    accountNoController.text = c.courierAcno;
    userController.text = c.courierUser;
    passwordController.text = c.courierPassword;
    apiKeyController.text = c.courierApikey;
    selectedStatus = c.status.toLowerCase() == 'active' ? 'Active' : 'Inactive';
    isDefault = c.isDefault == '1';
    if (selectedCourierLabel == null || selectedCourierLabel!.isEmpty) {
      selectedCourierLabel = courierName;
    }
    setState(() {});
  }

  void _showCourierSearchDialog() {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return _CourierSearchDialog(
          couriers: couriers,
          selectedCourier: selectedCourierLabel,
          onCourierSelected: (courierName) {
            
            final selectedCourierData = couriers.firstWhere(
              (courier) => _courierDisplayLabel(courier) == courierName,
              orElse: () => {},
            );
            
            setState(() {
              selectedCourier = selectedCourierData['name'] ?? selectedCourierData['courier_name'] ?? '';
              selectedCourierId = selectedCourierData.isNotEmpty ? selectedCourierData['id']?.toString() : null;
              selectedCourierLabel = courierName;
            });
            
            Navigator.of(context).pop();
          },
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        
        foregroundColor: Colors.white,
        surfaceTintColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black),
          onPressed: () => Navigator.of(context).maybePop(),
        ),
        title: Text(
          widget.isEdit ? 'Edit Courier Company' : 'Add Courier Company',
          style: const TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
          child: Form(
            key: _formKey,
            child: AnimationLimiter(
              child: ListView(
                padding: EdgeInsets.zero,
                children: AnimationConfiguration.toStaggeredList(
                  duration: const Duration(milliseconds: 600),
                  childAnimationBuilder: (widget) => SlideAnimation(
                    verticalOffset: 50.0,
                    child: FadeInAnimation(
                      child: widget,
                    ),
                  ),
                  children: [
                    const SizedBox(height: 10),
                    GestureDetector(
                      onTap: widget.isEdit ? null : () async {
                        setState(() => isLoadingCouriers = true);
                        await _loadUserDataAndFetchCouriers();
                        setState(() => isLoadingCouriers = false);
                        final result = await showModalBottomSheet<String>(
                          context: context,
                          isScrollControlled: true,
                          backgroundColor: Colors.transparent,
                          builder: (ctx) => isLoadingCouriers
                            ? Container(
                                decoration: const BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.only(
                                    topLeft: Radius.circular(20),
                                    topRight: Radius.circular(20),
                                  ),
                                ),
                                child: const SizedBox(
                                  height: 120,
                                  child: Center(child: CircularProgressIndicator(color: Color(0xFF007AFF))),
                                ),
                              )
                            : _CourierSearchDialog(
                                couriers: couriers,
                                selectedCourier: selectedCourier,
                                onCourierSelected: (courierName) {
                                  
                                  final selectedCourierData = couriers.firstWhere(
                                    (courier) => (courier['name'] ?? courier['courier_name'] ?? '') == courierName,
                                    orElse: () => {},
                                  );
                                  setState(() {
                                    selectedCourier = courierName;
                                    selectedCourierId = selectedCourierData.isNotEmpty ? selectedCourierData['id']?.toString() : null;
                                  });
                                  
                                  Navigator.of(ctx).pop(courierName);
                                },
                              ),
                        );
                        if (result != null) {
                          setState(() {
                            
                            selectedCourierLabel = result;
                            selectedCourier = result;
                            _showCourierError = false;
                            _showStatusError = false;
                          });
                        }
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _showCourierError ? Colors.red : Colors.transparent, 
                            width: _showCourierError ? 2 : 1
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: Offset(0, 2),
                            ),
                          ],
                        ),
                        child: Row(
                          children: [
                            Expanded(
                              child: Text(
                                (selectedCourierLabel == null || selectedCourierLabel!.isEmpty) ? 'Select Courier' : selectedCourierLabel!,
                                style: TextStyle(
                                  fontSize: 15, 
                                  color: _showCourierError
                                      ? Colors.red
                                      : widget.isEdit
                                          ? Colors.grey[600]
                                          : (selectedCourierLabel == null || selectedCourierLabel!.isEmpty)
                                              ? Colors.black
                                              : Colors.black,
                                ),
                                overflow: TextOverflow.ellipsis,
                                maxLines: 1,
                              ),
                            ),
                            Icon(
                              widget.isEdit ? Icons.lock : Icons.keyboard_arrow_down_rounded,
                              color: widget.isEdit ? Colors.grey[600] : const Color(0xFF222222),
                            ),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: accountTitleController,
                      decoration: InputDecoration(
                        labelText: 'Account Title',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none),
                        filled: true,
                        fillColor: const Color(0xFFF5F5F7),
                        isDense: true,
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
                        ),
                        errorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                        focusedErrorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                      ),
                      validator: (val) => val == null || val.isEmpty ? 'Enter account title' : null,
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: accountNoController,
                      decoration: InputDecoration(
                        labelText: 'Account No',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none),
                        filled: true,
                        fillColor: const Color(0xFFF5F5F7),
                        isDense: true,
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
                        ),
                        errorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                        focusedErrorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                      ),
                      validator: (val) => val == null || val.isEmpty ? 'Enter account no' : null,
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: userController,
                      decoration: InputDecoration(
                        labelText: 'User',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none),
                        filled: true,
                        fillColor: const Color(0xFFF5F5F7),
                        isDense: true,
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
                        ),
                        errorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                        focusedErrorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                      ),
                      validator: (val) => val == null || val.isEmpty ? 'Enter user' : null,
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: passwordController,
                      obscureText: obscurePassword,
                      decoration: InputDecoration(
                        labelText: 'Password',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none),
                        filled: true,
                        fillColor: const Color(0xFFF5F5F7),
                        isDense: true,
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        suffixIcon: IconButton(
                          icon: Icon(
                            obscurePassword ? Icons.visibility_off : Icons.visibility,
                            color: Colors.grey[600],
                          ),
                          onPressed: () {
                            setState(() {
                              obscurePassword = !obscurePassword;
                            });
                          },
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
                        ),
                        errorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                        focusedErrorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                      ),
                      validator: (val) => val == null || val.isEmpty ? 'Enter password' : null,
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      controller: apiKeyController,
                      obscureText: obscureApiKey,
                      decoration: InputDecoration(
                        labelText: 'API Key',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none),
                        filled: true,
                        fillColor: const Color(0xFFF5F5F7),
                        isDense: true,
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        suffixIcon: IconButton(
                          icon: Icon(
                            obscureApiKey ? Icons.visibility_off : Icons.visibility,
                            color: Colors.grey[600],
                          ),
                          onPressed: () {
                            setState(() {
                              obscureApiKey = !obscureApiKey;
                            });
                          },
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
                        ),
                        errorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                        focusedErrorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(10),
                          borderSide: const BorderSide(color: Colors.red, width: 2),
                        ),
                      ),
                      validator: (val) => val == null || val.isEmpty ? 'Enter API key' : null,
                    ),
                    const SizedBox(height: 8),
                    GestureDetector(
                      onTap: () async {
                        final result = await showModalBottomSheet<String>(
                          context: context,
                          isScrollControlled: true,
                          backgroundColor: Colors.transparent,
                          builder: (context) => _StatusDialog(
                            statuses: statuses,
                            selectedStatus: selectedStatus,
                          ),
                        );
                        if (result != null) {
                          setState(() {
                            selectedStatus = result;
                            _showStatusError = false;
                          });
                        }
                      },
                      child: Container(
                        width: 500,
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(
                              color: _showStatusError ? Colors.red : Colors.transparent, 
                              width: _showStatusError ? 2 : 1
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedStatus ?? 'Select Status',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15, 
                                    color: _showStatusError 
                                        ? Colors.red 
                                        : (selectedStatus == null ? Colors.black : Colors.black),
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 8),
                    if (accountTitleController.text.trim() != 'Managed')
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text('Default Courier', style: TextStyle(fontSize: 16)),
                          Switch(
                            value: isDefault,
                            onChanged: (val) => setState(() => isDefault = val),
                            activeColor: Color(0xFF007AFF),
                          ),
                        ],
                      ),
                    const SizedBox(height: 24),
                    SizedBox(
                      width: double.infinity,
                      height: 48,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        onPressed: () async {
                          setState(() {
                            _showCourierError = selectedCourier == null;
                            _showStatusError = selectedStatus == null;
                            _showApiKeyError = apiKeyController.text.isEmpty;
                          });
                          final valid = _formKey.currentState!.validate();
                          if (!_showCourierError && !_showStatusError && !_showApiKeyError && valid) {
                            if (widget.isEdit) {
                              await _updateCourier();
                            } else {
                              await _storeCourier();
                            }
                          }
                        },
                        child: Text(widget.isEdit ? 'Update' : 'Save', style: const TextStyle(fontSize: 18, color: Colors.white)),
                      ),
                    ),
                    const SizedBox(height: 32),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
          child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
              bottomNavigationBar: AppBottomBar(
          selectedIndex: 3,
          onOrderListTap: () => Get.to(() => OrderListScreen(from: 'add_courier_company')),
          onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'add_courier_company')),
        ),
    );
  }

  InputDecoration _inputDecoration(String label) {
    return InputDecoration(
      labelText: label,
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(10),
      ),
      filled: true,
      fillColor: const Color(0xFFF5F5F7),
      contentPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(10),
        borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
      ),
    );
  }

  Future<void> _updateCourier() async {
    try {
      
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
      );

      
      String courierId;
      if (selectedCourierId != null && selectedCourierId!.isNotEmpty) {
        courierId = selectedCourierId!;
        
      } else if (selectedCourier != null && selectedCourier!.isNotEmpty) {
        
        final selectedCourierData = couriers.firstWhere(
          (courier) => (courier['name'] ?? courier['courier_name'] ?? '') == selectedCourier,
          orElse: () => {},
        );
        
        if (selectedCourierData.isNotEmpty) {
          courierId = selectedCourierData['id'].toString();
          print('DEBUG: Found courier ID from name: $courierId');
        } else {
          
          courierId = widget.courierAccount!.courierId;
          
        }
      } else {
        
        courierId = widget.courierAccount!.courierId;
       
      }
      
  
      
      final result = await _courierService.updateCourier(
        acno: widget.courierAccount!.acno,
        userId: _authService.getCurrentUserId() ?? 0,
        id: widget.courierAccount!.id,
        courierId: courierId,
        accountTitle: accountTitleController.text,
        accountNo: accountNoController.text,
        accountUser: userController.text,
        accountPassword: passwordController.text,
        apikey: apiKeyController.text,
        status: selectedStatus == 'Active' ? 'active' : 'inactive',
        isDefault: isDefault ? '1' : '0',
      );
      
      
      Navigator.of(context).pop();

      if (result['success'] == true) {
        
        customSnackBar('Success', result['message']);
        
        
        
        _clearCourierCompaniesCache();
        
        
        await _refreshCourierDetails();
        
        
        await Future.delayed(Duration(milliseconds: 100));
        
        
        Navigator.of(context).pop(true);
      } else {
        
        customSnackBar('Error', result['message']);
      }
    } catch (e) {
      
      Navigator.of(context).pop();
      
      
      customSnackBar('Error', e.toString());
    }
  }

  Future<void> _storeCourier() async {
    try {
      
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        },
      );

      
      String courierId;
      if (selectedCourierId != null && selectedCourierId!.isNotEmpty) {
        courierId = selectedCourierId!;
        
      } else if (selectedCourier != null && selectedCourier!.isNotEmpty) {
        
        final selectedCourierData = couriers.firstWhere(
          (courier) => (courier['name'] ?? courier['courier_name'] ?? '') == selectedCourier,
          orElse: () => {},
        );
        
        if (selectedCourierData.isNotEmpty) {
          courierId = selectedCourierData['id'].toString();
         
        } else {
          
          courierId = couriers.isNotEmpty ? couriers.first['id'].toString() : '1';
         
        }
      } else {
        
        courierId = couriers.isNotEmpty ? couriers.first['id'].toString() : '1';
        
      }
      
      
      final result = await _courierService.storeCourier(
        acno: _authService.getCurrentAcno() ?? '',
        userId: _authService.getCurrentUserId() ?? 0,
        courierId: courierId,
        accountTitle: accountTitleController.text,
        accountNo: accountNoController.text,
        accountUser: userController.text,
        accountPassword: passwordController.text,
        apikey: apiKeyController.text,
        status: selectedStatus == 'Active' ? 'active' : 'inactive',
        isDefault: isDefault ? '1' : '0',
      );
      
      
      Navigator.of(context).pop();

      if (result['success'] == true) {
        
        customSnackBar('Success', result['message']);
        
        
        Navigator.of(context).pop(true);
      } else {
        
        customSnackBar('Error', result['message']);
      }
    } catch (e) {
      
      Navigator.of(context).pop();
      
      
      customSnackBar('Error', e.toString());
    }
  }

  Widget _navBarItem(IconData icon, String label, String route) {
    return InkWell(
      onTap: () {
        Get.offAllNamed(route);
      },
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 28, color: const Color(0xFF0A2A3A)),
          const SizedBox(height: 2),
          Text(label, style: const TextStyle(fontSize: 12, color: Color(0xFF0A2A3A))),
        ],
      ),
    );
  }

  
  
  void _clearCourierCompaniesCache() {
    
    
    try {
      
      
      CourierCompaniesScreen.clearAllCourierCompaniesCaches();
      
    } catch (e) {
      print(' Could not clear cache: $e');
    }
  }

  
  Future<void> _refreshCourierDetails() async {
    try {
      if (widget.isEdit && widget.courierAccount != null) {
        final acno = _authService.getCurrentAcno();
        if (acno != null) {
          
          final courierDetail = await _courierService.getCourierDetailById(
            int.tryParse(widget.courierAccount!.id) ?? 0,
            acno,
          );
          
          if (courierDetail.isNotEmpty) {
            
            setState(() {
              accountTitleController.text = courierDetail['account_title'] ?? '';
              accountNoController.text = courierDetail['account_no'] ?? '';
              userController.text = courierDetail['account_user'] ?? '';
              passwordController.text = courierDetail['account_password'] ?? '';
              apiKeyController.text = courierDetail['apikey'] ?? '';
              selectedStatus = (courierDetail['status'] ?? '').toLowerCase() == 'active' ? 'Active' : 'Inactive';
              isDefault = courierDetail['default'] == '1';
            });
          }
        }
      }
    } catch (e) {
      print(' Failed to refresh courier details: $e');
    }
  }

  
  String _courierDisplayLabel(Map<String, dynamic> c) {
    final courierName = c['courier_name']?.toString() ?? c['name']?.toString() ?? '';
    return courierName;
  }
}

class _CourierUpdateSuccessBottomSheet extends StatelessWidget {
  const _CourierUpdateSuccessBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(24),
              child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
            ),
            const SizedBox(height: 24),
            const Text(
              'Success!',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
            ),
            const SizedBox(height: 8),
            const Text(
              'Courier details updated successfully',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  elevation: 0,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _CourierAddSuccessBottomSheet extends StatelessWidget {
  const _CourierAddSuccessBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(32),
              child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
            ),
            const SizedBox(height: 24),
            const Text(
              'Success!',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
            ),
            const SizedBox(height: 8),
            const Text(
              'Courier details added successfully',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  elevation: 0,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
              ),
            ),
          ],
        ),
      ),
    );
  }
} 

class _CourierSearchDialog extends StatefulWidget {
  final List<Map<String, dynamic>> couriers;
  final String? selectedCourier;
  final Function(String) onCourierSelected;

  const _CourierSearchDialog({
    Key? key,
    required this.couriers,
    required this.selectedCourier,
    required this.onCourierSelected,
  }) : super(key: key);

  @override
  State<_CourierSearchDialog> createState() => _CourierSearchDialogState();
}

class _CourierSearchDialogState extends State<_CourierSearchDialog> {
  final TextEditingController _searchController = TextEditingController();
  List<Map<String, dynamic>> _filteredCouriers = [];

  @override
  void initState() {
    super.initState();
    _filteredCouriers = widget.couriers;
  }

  String _courierDisplayLabel(Map<String, dynamic> c) {
    final courierName = c['courier_name']?.toString() ?? c['name']?.toString() ?? '';
    return courierName;
  }

  void _filterCouriers(String query) {
    setState(() {
      if (query.isEmpty) {
        _filteredCouriers = widget.couriers;
      } else {
        _filteredCouriers = widget.couriers.where((courier) {
          final displayLabel = _courierDisplayLabel(courier).toLowerCase();
          return displayLabel.contains(query.toLowerCase());
        }).toList();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text(
                          'Select Courier',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        const SizedBox(height: 16),
                        TextField(
                          controller: _searchController,
                          decoration: InputDecoration(
                            hintText: 'Search couriers',
                            prefixIcon: const Icon(Icons.search_rounded),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                          ),
                          onChanged: _filterCouriers,
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          height: 300,
                          child: _filteredCouriers.isEmpty
                              ? const Center(
                                  child: Text(
                                    'No couriers found',
                                    style: TextStyle(color: Colors.grey),
                                  ),
                                )
                              : ListView.separated(
                                  itemCount: _filteredCouriers.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, index) {
                                    final courier = _filteredCouriers[index];
                                    final displayLabel = _courierDisplayLabel(courier);
                                    final isSelected = displayLabel == widget.selectedCourier;

                                    return ListTile(
                                      title: Text(
                                        displayLabel,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () => widget.onCourierSelected(displayLabel),
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
}

class _StatusDialog extends StatefulWidget {
  final List<String> statuses;
  final String? selectedStatus;

  const _StatusDialog({
    required this.statuses,
    this.selectedStatus,
  });

  @override
  State<_StatusDialog> createState() => _StatusDialogState();
}

class _StatusDialogState extends State<_StatusDialog> {
  late List<String> filteredStatuses;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredStatuses = widget.statuses;
    searchController = TextEditingController();
    selected = widget.selectedStatus;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredStatuses = widget.statuses.where((s) => s.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select Status', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.grey),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                            focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: Colors.grey, width: 2)),
                            contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 8),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredStatuses.isEmpty
                              ? const Center(child: Text('No statuses found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredStatuses.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final status = filteredStatuses[i];
                                    final isSelected = status == selected;
                                    return ListTile(
                                      title: Text(
                                        status,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(status);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../models/notification_model.dart';
import '../services/notification_service.dart';
import '../services/auth_service.dart';
import '../utils/custom_snackbar.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'notification_screen.dart';
import 'package:dio/dio.dart';
import 'package:google_fonts/google_fonts.dart';
import '../config/api_config.dart';
import 'create_order.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;

class AddNotificationScreen extends StatefulWidget {
  final bool isEdit;
  final NotificationModel? notification;

  const AddNotificationScreen({
    Key? key,
    this.isEdit = false,
    this.notification,
  }) : super(key: key);

  @override
  State<AddNotificationScreen> createState() => _AddNotificationScreenState();
}

class _AddNotificationScreenState extends State<AddNotificationScreen> {
  final NotificationService _notificationService = NotificationService();
  final AuthService _authService = Get.find<AuthService>();
  final _formKey = GlobalKey<FormState>();
  final TextEditingController subjectController = TextEditingController();
  final TextEditingController messageController = TextEditingController();
  final FocusNode messageFocusNode = FocusNode();
  
  String? selectedStatus;
  bool statusError = false;
  bool email = false;
  bool whatsapp = false;
  bool sms = false;
  bool isActive = true;
  bool isLoading = false;
  String? _currentAcno;
  
  
  bool messageError = false;
  bool subjectError = false;
  bool notificationTypeError = false;

  List<Map<String, dynamic>> statusOptions = [];

  @override
  void initState() {
    super.initState();
    _loadCurrentUserAcno();
    _fetchStatusOptions();
    if (widget.isEdit && widget.notification != null) {
      _loadNotificationData();
    }
  }

  @override
  void dispose() {
    subjectController.dispose();
    messageController.dispose();
    messageFocusNode.dispose();
    super.dispose();
  }

  Future<void> _loadCurrentUserAcno() async {
    final user = _authService.currentUser.value;
    if (user != null) {
      setState(() {
        _currentAcno = user.acno;
      });
    }
  }

  void _loadNotificationData() {
    final notification = widget.notification!;
    subjectController.text = notification.subject;
    messageController.text = notification.message;
    selectedStatus = notification.statusName;
    email = notification.isEmail == 'Y';
    whatsapp = notification.isWhatsapp == 'Y';
    sms = notification.isSms == 'Y';
    isActive = notification.status == 'Y';
  }

  Future<void> _fetchStatusOptions() async {
    try {
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
        data: {"status_type": ["System","Rider","Customer Service"]},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        if (data is List) {
          setState(() {
            statusOptions = List<Map<String, dynamic>>.from(data);
           
            
          });
        } else if (data is Map && data['payload'] is List) {
          setState(() {
            statusOptions = List<Map<String, dynamic>>.from(data['payload']);
           
            
          });
        }
      }
    } catch (e) {
      print('Error fetching statusOptions: $e');
    }
  }

  Future<void> _saveNotification() async {
    
    setState(() {
      statusError = false;
      messageError = false;
      subjectError = false;
      notificationTypeError = false;
    });

    bool hasValidationError = false;

    
    if (!_formKey.currentState!.validate()) {
      hasValidationError = true;
    }

    
    if (selectedStatus == null || selectedStatus!.isEmpty) {
      setState(() {
        statusError = true;
      });
      hasValidationError = true;
    }

    
    if (messageController.text.trim().isEmpty) {
      setState(() {
        messageError = true;
      });
      hasValidationError = true;
    }

    
    if (!email && !whatsapp && !sms) {
      setState(() {
        notificationTypeError = true;
      });
      hasValidationError = true;
    }

    
    if (email && subjectController.text.trim().isEmpty) {
      setState(() {
        subjectError = true;
      });
      hasValidationError = true;
    }

    
    if (hasValidationError) {
      if (messageController.text.trim().isEmpty) {
        customSnackBar('Error', 'Please enter a message');
      } else if (selectedStatus == null || selectedStatus!.isEmpty) {
        customSnackBar('Error', 'Please select a status');
      } else if (!email && !whatsapp && !sms) {
        customSnackBar('Error', 'Please select at least one notification type (Email, WhatsApp, or SMS)');
      } else if (email && subjectController.text.trim().isEmpty) {
        customSnackBar('Error', 'Please enter a subject for email notification');
      } else {
        customSnackBar('Error', 'Please fill in all required fields');
      }
      return;
    }

    
    if (_currentAcno == null || _currentAcno!.isEmpty) {
      customSnackBar('Error', 'User account not found');
      return;
    }

    setState(() {
      isLoading = true;
    });

    try {
      Map<String, dynamic> result;
      
      if (widget.isEdit && widget.notification != null) {
        
        final int safeId = int.tryParse(widget.notification!.id.toString()) ?? 0;
        final dynamic statusIdRaw = statusOptions.firstWhere(
          (opt) => opt['name'] == selectedStatus,
          orElse: () => {'id': 2},
        )['id'];
        final int safeStatusId = statusIdRaw is int ? statusIdRaw : int.tryParse(statusIdRaw.toString()) ?? 2;
        result = await _notificationService.editNotification(
          id: safeId,
          acno: _currentAcno!,
          message: messageController.text.trim(),
          statusId: safeStatusId,
          subject: subjectController.text.trim(),
          isEmail: email ? 'Y' : 'N',
          isWhatsapp: whatsapp ? 'Y' : 'N',
          isSms: sms ? 'Y' : 'N',
          status: isActive ? 'Y' : 'N',
        );
      } else {
        
        final dynamic statusIdRaw = statusOptions.firstWhere(
          (opt) => opt['name'] == selectedStatus,
          orElse: () => {'id': 2},
        )['id'];
        final int safeStatusId = statusIdRaw is int ? statusIdRaw : int.tryParse(statusIdRaw.toString()) ?? 2;
        result = await _notificationService.createNotification(
          acno: _currentAcno!,
          message: messageController.text.trim(),
          statusId: safeStatusId,
          subject: subjectController.text.trim(),
          isEmail: email ? 'Y' : 'N',
          isWhatsapp: whatsapp ? 'Y' : 'N',
          isSms: sms ? 'Y' : 'N',
          status: isActive ? 'Y' : 'N',
        );
      }

      final bool success = result['success'] ?? false;
      final String message = result['message'] ?? 'Unknown response';

      if (success) {
        customSnackBar('Success', message);
        
        
        Navigator.of(context).pop(true);
      } else {
        customSnackBar('Error', message);
      }
    } catch (e) {
      customSnackBar('Error', e.toString());
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).maybePop(),
        ),
        title: Text(
          widget.isEdit ? 'Edit Notification' : 'Add Notification',
          style: const TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      backgroundColor: Colors.white,
      body: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              const SizedBox(height: 12),
              
              GestureDetector(
                onTap: () async {
                  if (statusOptions.isEmpty) return;
                  final result = await showModalBottomSheet<String>(
                    context: context,
                    isScrollControlled: true,
                    backgroundColor: Colors.transparent,
                    builder: (ctx) {
                      String search = '';
                      List<Map<String, dynamic>> filtered = statusOptions;
                      return StatefulBuilder(
                        builder: (context, setState) => Container(
                          decoration: const BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.only(
                              topLeft: Radius.circular(20),
                              topRight: Radius.circular(20),
                            ),
                          ),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              
                              Container(
                                margin: const EdgeInsets.only(top: 8),
                                width: 40,
                                height: 4,
                                decoration: BoxDecoration(
                                  color: Colors.grey[300],
                                  borderRadius: BorderRadius.circular(2),
                                ),
                              ),
                              
                              Flexible(
                                child: AnimationLimiter(
                                  child: SingleChildScrollView(
                                    child: Padding(
                                      padding: const EdgeInsets.all(20),
                                      child: Column(
                                        mainAxisSize: MainAxisSize.min,
                                        children: AnimationConfiguration.toStaggeredList(
                                          duration: const Duration(milliseconds: 400),
                                          childAnimationBuilder: (widget) => SlideAnimation(
                                            verticalOffset: 30.0,
                                            child: FadeInAnimation(
                                              child: widget,
                                            ),
                                          ),
                                          children: [
                                            const Text('Select Status', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 18, color: Colors.black)),
                                            const SizedBox(height: 12),
                                            TextField(
                                              decoration: InputDecoration(
                                                hintText: 'Search',
                                                prefixIcon: const Icon(Icons.search_rounded, color: Colors.grey),
                                                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                                                focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: Colors.grey, width: 2)),
                                                contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 8),
                                              ),
                                              onChanged: (val) => setState(() {
                                                search = val;
                                                filtered = statusOptions.where((s) => (s['name'] ?? '').toString().toLowerCase().contains(val.toLowerCase())).toList();
                                              }),
                                            ),
                                            const SizedBox(height: 12),
                                            SizedBox(
                                              height: 300,
                                              child: ListView.separated(
                                                itemCount: filtered.length,
                                                separatorBuilder: (_, __) => Container(
                                                  height: 1,
                                                  color: Colors.grey.withOpacity(0.2),
                                                  margin: const EdgeInsets.symmetric(horizontal: 8),
                                                ),
                                                itemBuilder: (context, i) {
                                                  final status = filtered[i]['name'] ?? '';
                                                  final isSelected = selectedStatus == status;
                                                  return ListTile(
                                                    title: Text(status, style: TextStyle(color: isSelected ? Colors.black : Colors.black, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal)),
                                                    onTap: () => Navigator.of(context).pop(status),
                                                    selected: isSelected,
                                                    selectedTileColor: Colors.grey.withOpacity(0.08),
                                                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                                    trailing: isSelected ? const Icon(Icons.check_circle, color: Colors.black) : null,
                                                  );
                                                },
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  );
                  if (result != null) {
                    setState(() {
                      selectedStatus = result;
                      statusError = false;
                    });
                  }
                },
                child: Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF3F3F3),
                    borderRadius: BorderRadius.circular(14),
                    border: statusError ? Border.all(color: Colors.red, width: 1.5) : null,
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          selectedStatus == null || selectedStatus!.isEmpty ? 'Select Status' : selectedStatus!,
                          style: GoogleFonts.poppins(
                            fontSize: 15,
                            color: statusError
                                ? Colors.red
                                : (selectedStatus == null || selectedStatus!.isEmpty)
                                    ? Colors.black
                                    : Colors.black,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                      ),
                      const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: const Text('Choose Notification to Send to your Customer', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              ),
              const SizedBox(height: 12),
              
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(8),
                    border: notificationTypeError ? Border.all(color: Colors.red, width: 1.5) : null,
                  ),
                  padding: notificationTypeError ? const EdgeInsets.all(8) : EdgeInsets.zero,
                  child: Column(
                    children: [
                      _toggleRow('WhatsApp Notification', whatsapp, (val) {
                        setState(() {
                          whatsapp = val;
                          notificationTypeError = false;
                        });
                      }),
                      _toggleRow('Email Notification', email, (val) {
                        setState(() {
                          email = val;
                          notificationTypeError = false;
                          if (!val) {
                            subjectError = false;
                          }
                        });
                      }),
                      _toggleRow('SMS Notification', sms, (val) {
                        setState(() {
                          sms = val;
                          notificationTypeError = false;
                        });
                      }),
                    ],
                  ),
                ),
              ),
              if (email) ...[
                const SizedBox(height: 12),
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFF3F3F3),
                    borderRadius: BorderRadius.circular(12),
                    border: subjectError ? Border.all(color: Colors.red, width: 1.5) : null,
                  ),
                  child: TextFormField(
                  controller: subjectController,
                    decoration: InputDecoration(
                      labelText: 'Subject',
                      border: InputBorder.none,
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    ),
                    onChanged: (value) {
                      if (value.trim().isNotEmpty && subjectError) {
                        setState(() {
                          subjectError = false;
                        });
                      }
                    },
                  validator: (val) {
                    if (!email) return null;
                    if (val == null || val.trim().isEmpty) {
                      return 'Subject is required for email notifications';
                    }
                    return null;
                  },
                  ),
                ),
                const SizedBox(height: 18),
              ],
                              Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFF3F3F3),
                    borderRadius: BorderRadius.circular(12),
                    border: messageError ? Border.all(color: Colors.red, width: 1.5) : null,
                  ),
                  child: TextFormField(
                controller: messageController,
                focusNode: messageFocusNode,
                maxLines: 6,
                    decoration: InputDecoration(
                      labelText: 'Your Message',
                      border: InputBorder.none,
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 0),
                  alignLabelWithHint: true,
                ),
                textAlignVertical: TextAlignVertical.top,
                onChanged: (value) {
                  if (value.trim().isNotEmpty && messageError) {
                    setState(() {
                      messageError = false;
                    });
                  }
                },
                validator: (val) {
                  if (val == null || val.trim().isEmpty) {
                    return 'Message is required';
                  }
                  return null;
                },
                  ),
              ),
              const SizedBox(height: 14),
              
              
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.grey[50],
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.grey[300]!),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    
                
                    const Text(
                      'Click on any variable to insert it into your message:',
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.black54,
                      ),
                    ),
                    const SizedBox(height: 12),
                    Wrap(
                      spacing: 8,
                      runSpacing: 8,
                      children: [
                        _buildVariableChip('{{ORDER_ID}}'),
                        _buildVariableChip('{{WEBORDER_ID}}'),
                        _buildVariableChip('{{CUSTOMER_NAME}}'),
                        _buildVariableChip('{{CUSTOMER_EMAIL}}'),
                        _buildVariableChip('{{ORDER_STATUS}}'),
                        _buildVariableChip('{{ORDER_AMOUNT}}'),
                        _buildVariableChip('{{STORENAME}}'),
                        _buildVariableChip('{{COURIER}}'),
                        _buildVariableChip('{{CONSIGNMENT_NO}}'),
                        _buildVariableChip('{{TRACKING_URL}}'),
                      ],
                    ),
                  ],
                ),
              ),
              
              const SizedBox(height: 14),
              
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: const Text('Status', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              ),
              Padding(
                padding: const EdgeInsets.only(left: 8.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text('Inactive/Active', style: TextStyle(fontSize: 16)),
                    Switch(
                      value: isActive,
                      onChanged: (val) => setState(() => isActive = val),
                      activeColor: Color(0xFF007AFF),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF007AFF),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  onPressed: isLoading ? null : _saveNotification,
                  child: isLoading 
                    ? const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      )
                    : Text(widget.isEdit ? 'Update' : 'Save', style: const TextStyle(fontSize: 18, color: Colors.white)),
                ),
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
          child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      resizeToAvoidBottomInset: false,
                             bottomNavigationBar: AppBottomBar(
                 selectedIndex: 3,
                 onOrderListTap: () => Get.to(() => OrderListScreen(from: 'add_notification')),
                 onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'add_notification')),
               ),
    );
  }

  InputDecoration _inputDecoration(String label) {
    return InputDecoration(
      labelText: label,
      border: InputBorder.none,
      filled: true,
      fillColor: const Color(0xFFF3F3F3),
      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 16),
    );
  }

  Widget _toggleRow(String label, bool value, ValueChanged<bool> onChanged) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label, style: const TextStyle(fontSize: 16)),
        Switch(
          value: value,
          onChanged: onChanged,
          activeColor: Color(0xFF007AFF),
        ),
      ],
    );
  }

  Widget _navBarItem(IconData icon, String label, String route) {
    return InkWell(
      onTap: () {
        Get.offAllNamed(route);
      },
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 28, color: const Color(0xFF0A2A3A)),
          const SizedBox(height: 2),
          Text(label, style: const TextStyle(fontSize: 12, color: Color(0xFF0A2A3A))),
        ],
      ),
    );
  }

  Widget _buildVariableChip(String variable) {
    return GestureDetector(
      onTap: () {
        
        final currentText = messageController.text;
        final selection = messageController.selection;
        final newText = currentText.replaceRange(
          selection.start,
          selection.end,
          variable,
        );
        messageController.text = newText;
        
        
        final newCursorPosition = selection.start + variable.length;
        messageController.selection = TextSelection.fromPosition(
          TextPosition(offset: newCursorPosition),
        );
        
        
        FocusScope.of(context).requestFocus(FocusNode());
        Future.delayed(const Duration(milliseconds: 100), () {
          FocusScope.of(context).requestFocus(messageFocusNode);
        });
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: const Color(0xFF007AFF).withOpacity(0.1),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: const Color(0xFF007AFF).withOpacity(0.3),
            width: 1,
          ),
        ),
        child: Text(
          variable,
          style: const TextStyle(
            color: Color(0xFF007AFF),
            fontSize: 12,
            fontWeight: FontWeight.w500,
            fontFamily: 'monospace',
          ),
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'dashboard_screen.dart' as dash;
import 'report.dart' as report;
import 'menu.dart' as menu;
import 'package:flutter/services.dart'; 
import 'create_order.dart';
import '../services/statement_service.dart';
import '../services/auth_service.dart';
import 'package:google_fonts/google_fonts.dart'; 
import '../utils/Layout/app_bottom_bar.dart';
import 'order_list_screen.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../utils/custom_snackbar.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';

class AddProductScreen extends StatefulWidget {
  final int? platformId;
  final int? customerPlatformId;
  final List<OrderItem>? existingOrderItems; 
  
  const AddProductScreen({
    Key? key, 
    this.platformId,
    this.customerPlatformId,
    this.existingOrderItems, 
  }) : super(key: key);

  @override
  State<AddProductScreen> createState() => _AddProductScreenState();
}

class _AddProductScreenState extends State<AddProductScreen> {
  int quantity = 1;
  String selectedProduct = '';
  final TextEditingController skuController = TextEditingController();
  final TextEditingController priceController = TextEditingController();
  final TextEditingController customProductController = TextEditingController();
  List<String> productList = [];
  final TextEditingController searchController = TextEditingController();
  bool _isLoadingProducts = false;
  String? _productError;
  final AuthService _authService = Get.find<AuthService>();
  List<Map<String, dynamic>> productData = [];
  bool isCustom = false;
  
  // Cache variables for product suggestions
  static Map<String, List<Map<String, dynamic>>>? _cachedProductSuggestions;
  static Map<String, String>? _cachedProductSuggestionsAcno;
  static Map<String, int>? _cachedProductSuggestionsPlatformId;
  static Map<String, int?>? _cachedProductSuggestionsCustomerPlatformId;
  
  final TextEditingController locationNameController = TextEditingController();
  
  String _searchQuery = '';
  List<String> _filteredProducts = [];
  
  int? _selectedLocationId;
  
  String defaultSkuCode = '';
  List<Map<String, dynamic>> locationOptions = [];
  String? selectedLocation;

  @override
  void initState() {
    super.initState();
    // Delay the fetch to allow the screen to render first
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _fetchProducts();
    });
  }

  // Generate cache key for product suggestions
  String _getProductSuggestionsCacheKey(String acno, int platformId, int? customerPlatformId) {
    return '${acno}_${platformId}_${customerPlatformId ?? 'null'}';
  }

  // Check if we have cached data for the current parameters
  bool _hasCachedProductSuggestions(String acno, int platformId, int? customerPlatformId) {
    final cacheKey = _getProductSuggestionsCacheKey(acno, platformId, customerPlatformId);
    return _cachedProductSuggestions != null && 
           _cachedProductSuggestions!.containsKey(cacheKey) &&
           _cachedProductSuggestionsAcno != null &&
           _cachedProductSuggestionsAcno![cacheKey] == acno &&
           _cachedProductSuggestionsPlatformId != null &&
           _cachedProductSuggestionsPlatformId![cacheKey] == platformId &&
           _cachedProductSuggestionsCustomerPlatformId != null &&
           _cachedProductSuggestionsCustomerPlatformId![cacheKey] == customerPlatformId;
  }

  // Get cached product suggestions
  List<Map<String, dynamic>>? _getCachedProductSuggestions(String acno, int platformId, int? customerPlatformId) {
    final cacheKey = _getProductSuggestionsCacheKey(acno, platformId, customerPlatformId);
    return _cachedProductSuggestions?[cacheKey];
  }

  // Cache product suggestions
  void _cacheProductSuggestions(String acno, int platformId, int? customerPlatformId, List<Map<String, dynamic>> data) {
    final cacheKey = _getProductSuggestionsCacheKey(acno, platformId, customerPlatformId);
    _cachedProductSuggestions ??= {};
    _cachedProductSuggestionsAcno ??= {};
    _cachedProductSuggestionsPlatformId ??= {};
    _cachedProductSuggestionsCustomerPlatformId ??= {};
    
    _cachedProductSuggestions![cacheKey] = List<Map<String, dynamic>>.from(data);
    _cachedProductSuggestionsAcno![cacheKey] = acno;
    _cachedProductSuggestionsPlatformId![cacheKey] = platformId;
    _cachedProductSuggestionsCustomerPlatformId![cacheKey] = customerPlatformId;
  }

  // Clear cache for specific parameters
  void _clearProductSuggestionsCache(String acno, int platformId, int? customerPlatformId) {
    final cacheKey = _getProductSuggestionsCacheKey(acno, platformId, customerPlatformId);
    _cachedProductSuggestions?.remove(cacheKey);
    _cachedProductSuggestionsAcno?.remove(cacheKey);
    _cachedProductSuggestionsPlatformId?.remove(cacheKey);
    _cachedProductSuggestionsCustomerPlatformId?.remove(cacheKey);
  }

  // Clear all product suggestions cache
  static void clearAllProductSuggestionsCache() {
    _cachedProductSuggestions = null;
    _cachedProductSuggestionsAcno = null;
    _cachedProductSuggestionsPlatformId = null;
    _cachedProductSuggestionsCustomerPlatformId = null;
  }

  // Clear cache for current user
  void _clearCurrentUserProductSuggestionsCache() {
    final acno = _authService.getCurrentAcno();
    if (acno != null) {
      final platformId = widget.platformId ?? 0;
      final customerPlatformId = widget.customerPlatformId;
      _clearProductSuggestionsCache(acno, platformId, customerPlatformId);
    }
  }

  // Refresh products (clear cache and fetch again)
  Future<void> _refreshProducts() async {
    _clearCurrentUserProductSuggestionsCache();
    await _fetchProducts();
  }

  // Preload product suggestions for better performance
  static Future<void> preloadProductSuggestions(String acno, int platformId, int? customerPlatformId) async {
    final cacheKey = '${acno}_${platformId}_${customerPlatformId ?? 'null'}';
    
    // Check if already cached
    if (_cachedProductSuggestions != null && _cachedProductSuggestions!.containsKey(cacheKey)) {
      return;
    }

    try {
      final service = StatementService();
      final data = await service.fetchProductSuggestions(
        acno: acno,
        platformId: platformId,
        customerPlatformId: customerPlatformId,
      ).timeout(const Duration(seconds: 30));
      
      // Cache the preloaded data
      _cachedProductSuggestions ??= {};
      _cachedProductSuggestionsAcno ??= {};
      _cachedProductSuggestionsPlatformId ??= {};
      _cachedProductSuggestionsCustomerPlatformId ??= {};
      
      _cachedProductSuggestions![cacheKey] = List<Map<String, dynamic>>.from(data);
      _cachedProductSuggestionsAcno![cacheKey] = acno;
      _cachedProductSuggestionsPlatformId![cacheKey] = platformId;
      _cachedProductSuggestionsCustomerPlatformId![cacheKey] = customerPlatformId;
    } catch (e) {
      print('Failed to preload product suggestions: $e');
    }
  }

  Future<void> _fetchProducts() async {
    setState(() {
      _isLoadingProducts = true;
      _productError = null;
    });
    
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          _productError = 'User not logged in';
          _isLoadingProducts = false;
        });
        return;
      }
      
      final platformId = widget.platformId ?? 0;
      final customerPlatformId = widget.customerPlatformId;
      
      // Check if we have cached data
      if (_hasCachedProductSuggestions(acno, platformId, customerPlatformId)) {
        final cachedData = _getCachedProductSuggestions(acno, platformId, customerPlatformId);
        if (cachedData != null) {
          if (mounted) {
            setState(() {
              productData = cachedData;
              productList = cachedData.map((e) => _createProductDisplayLabel(e)).where((e) => e.isNotEmpty).toList();
              _filteredProducts = List<String>.from(productList);
              _isLoadingProducts = false;
            });
          }
          return;
        }
      }
      
      final service = StatementService();
      
      // Add timeout to prevent hanging
      final data = await service.fetchProductSuggestions(
        acno: acno,
        platformId: platformId,
        customerPlatformId: customerPlatformId,
      ).timeout(
        const Duration(seconds: 30),
        onTimeout: () {
          throw Exception('Request timed out. Please try again.');
        },
      );
      
      // Cache the fetched data
      _cacheProductSuggestions(acno, platformId, customerPlatformId, data);
      
      if (mounted) {
        setState(() {
          productData = data;
          productList = data.map((e) => _createProductDisplayLabel(e)).where((e) => e.isNotEmpty).toList();
          _filteredProducts = List<String>.from(productList); 
          _isLoadingProducts = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _productError = 'Failed to load products: ${e.toString()}';
          _isLoadingProducts = false;
        });
      }
      
    }
  }

  
  String _createProductDisplayLabel(Map<String, dynamic> product) {
    final productName = product['product_name']?.toString() ?? '';
    final attributeValues = product['attribute_values']?.toString();
    
    if (attributeValues != null && attributeValues.isNotEmpty && attributeValues != 'null') {
      return '$productName - $attributeValues';
    } else {
      return productName;
    }
  }

  
  bool _wouldExceedStock(String productId, String locationId, int requestedQuantity) {
    if (widget.existingOrderItems == null) return false;
    
    
    int alreadyAddedQuantity = 0;
    for (var item in widget.existingOrderItems!) {
      if (item.productId == productId && item.locationId == locationId) {
        alreadyAddedQuantity += item.qty;
      }
    }
    
    
    final selectedProductObj = productData.firstWhere(
      (p) => _createProductDisplayLabel(p) == selectedProduct,
      orElse: () => <String, dynamic>{},
    );
    
    if (selectedProductObj.isEmpty) return false;
    
    final inventory = selectedProductObj['inventory'];
    if (inventory is List) {
      final locationData = inventory.firstWhere(
        (loc) => loc['location_id'].toString() == locationId,
        orElse: () => {},
      );
      
      if (locationData.isNotEmpty) {
        final availableStock = locationData['quantity'] as int? ?? 0;
        final totalRequested = alreadyAddedQuantity + requestedQuantity;
        return totalRequested > availableStock;
      }
    }
    
    return false;
  }

  
  int _getAvailableStock(String productId, String locationId) {
    final selectedProductObj = productData.firstWhere(
      (p) => _createProductDisplayLabel(p) == selectedProduct,
      orElse: () => <String, dynamic>{},
    );
    
    if (selectedProductObj.isEmpty) return 0;
    
    final inventory = selectedProductObj['inventory'];
    if (inventory is List) {
      final locationData = inventory.firstWhere(
        (loc) => loc['location_id'].toString() == locationId,
        orElse: () => {},
      );
      
      if (locationData.isNotEmpty) {
        return locationData['quantity'] as int? ?? 0;
      }
    }
    
    return 0;
  }

  
  int _getAlreadyAddedQuantity(String productId, String locationId) {
    if (widget.existingOrderItems == null) return 0;
    
    int alreadyAddedQuantity = 0;
    for (var item in widget.existingOrderItems!) {
      if (item.productId == productId && item.locationId == locationId) {
        alreadyAddedQuantity += item.qty;
      }
    }
    
    return alreadyAddedQuantity;
  }

  
  void _filterProducts(String query) {
    setState(() {
      _searchQuery = query;
      if (query.isEmpty) {
        _filteredProducts = List<String>.from(productList);
      } else {
        _filteredProducts = productList.where((p) => p.toLowerCase().contains(query.toLowerCase())).toList();
      }
    });
  }

  
  void _onProductSelected(String productDisplayLabel) {
    setState(() {
      selectedProduct = productDisplayLabel;
      
      final selectedProductObj = productData.firstWhere(
        (p) => _createProductDisplayLabel(p) == productDisplayLabel,
        orElse: () => <String, dynamic>{},
      );
    
      
      
      defaultSkuCode = selectedProductObj['default_sku_code']?.toString() ?? '';
     
      
      
      skuController.text = selectedProductObj['default_sku_code']?.toString() ?? '';
      priceController.text = selectedProductObj['default_price']?.toString() ?? '';
      
      
      locationOptions = [];
      selectedLocation = null;
      _selectedLocationId = null;
      
      final inventory = selectedProductObj['inventory'];
      
      
      if (inventory is List && inventory.isNotEmpty) {
        locationOptions = inventory.map((location) => {
          'name': location['location_name']?.toString() ?? '',
          'id': location['location_id'],
          'quantity': location['quantity'] ?? 0,
          'isDefault': location['default'] == 1,
        }).toList();
        
        
        final defaultLocation = locationOptions.firstWhere(
          (loc) => loc['isDefault'] == true,
          orElse: () => locationOptions.isNotEmpty ? locationOptions.first : {},
        );
        
        if (defaultLocation.isNotEmpty) {
          selectedLocation = defaultLocation['name'];
          _selectedLocationId = defaultLocation['id'] is int 
              ? defaultLocation['id'] 
              : int.tryParse(defaultLocation['id'].toString()) ?? null;
          locationNameController.text = selectedLocation!;
        }
        
        
      }
    });
  }

  
  Future<void> _showProductAddedDialog(BuildContext context, OrderItem orderItem) async {
    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        width: double.infinity,
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
        ),
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(32),
              child: SvgPicture.asset(
                'assets/Check Mark.svg',
                width: 64,
                height: 64,
                color: const Color(0xFF007AFF),
              ),
            ),
            const SizedBox(height: 24),
            const Text(
              'Success!',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            const Text(
              'Product added successfully',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop(); 
                  Navigator.of(context).pop(orderItem); 
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('OK', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    
    final hideCustomItem = widget.platformId?.toString() == '3';
    
    // Don't show full-screen loading, show loading inside dropdown instead
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        title: const Text(
          'Add Product',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        child: AnimationLimiter(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: AnimationConfiguration.toStaggeredList(
              duration: const Duration(milliseconds: 500),
              childAnimationBuilder: (widget) => SlideAnimation(
                verticalOffset: 50.0,
                child: FadeInAnimation(
                  child: widget,
                ),
              ),
              children: [
                const SizedBox(height: 4),
                
                isCustom
                    ? Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                        ),
                        child: TextField(
                          controller: customProductController,
                          decoration: InputDecoration(
                            hintText: 'Enter Product',
                            hintStyle: GoogleFonts.poppins(color: Colors.black, fontSize: 13),
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          ),
                          style: const TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w400,
                            fontSize: 15,
                            color: Color(0xFF222222),
                          ),
                        ),
                      )
                    : GestureDetector(
                        onTap: () async {
                          
                          await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (context) {
                              return StatefulBuilder(
                                builder: (context, setState) => Container(
                                  decoration: const BoxDecoration(
                                    color: Colors.white,
                                    borderRadius: BorderRadius.only(
                                      topLeft: Radius.circular(20),
                                      topRight: Radius.circular(20),
                                    ),
                                  ),
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      
                                      Container(
                                        margin: const EdgeInsets.only(top: 8),
                                        width: 40,
                                        height: 4,
                                        decoration: BoxDecoration(
                                          color: Colors.grey[300],
                                          borderRadius: BorderRadius.circular(2),
                                        ),
                                      ),
                                      
                                      Flexible(
                                        child: AnimationLimiter(
                                          child: SingleChildScrollView(
                                            child: Padding(
                                              padding: const EdgeInsets.all(20),
                                              child: Column(
                                                mainAxisSize: MainAxisSize.min,
                                                children: AnimationConfiguration.toStaggeredList(
                                                  duration: const Duration(milliseconds: 400),
                                                  childAnimationBuilder: (widget) => SlideAnimation(
                                                    verticalOffset: 30.0,
                                                    child: FadeInAnimation(
                                                      child: widget,
                                                    ),
                                                  ),
                                                  children: [
                                                    const Text('Select Product', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                                                    const SizedBox(height: 12),
                                                    TextField(
                                                      controller: TextEditingController(text: _searchQuery),
                                                      decoration: InputDecoration(
                                                        hintText: 'Search',
                                                        prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                                                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                                                      ),
                                                      onChanged: (val) {
                                                        _filterProducts(val);
                                                      },
                                                    ),
                                                    const SizedBox(height: 12),
                                                    SizedBox(
                                                      height: 300,
                                                      child: _filteredProducts.isEmpty
                                                          ? const Center(child: Text('No products found.', style: TextStyle(color: Colors.grey)))
                                                          : ListView.separated(
                                                              itemCount: _filteredProducts.length,
                                                              separatorBuilder: (_, __) => Container(
                                                                height: 1,
                                                                color: Colors.black.withOpacity(0.08),
                                                                margin: const EdgeInsets.symmetric(horizontal: 8),
                                                              ),
                                                              itemBuilder: (context, i) {
                                                                final product = _filteredProducts[i];
                                                                final isSelected = product == selectedProduct;
                                                                return ListTile(
                                                                  title: Text(
                                                                    product,
                                                                    style: TextStyle(
                                                                      color: isSelected ? Colors.black : Colors.black,
                                                                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                                                    ),
                                                                  ),
                                                                  selected: isSelected,
                                                                  selectedTileColor: const Color(0xFFE6F0FF),
                                                                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                                                  onTap: () {
                                                                    Navigator.of(context).pop(product);
                                                                  },
                                                                  trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                                                );
                                                              },
                                                            ),
                                                    ),
                                                  ],
                                                ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              );
                            },
                          ).then((picked) {
                            if (picked != null) {
                              _onProductSelected(picked);
                            }
                          });
                        },
                        child: Container(
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                          ),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          margin: const EdgeInsets.only(bottom: 8),
                          child: Row(
                            children: [
                              Expanded(
                                child: _isLoadingProducts
                                    ? const Row(
                                        mainAxisSize: MainAxisSize.min,
                                        children: [
                                          SizedBox(
                                            width: 16,
                                            height: 16,
                                            child: CircularProgressIndicator(
                                              strokeWidth: 2,
                                              color: Color(0xFF007AFF),
                                            ),
                                          ),
                                          SizedBox(width: 8),
                                          Text(
                                            'Loading products...',
                                            style: TextStyle(
                                              fontFamily: 'SF Pro Display',
                                              fontWeight: FontWeight.w400,
                                              fontSize: 15,
                                              color: Color(0xFF222222),
                                            ),
                                          ),
                                        ],
                                      )
                                    : Text(
                                        selectedProduct.isEmpty ? 'Select Product' : selectedProduct,
                                        style: const TextStyle(
                                          fontFamily: 'SF Pro Display',
                                          fontWeight: FontWeight.w400,
                                          fontSize: 15,
                                          color: Color(0xFF222222),
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                      ),
                              ),
                              Icon(
                                _isLoadingProducts 
                                    ? Icons.hourglass_empty_rounded 
                                    : Icons.keyboard_arrow_down_rounded, 
                                color: _isLoadingProducts 
                                    ? const Color(0xFF007AFF) 
                                    : const Color(0xFF222222)
                              ),
                            ],
                          ),
                        ),
                      ),
                
                Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: TextField(
                    controller: skuController,
                    enabled: isCustom, // Only editable for custom items
                    decoration: InputDecoration(
                      hintText: 'SKU Code',
                      hintStyle: GoogleFonts.poppins(color: Colors.black, fontSize: 13),
                      border: InputBorder.none,
                      contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                    ),
                    style: TextStyle(
                      fontFamily: 'SF Pro Display', 
                      fontSize: 15, 
                      color: isCustom ? Colors.black : Colors.grey[600], // Grey text when disabled
                    ),
                  ),
                ),

                
                Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: TextField(
                    controller: priceController,
                    enabled: isCustom, // Only editable for custom items
                    keyboardType: const TextInputType.numberWithOptions(decimal: true),
                    decoration: InputDecoration(
                      hintText: 'Price',
                      hintStyle: GoogleFonts.poppins(color: Colors.black, fontSize: 13),
                      border: InputBorder.none,
                      contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                    ),
                    style: TextStyle(
                      fontFamily: 'SF Pro Display', 
                      fontSize: 15, 
                      color: isCustom ? Colors.black : Colors.grey[600], // Grey text when disabled
                    ),
                  ),
                ),
                
                // Only show location field for non-custom items
                if (!isCustom) OutlinedButton(
                  onPressed: locationOptions.isNotEmpty ? () async {
                    final result = await showModalBottomSheet<String>(
                      context: context,
                      isScrollControlled: true,
                      backgroundColor: Colors.transparent,
                      builder: (context) {
                        String search = '';
                        List<Map<String, dynamic>> filteredLocations = locationOptions;
                        return StatefulBuilder(
                          builder: (context, setState) {
                            filteredLocations = locationOptions.where((location) => 
                              (location['name']?.toString().toLowerCase() ?? '').contains(search.toLowerCase())
                            ).toList();
                            return Container(
                              decoration: const BoxDecoration(
                                color: Colors.white,
                                borderRadius: BorderRadius.only(
                                  topLeft: Radius.circular(20),
                                  topRight: Radius.circular(20),
                                ),
                              ),
                              child: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  
                                  Container(
                                    margin: const EdgeInsets.only(top: 8),
                                    width: 40,
                                    height: 4,
                                    decoration: BoxDecoration(
                                      color: Colors.grey[300],
                                      borderRadius: BorderRadius.circular(2),
                                    ),
                                  ),
                                  
                                  Flexible(
                                    child: AnimationLimiter(
                                      child: SingleChildScrollView(
                                        child: Padding(
                                          padding: const EdgeInsets.all(20),
                                          child: Column(
                                            mainAxisSize: MainAxisSize.min,
                                            children: AnimationConfiguration.toStaggeredList(
                                              duration: const Duration(milliseconds: 400),
                                              childAnimationBuilder: (widget) => SlideAnimation(
                                                verticalOffset: 30.0,
                                                child: FadeInAnimation(
                                                  child: widget,
                                                ),
                                              ),
                                              children: [
                                                const Text('Select Location', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                                                const SizedBox(height: 12),
                                                TextField(
                                                  decoration: InputDecoration(
                                                    hintText: 'Search',
                                                    prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                                                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                                                  ),
                                                  onChanged: (val) {
                                                    setState(() {
                                                      search = val;
                                                    });
                                                  },
                                                ),
                                                const SizedBox(height: 12),
                                                SizedBox(
                                                  height: 300,
                                                  child: filteredLocations.isEmpty
                                                      ? const Center(child: Text('No locations found.', style: TextStyle(color: Colors.grey)))
                                                      : ListView.separated(
                                                          itemCount: filteredLocations.length,
                                                          separatorBuilder: (_, __) => Container(
                                                            height: 1,
                                                            color: Colors.black.withOpacity(0.08),
                                                            margin: const EdgeInsets.symmetric(horizontal: 8),
                                                          ),
                                                          itemBuilder: (context, index) {
                                                            final location = filteredLocations[index];
                                                            final locationName = location['name'] as String;
                                                            final isSelected = selectedLocation == locationName;
                                                            final quantity = location['quantity'] as int;
                                                            final isDefault = location['isDefault'] as bool;
                                                            
                                                            return ListTile(
                                                              title: Row(
                                                                children: [
                                                                  Expanded(
                                                                    child: Text(
                                                                      locationName,
                                                                      style: TextStyle(
                                                                        color: isSelected ? Colors.black : Colors.black,
                                                                        fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                                                      ),
                                                                    ),
                                                                  ),
                                                                  if (isDefault)
                                                                    Container(
                                                                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                                                                      decoration: BoxDecoration(
                                                                        color: const Color(0xFF007AFF),
                                                                        borderRadius: BorderRadius.circular(4),
                                                                      ),
                                                                      child: const Text(
                                                                        'Default',
                                                                        style: TextStyle(
                                                                          color: Colors.white,
                                                                          fontSize: 10,
                                                                          fontWeight: FontWeight.w500,
                                                                        ),
                                                                      ),
                                                                    ),
                                                                ],
                                                              ),
                                                              subtitle: Text(
                                                                'Quantity: $quantity',
                                                                style: const TextStyle(
                                                                  color: Colors.grey,
                                                                  fontSize: 12,
                                                                ),
                                                              ),
                                                              selected: isSelected,
                                                              selectedTileColor: const Color(0xFFE6F0FF),
                                                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                                              onTap: () {
                                                                this.setState(() {
                                                                  selectedLocation = locationName;
                                                                  _selectedLocationId = location['id'] is int 
                                                                      ? location['id'] 
                                                                      : int.tryParse(location['id'].toString()) ?? null;
                                                                  locationNameController.text = locationName;
                                                                });
                                                                Navigator.of(context).pop(locationName);
                                                              },
                                                              trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                                            );
                                                          },
                                                        ),
                                                ),
                                              ],
                                            ),
                                          ),
                                        ),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            );
                          },
                        );
                      },
                    );
                    if (result != null) {
                      setState(() {
                        selectedLocation = result;
                      });
                    }
                  } : null,
                  style: OutlinedButton.styleFrom(
                    backgroundColor: const Color(0xFFF5F5F7),
                    side: BorderSide.none,
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                    padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Expanded(
                        child: Text(
                          selectedLocation ?? 'Select Location',
                          style: TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w500,
                            fontSize: 16,
                            color: selectedLocation != null ? const Color(0xFF222222) : Colors.grey,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                    ],
                  ),
                ),
                const SizedBox(height: 8),
                
                Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(14),
                  ),
                  child: Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.remove, color: Color(0xFF222222)),
                        splashRadius: 20,
                        onPressed: () {
                          setState(() {
                            if (quantity > 1) quantity--;
                          });
                        },
                      ),
                      Expanded(
                        child: Center(
                          child: Text(
                            '$quantity',
                            style: const TextStyle(
                              fontFamily: 'SF Pro Display',
                              fontWeight: FontWeight.w400,
                              fontSize: 15,
                              color: Color(0xFF222222),
                            ),
                          ),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.add, color: Color(0xFF222222)),
                        splashRadius: 20,
                        onPressed: () {
                          setState(() {
                            quantity++;
                          });
                        },
                      ),
                    ],
                  ),
                ),
                
                if (!isCustom && selectedProduct.isNotEmpty && selectedLocation != null && _selectedLocationId != null) ...[
                  Builder(
                    builder: (context) {
                      final selectedProductObj = productData.firstWhere(
                        (p) => _createProductDisplayLabel(p) == selectedProduct,
                        orElse: () => <String, dynamic>{},
                      );
                      
                      if (selectedProductObj.isNotEmpty) {
                        final productId = selectedProductObj['id']?.toString() ?? '';
                        final locationId = _selectedLocationId.toString();
                        final availableStock = _getAvailableStock(productId, locationId);
                        final alreadyAdded = _getAlreadyAddedQuantity(productId, locationId);
                        final remainingStock = availableStock - alreadyAdded;
                        
                        return Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                          decoration: BoxDecoration(
                            color: remainingStock > 0 ? const Color(0xFFE8F5E8) : const Color(0xFFFFEBEE),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color: remainingStock > 0 ? const Color(0xFF4CAF50) : const Color(0xFFF44336),
                              width: 1,
                            ),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                remainingStock > 0 ? Icons.inventory_2 : Icons.inventory_2_outlined,
                                color: remainingStock > 0 ? const Color(0xFF4CAF50) : const Color(0xFFF44336),
                                size: 16,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  remainingStock > 0 
                                    ? 'Available: $remainingStock items (${alreadyAdded > 0 ? '$alreadyAdded already added' : 'none added yet'})'
                                    : 'Out of stock (${alreadyAdded > 0 ? '$alreadyAdded already added' : 'none available'})',
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: remainingStock > 0 ? const Color(0xFF4CAF50) : const Color(0xFFF44336),
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        );
                      }
                      return const SizedBox.shrink();
                    },
                  ),
                ],
                
                const SizedBox(height: 24),
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    onPressed: () async {
                      if (
                        (isCustom && customProductController.text.isEmpty) ||
                        (!isCustom && selectedProduct.isEmpty) ||
                        skuController.text.isEmpty ||
                        priceController.text.isEmpty ||
                        quantity <= 0
                      ) {
                        customSnackBar('Error', 'Please fill all required fields');
                        return;
                      }
                      
                      
                      // Only require location for non-custom items
                      if (!isCustom && (selectedLocation == null || selectedLocation!.isEmpty)) {
                        customSnackBar('Error', 'Please add location');
                        return;
                      }
                      
                      
                      if (!isCustom && selectedLocation != null) {
                        final selectedLocationData = locationOptions.firstWhere(
                          (location) => location['name'] == selectedLocation,
                          orElse: () => {},
                        );
                        if (selectedLocationData.isNotEmpty) {
                          final availableQuantity = selectedLocationData['quantity'] as int;
                          if (availableQuantity == 0) {
                            customSnackBar('Out of Stock', 'This product is out of stock at the selected location');
                            return;
                          }
                          
                          if (quantity > availableQuantity) {
                            customSnackBar('Out of Stock', 'Requested quantity ($quantity) exceeds available stock ($availableQuantity)');
                            return;
                          }
                        }
                      }
                      
                      
                      if (!isCustom && selectedProduct.isNotEmpty && _selectedLocationId != null) {
                        final selectedProductObj = productData.firstWhere(
                          (p) => _createProductDisplayLabel(p) == selectedProduct,
                          orElse: () => <String, dynamic>{},
                        );
                        
                        if (selectedProductObj.isNotEmpty) {
                          final productId = selectedProductObj['id']?.toString() ?? '';
                          final locationId = _selectedLocationId.toString();
                          
                          if (_wouldExceedStock(productId, locationId, quantity)) {
                            final availableStock = _getAvailableStock(productId, locationId);
                            final alreadyAdded = _getAlreadyAddedQuantity(productId, locationId);
                            final remainingStock = availableStock - alreadyAdded;
                            
                            if (remainingStock <= 0) {
                              customSnackBar('Out of Stock', 'This product is out of stock. All available quantity ($availableStock) has already been added to the order.');
                            } else {
                              customSnackBar('Out of Stock', 'Requested quantity ($quantity) exceeds remaining stock ($remainingStock). Only $remainingStock items available.');
                            }
                            return;
                          }
                        }
                      }
                      final selectedProductObj = productData.firstWhere(
                        (p) => _createProductDisplayLabel(p) == selectedProduct,
                        orElse: () => <String, dynamic>{},
                      );
                      OrderItem? orderItem;
                      if (isCustom) {
                        orderItem = OrderItem(
                          name: customProductController.text,
                          sku: skuController.text,
                          refCode: '',
                          qty: quantity,
                          price: double.tryParse(priceController.text) ?? 0,
                          productCode: '',
                          variationId: '',
                          productId: '',
                          locationId: '0',
                          weight: 0, 
                        );
                     
                      } else if (selectedProductObj.isNotEmpty) {
                        final productId = selectedProductObj['id']?.toString() ?? '';
                        final refCode = selectedProductObj['ref_code']?.toString() ?? '';
                        orderItem = OrderItem(
                          name: selectedProduct,
                          sku: skuController.text.isNotEmpty ? skuController.text : (selectedProductObj['sku'] ?? ''),
                          refCode: refCode,
                          qty: quantity,
                          price: double.tryParse(priceController.text) ?? 0,
                          productCode: selectedProductObj['id']?.toString() ?? '',
                          variationId: selectedProductObj['variation_id']?.toString() ?? '',
                          productId: productId,
                          locationId: _selectedLocationId?.toString() ?? '0',
                          weight: double.tryParse(selectedProductObj['default_weight']?.toString() ?? '0') ?? 0,
                        );
                        
                      }
                      
                      if (orderItem != null) {
                        await _showProductAddedDialog(context, orderItem);
                      }
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10),
                      ),
                      elevation: 0,
                    ),
                    child: const Text(
                      'Add',
                      style: TextStyle(
                        fontFamily: 'SF Pro Display',
                        fontWeight: FontWeight.w600,
                        fontSize: 16,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
                
                
                if (!hideCustomItem)
                  Center(
                    child: GestureDetector(
                      onTap: () {
                        setState(() {
                          isCustom = !isCustom;
                          if (!isCustom) customProductController.clear();
                        });
                      },
                      child: Text(
                        isCustom ? 'Add from Existing Catalogue' : 'Add Custom Item',
                        style: const TextStyle(
                          fontFamily: 'SF Pro Display',
                          fontWeight: FontWeight.w400,
                          fontSize: 14,
                          color: Color(0xFF222222),
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
      resizeToAvoidBottomInset: false,
      bottomNavigationBar: AppBottomBar(
        selectedIndex: 1,
        onHomeTap: () {
          Get.offAll(() => dash.DashboardScreen());
        },
        onMenuTap: () {
          Get.offAll(() => menu.MenuScreen());
        },
        onReportsTap: () {
          Get.offAll(() => report.ReportsScreen());
        },
        onOrderListTap: () {
          Get.offAll(() => OrderListScreen());
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: FloatingActionButton(
        onPressed: () {},
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
          child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
  }

  // Static method to clear all caches (useful for logout scenarios)
  static void clearAllCaches() {
    clearAllProductSuggestionsCache();
  }
}

class _ProductField extends StatelessWidget {
  final String hint;
  final TextEditingController? controller;
  final TextInputType? keyboardType;
  const _ProductField({required this.hint, this.controller, this.keyboardType});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 14),
      child: TextField(
        controller: controller,
        keyboardType: keyboardType,
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.poppins(color: Color(0xFF6B6B6B), fontSize: 13),
          filled: true,
          fillColor: Color(0xFFF5F5F7),
          contentPadding: EdgeInsets.symmetric(horizontal: 10, vertical: 10),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide.none,
          ),
        ),
        style: const TextStyle(
          fontFamily: 'SF Pro Display',
          fontWeight: FontWeight.w400,
          fontSize: 15,
          color: Colors.black,
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../network/order_service.dart';
import '../services/courier_service.dart';
import '../services/cities_service.dart';
import '../services/statement_service.dart';
import '../services/auth_service.dart';
import '../config/api_config.dart';
import 'dart:convert'; 
import 'package:dio/dio.dart'; 
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';

class AgeingReportFilterScreen extends StatefulWidget {
  final Function(Map<String, dynamic> filters) onApply;
  final VoidCallback onReset;
  final Map<String, dynamic>? initialFilters;
  const AgeingReportFilterScreen({Key? key, required this.onApply, required this.onReset, this.initialFilters}) : super(key: key);

  @override
  State<AgeingReportFilterScreen> createState() => _AgeingReportFilterScreenState();
}

class _AgeingReportFilterScreenState extends State<AgeingReportFilterScreen> {
  List<String> selectedStatuses = []; 
  List<String> selectedCouriers = []; 
  List<String> selectedCities = []; 
  String selectedAgeingType = 'Courier';

  List<String> ageingTypeOptions = ['Courier', 'Order'];
  List<String> statusOptions = [];
  List<String> courierOptions = [];
  List<String> cityOptions = [];


  
  
  bool showValidationErrors = false;
  final AuthService _authService = Get.find<AuthService>();

  
  static List<String>? _cachedStatuses;
  static List<String>? _cachedCities;

  @override
  void initState() {
    super.initState();
    
    if (widget.initialFilters != null) {
      
      final statusFilter = widget.initialFilters!['status'];
      if (statusFilter is String && statusFilter.isNotEmpty) {
        selectedStatuses = [statusFilter];
      } else if (statusFilter is List<String>) {
        selectedStatuses = List<String>.from(statusFilter);
      }
      
      final courierFilter = widget.initialFilters!['courier'];
      if (courierFilter is String && courierFilter.isNotEmpty) {
        selectedCouriers = [courierFilter];
      } else if (courierFilter is List<String>) {
        selectedCouriers = List<String>.from(courierFilter);
      }
      
      final cityFilter = widget.initialFilters!['city'];
      if (cityFilter is String && cityFilter.isNotEmpty) {
        selectedCities = [cityFilter];
      } else if (cityFilter is List<String>) {
        selectedCities = List<String>.from(cityFilter);
      }
      selectedAgeingType = widget.initialFilters!['ageingType'] as String? ?? 'Courier';
    }
    _loadUserDataAndFetchData();
  }

  Future<void> _loadUserDataAndFetchData() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchDropdownData();
  }

  Future<void> fetchDropdownData() async {
    
    if (_cachedCities != null) {
      setState(() {
        cityOptions = List<String>.from(_cachedCities!);
      });
      
      await _fetchCouriersFromCache();
      return;
    }
    
    final acno = _authService.getCurrentAcno();
    if (acno == null) {
      return;
    }
    
    
    try {
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
        data: {"status_type": ["System","Rider"]},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      final List<dynamic> data = response.data is List
          ? response.data
          : (response.data['data'] ?? []);
      statusOptions = data.map((s) => (s['name'] ?? s['status_name'] ?? '').toString()).where((s) => s.isNotEmpty).toList();
      
      _cachedStatuses = List<String>.from(statusOptions);
    } catch (_) {
      statusOptions = [];
    }
    
    
    await _fetchCouriersFromCache();
    
    
    try {
      
      final cachedCities = CitiesService.getCachedCities();
      if (cachedCities != null) {
        cityOptions = cachedCities.map((c) => c['name'].toString()).where((s) => s.isNotEmpty).toList();
        
        _cachedCities = List<String>.from(cityOptions);
      } else {
        
        final response = await Dio().post(
          ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
          data: {"country_id": 1},
          options: Options(headers: {'Content-Type': 'application/json'}),
        );
        if (response.statusCode == 200 && response.data != null) {
          final data = response.data;
          List<dynamic> cityList;
          if (data is List) {
            cityList = data;
          } else if (data is Map && data['payload'] is List) {
            cityList = data['payload'];
          } else {
            cityList = [];
          }
          cityOptions = cityList.map((c) => (c['name'] ?? c['city_name'] ?? '').toString()).where((s) => s.isNotEmpty).toList();
          
          _cachedCities = List<String>.from(cityOptions);
        } else {
          cityOptions = [];
        }
      }
    } catch (_) {
      cityOptions = [];
    }
    
    
    setState(() {
      
    });
  }

  Future<void> _fetchCouriersFromCache() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          courierOptions = [];
        });
        return;
      }
      
      
      final cachedCouriers = CourierService.getCachedCouriers(acno);
      if (cachedCouriers != null) {
        setState(() {
          courierOptions = cachedCouriers.map((c) {
            final accountTitle = c['account_title']?.toString() ?? '';
            final courierName = c['courier_name']?.toString() ?? c['name']?.toString() ?? '';
            if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
              return '$accountTitle ($courierName)';
            } else if (accountTitle.isNotEmpty) {
              return accountTitle;
            } else {
              return courierName;
            }
          }).where((s) => s.isNotEmpty).toList();
        });
      } else {
        
        final response = await Dio().post(
          ApiConfig.getEndpointUrl(ApiConfig.courierAccountsEndpoint),
          data: {"acno": acno},
          options: Options(headers: {'Content-Type': 'application/json'}),
        );
        final List<dynamic> data = response.data is List
            ? response.data
            : (response.data['data'] ?? []);
        setState(() {
          courierOptions = data.map((c) {
            final accountTitle = c['account_title']?.toString() ?? '';
            final courierName = c['courier_name']?.toString() ?? c['name']?.toString() ?? '';
            if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
              return '$accountTitle ($courierName)';
            } else if (accountTitle.isNotEmpty) {
              return accountTitle;
            } else {
              return courierName;
            }
          }).where((s) => s.isNotEmpty).toList();
        });
      }
    } catch (_) {
      setState(() {
        courierOptions = [];
      });
    }
  }

  void _showSearchDialog({
    required String title,
    required List<String> options,
    required String? selectedValue,
    required ValueChanged<String> onSelected,
  }) {
    showDialog(
      context: context,
      builder: (context) => _SearchDialog(
        title: title,
        options: options,
        selectedValue: selectedValue,
        onSelected: (val) {
          onSelected(val);
          Navigator.of(context).pop();
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    
    if (!ageingTypeOptions.contains(selectedAgeingType)) {
      selectedAgeingType = ageingTypeOptions.first;
    }
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Padding(
          padding: const EdgeInsets.only(left: 8),
          child: const Text(
            'Filter',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
        ),
        centerTitle: false,
              bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Stack(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: AnimationLimiter(
              child: Column(
                children: AnimationConfiguration.toStaggeredList(
                  duration: const Duration(milliseconds: 500),
                  childAnimationBuilder: (widget) => SlideAnimation(
                    verticalOffset: 50.0,
                    child: FadeInAnimation(
                      child: widget,
                    ),
                  ),
                  children: [
                     const SizedBox(height: 16),
                    
                    GestureDetector(
                      onTap: () async {
                        final selected = await showModalBottomSheet<String>(
                          context: context,
                          isScrollControlled: true,
                          backgroundColor: Colors.transparent,
                          builder: (context) => _AgeingTypeDialog(
                            ageingTypes: ageingTypeOptions,
                            selectedAgeingType: selectedAgeingType,
                          ),
                        );
                        if (selected != null) {
                          setState(() {
                            selectedAgeingType = selected;
                          });
                        }
                      },
                      child: Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(color: Colors.transparent, width: 1),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: Offset(0, 2),
                            ),
                          ],
                        ),
                        child: Row(
                          children: [
                            Expanded(
                              child: Text(
                                selectedAgeingType,
                                style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
                                overflow: TextOverflow.ellipsis,
                                maxLines: 1,
                              ),
                            ),
                            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                          ],
                        ),
                      ),
                    ),
                    const SizedBox(height: 2),
                    _customMultiSelectField(
                      context: context,
                      title: 'Select Status',
                      items: statusOptions,
                      selectedItems: selectedStatuses,
                      onConfirm: (values) {
                        setState(() {
                          selectedStatuses = values;
                        });
                      },
                    ),
                    const SizedBox(height: 2),
                    _customMultiSelectField(
                      context: context,
                      title: 'Select Courier',
                      items: courierOptions,
                      selectedItems: selectedCouriers,
                      onConfirm: (values) {
                        setState(() {
                          selectedCouriers = values;
                        });
                      },
                    ),
                    const SizedBox(height: 2),
                    _customMultiSelectField(
                      context: context,
                      title: 'Select Cities',
                      items: cityOptions,
                      selectedItems: selectedCities,
                      onConfirm: (values) {
                        setState(() {
                          selectedCities = values;
                        });
                      },
                    ),
                    const SizedBox(height: 20),
                    SizedBox(
                      width: double.infinity,
                      height: 48,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(10),
                          ),
                          elevation: 0,
                        ),
                        onPressed: () {
                                                     
                           if (selectedStatuses.isEmpty &&
                               selectedCouriers.isEmpty &&
                               selectedCities.isEmpty &&
                               (selectedAgeingType == null || selectedAgeingType.isEmpty)) {
                            final rootContext = Navigator.of(context, rootNavigator: true).context;
                            ScaffoldMessenger.of(rootContext).showSnackBar(
                              const SnackBar(
                                content: Text('Please select at least one filter'),
                                backgroundColor: Colors.red,
                                behavior: SnackBarBehavior.floating,
                                margin: EdgeInsets.all(16),
                                duration: Duration(seconds: 2),
                              ),
                            );
                            return;
                          }
                                                     
                           widget.onApply({
                             'status': selectedStatuses,
                             'courier': selectedCouriers,
                             'city': selectedCities,
                             'ageingType': selectedAgeingType,
                           });
                          Navigator.of(context).pop();
                        },
                        child: const Text(
                          'Apply Filters',
                          style: TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w600,
                            fontSize: 16,
                            color: Colors.white,
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(height: 16),
                    GestureDetector(
                                             onTap: () {
                         setState(() {
                           selectedStatuses.clear();
                           selectedCouriers.clear();
                           selectedCities.clear();
                         });
                         widget.onReset();
                       },
                      child: const Text('Reset Filter', style: TextStyle(color: Colors.red, fontWeight: FontWeight.w600, fontSize: 16)),
                    ),
                  ],
                ),
              ),
            ),
          ),
          
        ],
      ),
    );
  }

  Widget _searchableField({
    required String label,
    required String? value,
    required VoidCallback onTap,
    bool isError = false,
    Color fieldColor = Colors.white,
  }) {
    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: isError ? Colors.red : Colors.grey.shade300),
        borderRadius: BorderRadius.circular(10),
        color: isError ? const Color(0xFFFFEBEE) : fieldColor,
      ),
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  value ?? label,
                  style: TextStyle(
                    color: value != null ? Colors.black : Colors.black,
                  ),
                ),
              ),
              const Icon(Icons.arrow_drop_down_rounded, color: Colors.grey),
            ],
          ),
        ),
      ),
    );
  }

  Widget _customMultiSelectField({
    required BuildContext context,
    required String title,
    required List<String> items,
    required List<String> selectedItems,
    required void Function(List<String>) onConfirm,
  }) {
    return GestureDetector(
      onTap: () async {
        final result = await showModalBottomSheet<List<String>>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (ctx) => _CustomMultiSelectDialog(
            items: items,
            initialValue: selectedItems,
            onConfirm: (values) {
              Navigator.of(ctx).pop(values);
            },
            title: title,
          ),
        );
        if (result != null) {
          onConfirm(result);
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.transparent, width: 1),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                selectedItems.isEmpty ? title : selectedItems.join(', '),
                style: GoogleFonts.poppins(fontSize: 15, color: selectedItems.isEmpty ? Colors.black : Colors.black),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }

  Widget _customSingleSelectField({
    required BuildContext context,
    required String title,
    required List<String> items,
    required String? selectedItem,
    required void Function(String?) onConfirm,
  }) {
    return GestureDetector(
      onTap: () async {
        final result = await showModalBottomSheet<String>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (ctx) => _CustomSingleSelectDialog(
            items: items,
            initialValue: selectedItem,
            onConfirm: (value) {
              Navigator.of(ctx).pop(value);
            },
            title: title,
          ),
        );
        if (result != null) {
          onConfirm(result);
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.transparent, width: 1),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                selectedItem == null ? title : selectedItem,
                style: GoogleFonts.poppins(fontSize: 15, color: selectedItem == null ? Colors.grey : Colors.black),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }
}

class _SearchDialog extends StatefulWidget {
  final String title;
  final List<String> options;
  final String? selectedValue;
  final ValueChanged<String> onSelected;

  const _SearchDialog({
    Key? key,
    required this.title,
    required this.options,
    required this.selectedValue,
    required this.onSelected,
  }) : super(key: key);

  @override
  State<_SearchDialog> createState() => _SearchDialogState();
}

class _SearchDialogState extends State<_SearchDialog> {
  late List<String> _filteredOptions;
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _filteredOptions = widget.options;
  }

  void _filterOptions(String query) {
    setState(() {
      if (query.isEmpty) {
        _filteredOptions = widget.options;
      } else {
        _filteredOptions = widget.options.where((option) => option.toLowerCase().contains(query.toLowerCase())).toList();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Container(
        height: MediaQuery.of(context).size.height * 0.7,
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  widget.title,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close_rounded),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                hintText: 'Search...',
                prefixIcon: Icon(Icons.search_rounded),
                border: OutlineInputBorder(),
                contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              ),
              onChanged: _filterOptions,
            ),
            const SizedBox(height: 16),
            Expanded(
              child: _filteredOptions.isEmpty
                  ? const Center(
                      child: Text(
                        'No options found',
                        style: TextStyle(color: Colors.grey),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _filteredOptions.length,
                      itemBuilder: (context, index) {
                        final option = _filteredOptions[index];
                        final isSelected = option == widget.selectedValue;
                        return ListTile(
                          title: Text(option),
                          leading: isSelected
                              ? const Icon(Icons.check_circle_rounded, color: Color(0xFF007AFF))
                              : const Icon(Icons.radio_button_unchecked_rounded, color: Colors.grey),
                          onTap: () => widget.onSelected(option),
                          tileColor: isSelected ? const Color(0xFFE6F0FF) : null,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
}

class _CustomMultiSelectDialog extends StatefulWidget {
  final List<String> items;
  final List<String> initialValue;
  final void Function(List<String>) onConfirm;
  final String title;

  const _CustomMultiSelectDialog({
    Key? key,
    required this.items,
    required this.initialValue,
    required this.onConfirm,
    required this.title,
  }) : super(key: key);

  @override
  State<_CustomMultiSelectDialog> createState() => _CustomMultiSelectDialogState();
}

class _CustomMultiSelectDialogState extends State<_CustomMultiSelectDialog> {
  late List<String> _selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    _selected = List<String>.from(widget.initialValue);
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items
        .where((item) => item.toLowerCase().contains(_search.toLowerCase()))
        .toList();

    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: ListView.separated(
                            shrinkWrap: true,
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isChecked = _selected.contains(item);
                              return ListTile(
                                title: Text(item),
                                trailing: Checkbox(
                                  value: isChecked,
                                  activeColor: Color(0xFF007AFF),
                                  onChanged: (checked) {
                                    setState(() {
                                      if (checked == true) {
                                        _selected.add(item);
                                      } else {
                                        _selected.remove(item);
                                      }
                                    });
                                  },
                                ),
                                onTap: () {
                                  setState(() {
                                    if (isChecked) {
                                      _selected.remove(item);
                                    } else {
                                      _selected.add(item);
                                    }
                                  });
                                },
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: 100,
                          child: ElevatedButton(
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Color(0xFF007AFF),
                              elevation: 0,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                              padding: const EdgeInsets.symmetric(vertical: 14),
                            ),
                            onPressed: () {
                              Navigator.of(context).pop(_selected);
                            },
                            child: const Text('OK', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _CustomSingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final void Function(String?) onConfirm;
  final String title;

  const _CustomSingleSelectDialog({
    Key? key,
    required this.items,
    required this.initialValue,
    required this.onConfirm,
    required this.title,
  }) : super(key: key);

  @override
  State<_CustomSingleSelectDialog> createState() => _CustomSingleSelectDialogState();
}

class _CustomSingleSelectDialogState extends State<_CustomSingleSelectDialog> {
  String? _selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    _selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items
        .where((item) => item.toLowerCase().contains(_search.toLowerCase()))
        .toList();

    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      insetPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 24),
      child: SingleChildScrollView(
        child: Container(
          width: 500,
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(widget.title, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
              const SizedBox(height: 12),
              TextField(
                decoration: InputDecoration(
                  hintText: 'Search',
                  prefixIcon: Icon(Icons.search_rounded, color: Colors.black),
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                ),
                onChanged: (val) => setState(() => _search = val),
              ),
              const SizedBox(height: 12),
              SizedBox(
                height: 300,
                child: ListView.separated(
                  itemCount: filteredItems.length,
                  separatorBuilder: (_, __) => Container(
                    height: 1,
                    color: Colors.black.withOpacity(0.08),
                    margin: const EdgeInsets.symmetric(horizontal: 8),
                  ),
                  itemBuilder: (context, i) {
                    final item = filteredItems[i];
                    final isSelected = _selected == item;
                    return ListTile(
                      title: Text(item),
                      trailing: isSelected
                          ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                          : null,
                      onTap: () {
                        setState(() {
                          _selected = item;
                        });
                        widget.onConfirm(item);
                      },
                      selected: isSelected,
                      selectedTileColor: const Color(0xFFE6F0FF),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  
  static void clearAllAgeingFilterCaches() {
    _AgeingReportFilterScreenState._cachedStatuses = null;
    _AgeingReportFilterScreenState._cachedCities = null;
  }
}

class _AgeingTypeDialog extends StatefulWidget {
  final List<String> ageingTypes;
  final String selectedAgeingType;
  const _AgeingTypeDialog({Key? key, required this.ageingTypes, required this.selectedAgeingType}) : super(key: key);

  @override
  State<_AgeingTypeDialog> createState() => _AgeingTypeDialogState();
}

class _AgeingTypeDialogState extends State<_AgeingTypeDialog> {
  late List<String> filteredAgeingTypes;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredAgeingTypes = widget.ageingTypes;
    searchController = TextEditingController();
    selected = widget.selectedAgeingType;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredAgeingTypes = widget.ageingTypes.where((a) => a.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select Ageing Type', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredAgeingTypes.isEmpty
                              ? const Center(child: Text('No ageing types found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredAgeingTypes.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final ageingType = filteredAgeingTypes[i];
                                    final isSelected = ageingType == selected;
                                    return ListTile(
                                      title: Text(
                                        ageingType,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(ageingType);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../network/order_service.dart';
import '../services/auth_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'filter_screen.dart';
import 'dashboard_screen.dart' as dash;
import 'menu.dart' as menu;
import 'report.dart' as report;
import '../widgets/custom_date_selector.dart';
import 'ageing_report_filter_screen.dart';
import '../utils/custom_snackbar.dart';
import 'order_list_screen.dart';
import 'create_order.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../widgets/courier_logo_widget.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../config/api_config.dart';

class AgeingReportScreen extends StatefulWidget {
  const AgeingReportScreen({Key? key}) : super(key: key);

  @override
  State<AgeingReportScreen> createState() => _AgeingReportScreenState();
}

class _AgeingReportScreenState extends State<AgeingReportScreen> {
  
  int booked = 0;
  int arrival = 0;
  int inTransit = 0;
  int failed = 0;

  List<Map<String, dynamic>> orders = [];
  bool isLoading = false; 
  final Set<int> expanded = {};
  
  String? _searchQuery;
  List<Map<String, dynamic>> _filteredOrders = [];
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  final AuthService _authService = Get.find<AuthService>();

  
  DateTime startDate = DateTime.now().subtract(const Duration(days: 3));
  DateTime endDate = DateTime.now();

  
  String? filterAgeing;
  List<String> filterStatuses = []; 
  List<String> filterCouriers = []; 
  List<String> filterCities = []; 
  String? filterAgeingType = 'courier';

  
  static Map<String, dynamic>? _lastParams;
  static List<Map<String, dynamic>>? _cachedOrders;

  
  static void clearAllAgeingReportCaches() {
    _lastParams = null;
    _cachedOrders = null;
  }

  
  void _restoreOrFetchAgeingReport() async {
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
      'startDate': _formatDate(startDate),
      'endDate': _formatDate(endDate),
      'filterAgeing': filterAgeing,
      'filterStatuses': filterStatuses,
      'filterCouriers': filterCouriers,
      'filterCity': filterCities,
      'ageingType': filterAgeingType,
    };
    if (_lastParams != null && _cachedOrders != null && _lastParams.toString() == params.toString()) {
      setState(() {
        orders = List<Map<String, dynamic>>.from(_cachedOrders!);
        _applySearch();
      });
      await fetchSummary(); 
      return;
    }
    await fetchAllData(force: true);
  }

  @override
  void initState() {
    super.initState();
    
    _filteredOrders = [];
    _restoreOrFetchAgeingReport();
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  Future<void> _loadUserDataAndFetchData() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchAllData();
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text;
      _applySearch();
    });
  }

  Future<void> fetchAllData({bool force = false}) async {
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
      'startDate': _formatDate(startDate),
      'endDate': _formatDate(endDate),
      'filterAgeing': filterAgeing,
      'filterStatuses': filterStatuses,
      'filterCouriers': filterCouriers,
      'filterCity': filterCities,
      'ageingType': filterAgeingType,
    };
    if (!force && _lastParams != null && _cachedOrders != null &&
        _lastParams.toString() == params.toString()) {
      setState(() {
        orders = List<Map<String, dynamic>>.from(_cachedOrders!);
        _applySearch();
      });
      await fetchSummary(); 
      return;
    }
    
    
    setState(() {
      isLoading = true;
    });
    
    _lastParams = params;
    try {
      await Future.wait([
        fetchSummary(),
        fetchAgeingReport(force: force),
      ]);
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  Future<void> fetchSummary() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) return;

      final summary = await OrderService.fetchReportSummary(
        acno: acno,
        startDate: _formatDate(startDate),
        endDate: _formatDate(endDate),
        module: 'ageing_report',
      );
      setState(() {
        booked = int.tryParse(summary['booked_orders_count'] ?? '0') ?? 0;
        arrival = int.tryParse(summary['arrival_orders_count'] ?? '0') ?? 0;
        inTransit = int.tryParse(summary['intransit_orders_count'] ?? '0') ?? 0;
        failed = int.tryParse(summary['failed_orders_count'] ?? '0') ?? 0;
      });
    } catch (e) {
      
    }
  }

  Future<void> fetchAgeingReport({bool force = false}) async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        return;
      }

      
              final ageingType = (filterAgeingType ?? 'courier').toLowerCase();

      
      final data = await OrderService.fetchAgeingReport(
        acno: acno,
        startLimit: 1,
        endLimit: 50000,
        startDate: _formatDate(startDate),
        endDate: _formatDate(endDate),
        ageingType: ageingType,
        
        
        
        
      );
      
      
      if (data.isNotEmpty) {
        
      }
      
      
      List<Map<String, dynamic>> filteredData = data;
      
      
      if (filterAgeing != null) {
        filteredData = filteredData.where((order) {
          final noOfDays = int.tryParse(order['no_of_days']?.toString() ?? '0') ?? 0;
          switch (filterAgeing!.toLowerCase()) {
            case '0-3 days':
              return noOfDays >= 0 && noOfDays <= 3;
            case '4-7 days':
              return noOfDays >= 4 && noOfDays <= 7;
            case '8-15 days':
              return noOfDays >= 8 && noOfDays <= 15;
            case '16+ days':
              return noOfDays >= 16;
            default:
              return true;
          }
        }).toList();
      }
      
      
      if (filterStatuses.isNotEmpty) {
        filteredData = filteredData.where((order) {
          final orderStatus = order['status_name']?.toString().toLowerCase().trim();
          return filterStatuses.any((status) => 
            orderStatus == status.toLowerCase().trim()
          );
        }).toList();
      }
      
      
      if (filterCouriers.isNotEmpty) {
        

        
        filteredData = filteredData.where((order) {
          final orderCourierName = order['courier_name']?.toString().toLowerCase().trim();
          final orderAccountTitle = order['account_title']?.toString().toLowerCase().trim();
          
          
          bool matches = false;
          for (final filterCourier in filterCouriers) {
            final filterCourierLower = filterCourier.toLowerCase().trim();
            
            
            if (filterCourierLower.contains('managed')) {
              if (orderAccountTitle != null && orderAccountTitle.contains('managed')) {
                matches = true;
              
                break;
              }
            }
            
            else {
              
              if (orderCourierName == filterCourierLower) {
                
                if (orderAccountTitle == null || !orderAccountTitle.contains('managed')) {
                  matches = true;
                  
                  break;
                }
              }
              
              
              if (!matches && filterCourierLower.contains('(') && filterCourierLower.contains(')')) {
                final regex = RegExp(r'\(([^)]+)\)');
                final match = regex.firstMatch(filterCourierLower);
                if (match != null) {
                  final extractedCourier = match.group(1)?.toLowerCase().trim();
                  if (orderCourierName == extractedCourier) {
                    
                    if (orderAccountTitle == null || !orderAccountTitle.contains('managed')) {
                      matches = true;
                      
                      break;
                    }
                  }
                }
              }
              
              
              if (!matches && orderCourierName != null && orderCourierName.isNotEmpty) {
                if (orderCourierName.contains(filterCourierLower) || filterCourierLower.contains(orderCourierName)) {
                  
                  if (orderAccountTitle == null || !orderAccountTitle.contains('managed')) {
                    matches = true;
                    
                    break;
                  }
                }
              }
            }
          }
          
          
          if (orderCourierName != null && orderCourierName.isNotEmpty) {
            
          }
          
          return matches;
        }).toList();
        
        
      }
      
      
      if (filterCities.isNotEmpty) {
        filteredData = filteredData.where((order) {
          final orderCity = order['city_name']?.toString().toLowerCase().trim();
          return filterCities.any((city) => 
            orderCity == city.toLowerCase().trim()
          );
        }).toList();
      }
      
      if (filteredData.isNotEmpty) {
       
      }
      
      setState(() {
        orders = filteredData;
        _cachedOrders = List<Map<String, dynamic>>.from(filteredData); 
        _applySearch();
      });
    } catch (e) {
      
     
    }
  }

  void _applySearch() {
    if (_searchQuery != null && _searchQuery!.isNotEmpty) {
      _filteredOrders = orders.where((order) {
        return order.values.any((v) => v != null && v.toString().toLowerCase().contains(_searchQuery!.toLowerCase()));
      }).toList();
    } else {
      _filteredOrders = orders;
    }
  }

  String _formatDate(DateTime date) {
    return " ${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}";
  }

  String _formatOrderDate(String? dateString) {
    if (dateString == null || dateString.isEmpty) return '-';
    
    try {
      // Try to parse the date string
      final date = DateTime.tryParse(dateString);
      if (date != null) {
        // Format to show only date (YYYY-MM-DD)
        return "${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}";
      }
      
      // If parsing fails, try to extract just the date part if it contains time
      if (dateString.contains(' ')) {
        final datePart = dateString.split(' ')[0];
        if (datePart.contains('-') && datePart.split('-').length == 3) {
          return datePart;
        }
      }
      
      // Return original if no parsing possible
      return dateString;
    } catch (e) {
      return dateString;
    }
  }

  Future<void> _openDateSelector() async {
    final picked = await showModalBottomSheet<DateTimeRange>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        width: MediaQuery.of(context).size.width,
        height: MediaQuery.of(context).size.height * 0.6,
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: CustomDateSelector(
          initialStartDate: startDate,
          initialEndDate: endDate,
        ),
      ),
    );
    if (picked != null) {
      setState(() {
        startDate = picked.start;
        endDate = picked.end;
      });
      fetchAllData();
    }
  }

  String _getAgeingReportFilterSummary() {
    final summary = <String>[];
    
    if (filterAgeingType != null && filterAgeingType!.isNotEmpty) {
      final ageingTypeLabel = filterAgeingType![0].toUpperCase() + filterAgeingType!.substring(1);
      summary.add('Ageing Type: $ageingTypeLabel');
    }
    if (filterAgeing != null) summary.add('Ageing: $filterAgeing');
    if (filterStatuses.isNotEmpty) summary.add('Statuses: ${filterStatuses.join(", ")}');
    if (filterCouriers.isNotEmpty) summary.add('Couriers: ${filterCouriers.join(", ")}');
    if (filterCities.isNotEmpty) summary.add('Cities: ${filterCities.join(", ")}');
    
    
    final currentList = (_searchQuery != null && _searchQuery!.isNotEmpty) ? _filteredOrders : orders;
    final count = currentList.length;
    final summaryString = summary.where((s) => s.isNotEmpty).join(", ");
    return summaryString.isNotEmpty ? (summaryString + (count > 0 ? ' ($count)' : '')) : (count > 0 ? '($count)' : '');
  }

  String? _getCourierLogoUrl(String? courierName) {
    if (courierName == null || courierName.isEmpty) return null;
    return '${ApiConfig.assetBaseUrl}${Uri.encodeComponent(courierName.trim())}.svg';
  }

  Future<void> _manualRefresh() async {
    await fetchAllData(force: true);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          backgroundColor: Colors.white,
          
          foregroundColor: Colors.black,
          surfaceTintColor: Colors.white,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
            onPressed: () => Navigator.of(context).maybePop(),
          ),
          title: const Text(
            'Ageing Report',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
          actions: [
            if (_searchQuery != null && _searchQuery!.isNotEmpty)
              IconButton(
                icon: const Icon(Icons.clear_rounded, color: Colors.grey),
                onPressed: () {
                  setState(() {
                    _searchController.clear();
                    _searchQuery = null;
                    _applySearch();
                  });
                },
              ),
            IconButton(
              icon: SvgPicture.asset(
    'assets/Filter.svg',
    width: 24,
    height: 24,
    color: Colors.black, 
  ),
              onPressed: () async {
                await Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => AgeingReportFilterScreen(
                                             onApply: (filters) {
                         setState(() {
                           filterAgeing = filters['ageing'];
                           
                           final statusFilter = filters['status'];
                           if (statusFilter is String && statusFilter.isNotEmpty) {
                             filterStatuses = [statusFilter];
                           } else if (statusFilter is List<String>) {
                             filterStatuses = List<String>.from(statusFilter);
                           } else {
                             filterStatuses = [];
                           }
                           
                           final courierFilter = filters['courier'];
                           if (courierFilter is String && courierFilter.isNotEmpty) {
                             filterCouriers = [courierFilter];
                           } else if (courierFilter is List<String>) {
                             filterCouriers = List<String>.from(courierFilter);
                           } else {
                             filterCouriers = [];
                           }
                           
                           final cityFilter = filters['city'];
                           if (cityFilter is String && cityFilter.isNotEmpty) {
                             filterCities = [cityFilter];
                           } else if (cityFilter is List<String>) {
                             filterCities = List<String>.from(cityFilter);
                           } else {
                             filterCities = [];
                           }
                           filterAgeingType = (filters['ageingType'] as String?)?.toLowerCase() ?? 'courier';
                         });
                                                 

                        fetchAllData();
                        
                        customSnackBar('Success', 'Filters applied successfully');
                      },
                                             onReset: () {
                         setState(() {
                           filterAgeing = null;
                           filterStatuses.clear();
                           filterCouriers.clear();
                           filterCities.clear();
                           filterAgeingType = 'courier';
                         });
                        fetchAllData();
                        
                        customSnackBar('Success', 'Filters reset successfully');
                      },
                      initialFilters: {
                        'ageing': filterAgeing,
                        'status': filterStatuses,
                        'courier': filterCouriers,
                        'city': filterCities,
                        'ageingType': filterAgeingType,
                      },
                    ),
                  ),
                );
              },
            ),
            IconButton(
              icon: SvgPicture.asset(
    'assets/Calender.svg',
    width: 24,
    height: 24,
     
  ),
              onPressed: () async {
                final picked = await showModalBottomSheet<DateTimeRange>(
                  context: context,
                  isScrollControlled: true,
                  backgroundColor: Colors.transparent,
                  builder: (context) => Container(
                    width: MediaQuery.of(context).size.width,
                    height: MediaQuery.of(context).size.height * 0.6,
                    decoration: const BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                    ),
                    child: CustomDateSelector(
                      initialStartDate: startDate,
                      initialEndDate: endDate,
                    ),
                  ),
                );
                if (picked != null) {
                  setState(() {
                    startDate = picked.start;
                    endDate = picked.end;
                  });
                  fetchAllData();
                }
              },
            ),
          ],
        ),
        body: isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
          : GestureDetector(
              behavior: HitTestBehavior.translucent,
              onTap: () {
                FocusScope.of(context).unfocus();
              },
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
                
                Padding(
                  padding: const EdgeInsets.only(bottom: 4, top: 8),
                  child: Text(
                    _getDateRangeFormatted(),
                    style: const TextStyle(
                      fontFamily: 'SF Pro Display',
                      fontWeight: FontWeight.w400,
                      fontSize: 14,
                      color: Colors.grey,
                    ),
                  ),
                ),
                
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 4),
                  child: TextField(
                    controller: _searchController,
                    focusNode: _searchFocusNode,
                    decoration: InputDecoration(
                      hintText: 'Search',
                      suffixIcon: Icon(Icons.search_rounded),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      filled: true,
                      fillColor: const Color(0xFFF5F5F7),
                      contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                      ),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide.none,
                      ),
                    ),
                  ),
                ),
                
                                 
                 if (filterAgeing != null || filterStatuses.isNotEmpty || filterCouriers.isNotEmpty || filterCities.isNotEmpty || filterAgeingType != null) ...[
            const SizedBox(height: 8),
            Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: Colors.blue.withOpacity(0.1),
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.blue.withOpacity(0.3)),
              ),
              child: Row(
                children: [
                  Icon(Icons.filter_list_rounded, size: 16, color: Colors.blue[700]),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _getAgeingReportFilterSummary(),
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.blue[700],
                              fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                  GestureDetector(
                    onTap: () async {
                      setState(() {
                        filterAgeing = null;
                        filterStatuses.clear();
                        filterCouriers.clear();
                                                   filterCities.clear();
                        filterAgeingType = 'courier';
                      });
                      await fetchAllData();
                      customSnackBar('Success', 'Filters cleared');
                    },
                    child: Icon(Icons.clear_rounded, size: 16, color: Colors.blue[700]),
                  ),
                ],
              ),
            ),
                ],
                const SizedBox(height: 8),
            
            Container(
                  width: MediaQuery.of(context).size.width,
                  padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 18),
              decoration: BoxDecoration(
                    color: const Color(0xFFE6F1FF),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  _SummaryColumn(label: 'Booked', value: booked.toString()),
                  _SummaryColumn(label: 'Arrival', value: arrival.toString()),
                  _SummaryColumn(label: 'In Transit', value: inTransit.toString()),
                  _SummaryColumn(label: 'Failed', value: failed.toString()),
                ],
              ),
            ),
            const SizedBox(height: 8),
            
            Expanded(
              child: RefreshIndicator(
                        onRefresh: _manualRefresh,
                          child: AnimationLimiter(
                            child: ListView.builder(
                          physics: const AlwaysScrollableScrollPhysics(),
                          padding: const EdgeInsets.only(bottom: 80, top: 8),
                          itemCount: (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredOrders : orders).length,
                          itemBuilder: (context, i) {
                            final order = (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredOrders : orders)[i];
                                return AnimationConfiguration.staggeredList(
                                  position: i,
                                  duration: const Duration(milliseconds: 450),
                                  child: SlideAnimation(
                                    verticalOffset: 50.0,
                                    child: FadeInAnimation(
                                      child: Column(
                                        children: [
                                          Container(
                                            width: double.infinity,
                                            margin: const EdgeInsets.only(top: 4, bottom: 4),
                                            padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF5F5F7),
                                              borderRadius: BorderRadius.circular(12),
                                ),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                                    Expanded(
                                                      child: Padding(
                                                        padding: const EdgeInsets.only(top: 8),
                                                        child: Text(
                                                          'Order ID: ${order['id'] ?? ''}',
                                                          style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                                                        ),
                                                      ),
                                                    ),
                                                    Column(
                                                      children: [
                                                        const SizedBox(height: 6),
                                          Builder(
                                            builder: (context) {
                                              final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').trim();
                                                            final bgColor = _statusColor(status).withOpacity(0.1);
                                                            final txtColor = _statusColor(status);
                                              return Container(
                                                constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                                              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                decoration: BoxDecoration(
                                                  color: bgColor,
                                                  borderRadius: BorderRadius.circular(16),
                                                ),
                                                alignment: Alignment.center,
                                                child: Text(
                                                  status.isNotEmpty
                                                      ? (() {
                                                          final s = status.toLowerCase();
                                                          if (s == 'booked') return 'Booked';
                                                                        if (s == 'arrival') return 'Arrival';
                                                                        if (s == 'in transit') return 'In Transit';
                                                                        if (s == 'failed') return 'Failed';
                                                                        return status.capitalize ?? status;
                                                        })()
                                                                    : '-',
                                                                style: GoogleFonts.inter(color: txtColor, fontWeight: FontWeight.w500, fontSize: 15),
                                                  overflow: TextOverflow.ellipsis,
                                                ),
                                              );
                                            },
                                          ),
                                        ],
                                      ),
                                                  ],
                                    ),
                                                const SizedBox(height: 4),
                                                Row(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Name', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((order['consignee_name'] ?? '').isEmpty ? '-' : (order['consignee_name'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                              crossAxisAlignment: CrossAxisAlignment.center,
                                              children: [
                                                SizedBox(
                                                            width: 100,
                                                            child: Text(() {
                                                              final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                              return (status == 'booked' || status == 'pickup ready' || status == 'confirmed') ? 'Booking Date' : 'Order Date';
                                                            }(), style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                ),
                                                          const SizedBox(width: 36),
                                                Expanded(
                                                            child: Text(() {
                                                              final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                              if (status == 'booked' || status == 'pickup ready' || status == 'confirmed') {
                                                                return (order['shipment_date'] ?? '').isEmpty ? '-' : _formatOrderDate(order['shipment_date']);
                                                              } else {
                                                                return (order['order_date'] ?? '').isEmpty ? '-' : _formatOrderDate(order['order_date']);
                                                              }
                                                            }(), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                    ),
                                                        ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text(() {
                                                              final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                              return (status == 'pickup' || status == 'booked' || status == 'confirmed' || status == 'pickup ready') ? 'CN' : 'City';
                                                            }(), style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text(() {
                                                              final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                              if (status == 'pickup' || status == 'booked' || status == 'confirmed' || status == 'pickup ready') {
                                                                final consignmentNo = order['consigment_no'] ?? '';
                                                                return consignmentNo.toString().isEmpty ? '-' : consignmentNo.toString();
                                                              } else {
                                                                final cityName = order['city_name'] ?? '';
                                                                return cityName.toString().isEmpty ? '-' : cityName.toString();
                                                              }
                                                            }(), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                          ],
                                        ),
                                      ),
                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Order Amount', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((order['order_amount'] ?? '').toString().isEmpty ? '-' : 'Rs. ${order['order_amount']?.toString() ?? ''}', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                                                                                         width: (() {
                                                               final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                               if (status == 'booked' || status == 'pickup ready' || status == 'confirmed') {
                                                                 return order['courier_name'] != null &&
                                                                        order['courier_name'].toString().length > 10
                                                                      ? 113.0
                                                                      : 98.0;
                                                               } else {
                                                                 return 107.0; 
                                                               }
                                                             }()),
                                                            child: Text(() {
                                                              final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                              return (status == 'booked' || status == 'pickup ready' || status == 'confirmed') ? 'Courier' : 'Store';
                                                            }(), style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                                                                                     SizedBox(
                                                             width: (() {
                                                               final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                               return (status == 'booked' || status == 'pickup ready' || status == 'confirmed') ? 26.0 : 30.0;
                                                             }()),
                                                           ),
                                                          (() {
                                                            final status = (order['status_name']?.toString() ?? order['status']?.toString() ?? '').toLowerCase().trim();
                                                            if (status == 'booked' || status == 'pickup ready' || status == 'confirmed') {
                                                              
                                                              if (order['courier_name'] != null && order['courier_name'].toString().isNotEmpty) {
                                                                final pngUrl = order['courier_name'].toString();
                                                                final isManaged = pngUrl.toLowerCase().trim() == 'managed';
                                                                final courierId = order['courier_id']?.toString();
                                                                
                                                                
                                                                
                                                                return CourierLogoWidget(
                                                                  pngUrl: pngUrl,
                                                                  courierId: courierId,
                                                                  accountTitle: order['account_title']?.toString(),
                                                                  width: 78,
                                                                  height: 36,
                                                                  fit: BoxFit.contain,
                                                                );
                                                              } else {
                                                                return const SizedBox(height: 24);
                                                              }
                                                                                                                         } else {
                                                               
                                                               final storeName = order['store_name'] ?? '';
                                                               return Expanded(
                                                                 child: Text(
                                                                   storeName.toString().isEmpty ? '-' : storeName.toString(),
                                                                   style: GoogleFonts.inter(fontWeight: FontWeight.w300),
                                                                 ),
                                                               );
                                                             }
                                                          })(),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 12),
                                                GestureDetector(
                                                  onTap: () {
                                                    _showAgeingReportDetailsBottomSheet(context, order);
                                                  },
                                                  child: Text(
                                                    'View Details',
                                                    style: GoogleFonts.inter(
                                                      color: const Color(0xFF007AFF),
                                                      fontWeight: FontWeight.w500,
                                                      fontSize: 14,
                                                      decoration: TextDecoration.none,
                                                    ),
                                                  ),
                                                ),
                                              ],
                                            ),
                                          ),
                                          const SizedBox(height: 8),
                                        ],
                                      ),
                                ),
                              ),
                            );
                          },
                            ),
                        ),
                        ),
            ),
          ],
          ),
        ),
      ),
      bottomNavigationBar: AppBottomBar(
        selectedIndex: 2,
        onHomeTap: () {
          Get.offAll(() => dash.DashboardScreen());
        },
        onMenuTap: () {
          Get.offAll(() => menu.MenuScreen());
        },
        onReportsTap: () {
          Get.offAll(() => report.ReportsScreen());
        },
        onOrderListTap: () {
          Get.to(() => OrderListScreen(from: 'ageing_report'));
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: MediaQuery.of(context).viewInsets.bottom == 0
          ? FloatingActionButton(
              onPressed: () {
                Navigator.of(context).pushAndRemoveUntil(
                  MaterialPageRoute(builder: (_) => CreateOrderScreen(from: 'ageing_report')),
                  (route) => false,
                );
              },
              backgroundColor: const Color(0xFF0A253B),
              elevation: 4,
              shape: const CircleBorder(),
                child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
            )
          : null,
    );
  }

  Widget _infoRow(String label, dynamic value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(
            flex: 2,
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text('$label:', style: const TextStyle(fontWeight: FontWeight.w500)),
            ),
          ),
          Expanded(
            flex: 3,
            child: Align(
              alignment: Alignment.center,
              child: Text(value?.toString() ?? ''),
            ),
          ),
        ],
      ),
    );
  }

  String _getDateRangeFormatted() {
    String format(DateTime d) =>
        '${d.day.toString().padLeft(2, '0')}-${d.month.toString().padLeft(2, '0')}-${d.year}';
    return '${format(startDate)} to ${format(endDate)}';
  }

  void _showAgeingReportDetailsBottomSheet(BuildContext context, Map<String, dynamic> order) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: AnimationLimiter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: AnimationConfiguration.toStaggeredList(
                    duration: const Duration(milliseconds: 500),
                    childAnimationBuilder: (widget) => SlideAnimation(
                      verticalOffset: 30.0,
                      child: FadeInAnimation(
                        child: widget,
                      ),
                    ),
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            children: [
                              const Text(
                                'Details',
                                style: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  fontSize: 18,
                                  fontFamily: 'SF Pro Display',
                                ),
                              ),

                            ],
                          ),
                          IconButton(
                            icon: const Icon(Icons.close_rounded),
                            onPressed: () => Navigator.of(context).pop(),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      _ageingReportDetailRow('Order ID', order['id']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Name', order['consignee_name']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Contact', order['consignee_contact']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Date', _formatOrderDate(order['order_date'])),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Booking Date', _formatOrderDate(order['shipment_date'])),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('City', order['city_name']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Web Order ID', order['order_ref']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Store', order['store_name']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow(
                        'Payment Type',
                        order['payment_method_id'] == '1'
                            ? 'COD'
                            : order['payment_method_id'] == '2'
                                ? 'CC'
                                : (order['payment_type']?.toString() ?? ''),
                      ),
                      const SizedBox(height: 10),
                      if (order['payment_method_id'] == '1')
                        _ageingReportDetailRow('COD Amount', order['order_amount']?.toString() ?? '')
                      else if (order['payment_method_id'] == '2')
                        _ageingReportDetailRow('CC Amount', order['order_amount']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('Account', order['account_title']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow('CN', order['consigment_no']?.toString() ?? ''),
                      const SizedBox(height: 10),
                      _ageingReportDetailRow(
                        'No of Days',
                        () {
                          if (filterAgeingType == 'order') {
                            final statusDays = order['status_activity_days']?.toString();
                            final orderDays = order['order_activity_days']?.toString();
                            if (statusDays != null && orderDays != null && statusDays.isNotEmpty && orderDays.isNotEmpty) {
                              return '$statusDays/$orderDays';
                            } else {
                              return statusDays ?? orderDays ?? '';
                            }
                          } else if (filterAgeingType == 'courier') {
                            final statusDays = order['status_activity_days']?.toString();
                            final bookingDays = order['booking_activity_days']?.toString();
                            if (statusDays != null && bookingDays != null && statusDays.isNotEmpty && bookingDays.isNotEmpty) {
                              return '$statusDays/$bookingDays';
                            } else {
                              return statusDays ?? bookingDays ?? '';
                            }
                          } else {
                            return order['no_of_days']?.toString() ?? '';
                          }
                        }(),
                      ),
                     
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _ageingReportDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14)),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }
}

class _SummaryColumn extends StatelessWidget {
  final String label;
  final String value;
  const _SummaryColumn({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(value, style: const TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w700, fontSize: 16, color: Colors.black)),
        const SizedBox(height: 2),
        Text(label, style: const TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w300, fontSize: 13, color: Color(0xFF8E8E93))),
      ],
    );
  }
} 

Widget _defListRowAgeing(String label, dynamic value) {
  return Row(
    crossAxisAlignment: CrossAxisAlignment.center,
    children: [
      SizedBox(
        width: 100,
        child: Text(label, style: TextStyle(fontWeight: FontWeight.w400, fontSize: 14, color: Colors.black)),
      ),
      const SizedBox(width: 36), 
      Expanded(
        child: Align(
          alignment: Alignment.centerLeft,
          child: Text(value?.toString() ?? '', style: TextStyle(fontWeight: FontWeight.w300, fontSize: 14)),
        ),
      ),
    ],
  );
} 

Color _statusColor(String? status) {
  final s = status?.toLowerCase().trim();
  
  // New comprehensive status color mapping
  if (s == 'cancelled' || s == 'deleted') return const Color(0xFF464646);
  if (s == 'booked') return const Color(0xFF8e24aa); 
  if (s == 'new') return const Color(0xFF1DA1F2); 
  if (s == 'pickup ready') return const Color(0xFF43A047); 
  if (s == 'in transit') return const Color(0xFFea7317);
  if (s == 'out for delivery') return const Color(0xFFf2d016);
  if (s == 'delivered') return const Color(0xFF15ad38);
  if (s == 'shipped') return const Color(0xFF4191ff);
  if (s == 'onroute') return const Color(0xFFf2d016);
  if (s == 'accepted') return const Color(0xFF9b51e0);
  if (s == 'rejected') return const Color(0xFFff7400);
  if (s == 'returned') return const Color(0xFFf83245);
  if (s == 'replacement') return const Color(0xFF66cccc);
  if (s == 'error' || s == 'badge-error') return const Color(0xFFf64e60);
  
  // Default color for unknown statuses
  return const Color(0xFF8e24aa);
}

Color _statusTextColor(Color bg) {
  
  final brightness = ThemeData.estimateBrightnessForColor(bg);
  return brightness == Brightness.light ? Colors.black : Colors.white;
}

Color _statusBackgroundColor(String? status) {
  final s = status?.toLowerCase().trim();
  
  // Background colors matching the CSS scheme
  if (s == 'cancelled' || s == 'deleted') return const Color(0xFF46464629);
  if (s == 'booked') return const Color(0xFF8e24aa); 
  if (s == 'new') return const Color(0xFF1DA1F2); 
  if (s == 'pickup ready') return const Color(0xFF43A047); 
  if (s == 'in transit') return const Color(0xFFf3b98cad);
  if (s == 'out for delivery') return const Color(0xFFf2d01636);
  if (s == 'delivered') return const Color(0xFF1bc9432b);
  if (s == 'shipped') return const Color(0xFF4191ff2e);
  if (s == 'onroute') return const Color(0xFFf2d01636);
  if (s == 'accepted') return const Color(0xFF9b51e029);
  if (s == 'rejected') return const Color(0xFFff740036);
  if (s == 'returned') return const Color(0xFFf832452e);
  if (s == 'replacement') return const Color(0xFF66cccc2e);
  if (s == 'error' || s == 'badge-error') return const Color(0xFFffe2e6);
  
  // Default background color for unknown statuses
  return const Color(0xFF8e24aa);
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:dio/dio.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../config/api_config.dart';
import 'dashboard_screen.dart';
import 'order_list_screen.dart';
import 'report.dart';
import 'menu.dart';
import 'create_order.dart';

class BulkTrackingScreen extends StatefulWidget {
  final String? acno;
  final String? orderIds;
  final String? consignmentNos;
  const BulkTrackingScreen({Key? key, this.acno, this.orderIds, this.consignmentNos}) : super(key: key);

  @override
  State<BulkTrackingScreen> createState() => _BulkTrackingScreenState();
}

class _BulkTrackingScreenState extends State<BulkTrackingScreen> {
  bool isLoading = false;
  String? errorMessage;
  dynamic result;
  Set<int> expanded = {};

  @override
  void initState() {
    super.initState();
    
    if ((widget.acno ?? '').isNotEmpty && (widget.orderIds ?? '').isNotEmpty && (widget.consignmentNos ?? '').isNotEmpty) {
      _autoTrack();
    }
  }

  Future<void> _autoTrack() async {
    setState(() {
      isLoading = true;
      errorMessage = null;
      result = null;
    });
    try {
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.shipmentBulkTrackingEndpoint),
        data: {
          'acno': widget.acno,
          'order_id': widget.orderIds,
          'consigment_no': widget.consignmentNos,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      setState(() {
        result = response.data;
        isLoading = false;
      });
    } catch (e) {
      setState(() {
        errorMessage = 'No data found';
        isLoading = false;
      });
    }
  }

  @override
 Widget build(BuildContext context) {
  return Scaffold(
    backgroundColor: Colors.white,
    appBar: AppBar(
      title: const Text(
        'Bulk Shipment Tracking',
        style: TextStyle(
          fontFamily: 'SF Pro Display',
          fontWeight: FontWeight.w600,
          fontSize: 20,
          color: Colors.black,
        ),
      ),
      backgroundColor: Colors.white,
      elevation: 0,
      
      foregroundColor: Colors.black, 
      surfaceTintColor: Colors.white,
      bottom: PreferredSize(
        preferredSize: Size.fromHeight(1),
        child: Container(
          height: 1,
          color: Colors.grey[300],
        ),
      ),
    ),
    body: Container(
      color: Colors.white,
      child: Padding(
      padding: const EdgeInsets.all(16.0),
      child: isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
          : errorMessage != null
              ? Center(
                  child: Text(
                    errorMessage!,
                    style: const TextStyle(color: Colors.black),
                  ),
                )
              : result != null
                  ? AnimationLimiter(
                      child: _buildResultList(),
                    )
                  : const Center(
                      child: Text('No tracking results found.'),
                    ),
      ),
    ),
    bottomNavigationBar: AppBottomBar(
      selectedIndex: -1, 
      onHomeTap: () => Get.to(() => DashboardScreen()),
      onOrderListTap: () => Get.to(() => const OrderListScreen(from: 'bulk_tracking')),
      onReportsTap: () => Get.to(() => const ReportsScreen(from: 'bulk_tracking')),
      onMenuTap: () => Get.to(() => const MenuScreen()),
    ),
    floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
    floatingActionButton: FloatingActionButton(
      onPressed: () {
        Get.to(() => const CreateOrderScreen(from: 'bulk_tracking'));
      },
      backgroundColor: const Color(0xFF0A253B),
      elevation: 4,
      shape: const CircleBorder(),
      child: SvgPicture.asset(
        'assets/Create Order.svg',
        width: 28,
        height: 28,
        color: Colors.white,
      ),
    ),
  );
}



  Widget _buildResultList() {
    List<dynamic> shipments;
    if (result is Map && result['payload'] is List) {
      shipments = result['payload'];
    } else if (result is List) {
      shipments = result;
    } else if (result is Map && result['data'] is List) {
      shipments = result['data'];
    } else if (result is Map && result['shipments'] is List) {
      shipments = result['shipments'];
    } else if (result != null) {
      shipments = [result];
    } else {
      return const Text('No tracking results found.');
    }
    if (shipments.isEmpty) {
      return const Text('No tracking results found.');
    }
    return ListView.separated(
      itemCount: shipments.length,
      separatorBuilder: (context, i) => const SizedBox(height: 12),
      itemBuilder: (context, i) {
        final shipment = shipments[i];
        final status = shipment['status_name']?.toString() ?? shipment['status']?.toString() ?? '-';
        final consignmentNo = shipment['consigment_no']?.toString() ?? '-';
        final date = shipment['booking_date']?.toString() ?? shipment['created_at']?.toString() ?? '-';
        final consignee = shipment['consignee_name']?.toString() ?? '-';
        final amount = shipment['order_amount']?.toString() ?? '-';
        final origin = shipment['origin']?.toString() ?? '-';
        final destination = shipment['destination']?.toString() ?? '-';
        final detailList = shipment['detail'] as List<dynamic>? ?? [];
        Color statusColor = Colors.grey;
        
        switch (status.toLowerCase()) {
          case 'cancelled':
            statusColor = Colors.red;
            break;
          case 'booked':
            statusColor = Color(0xFF8e24aa);
            break;
          case 'new':
            statusColor = Color(0xFF1DA1F2);
            break;
          case 'pickup ready':
            statusColor = Color(0xFF43A047);
            break;
          default:
            statusColor = Colors.grey;
        }
        return AnimationConfiguration.staggeredList(
          position: i,
          duration: const Duration(milliseconds: 400),
          child: SlideAnimation(
            verticalOffset: 50.0,
            child: FadeInAnimation(
              child: Container(
                width: double.infinity,
                margin: const EdgeInsets.only(top: 4, bottom: 4),
                padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                decoration: BoxDecoration(
                  color: const Color(0xFFF5F5F7),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          child: Padding(
                            padding: const EdgeInsets.only(top: 8),
                            child: Text(
                              'CN#: $consignmentNo',
                              style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                            ),
                          ),
                        ),
                        Column(
                          children: [
                            SizedBox(height: 6),
                            Container(
                              constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                              decoration: BoxDecoration(
                                color: statusColor.withOpacity(0.1),
                                borderRadius: BorderRadius.circular(16),
                              ),
                              alignment: Alignment.center,
                              child: Text(
                                status,
                                style: GoogleFonts.inter(
                                  color: statusColor,
                                  fontWeight: FontWeight.w500, 
                                  fontSize: 15
                                ),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                      const SizedBox(height: 4),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.center,
                              children: [
                                SizedBox(
                                  width: 100,
                                  child: Text('Date', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                ),
                                const SizedBox(width: 36),
                                Expanded(
                                  child: Text(date.isEmpty ? '-' : date, style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.center,
                              children: [
                                SizedBox(
                                  width: 100,
                                  child: Text('Customer', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                ),
                                const SizedBox(width: 36),
                                Expanded(
                                  child: Text(consignee.isEmpty ? '-' : consignee, style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.center,
                              children: [
                                SizedBox(
                                  width: 100,
                                  child: Text('Amount', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                ),
                                const SizedBox(width: 36),
                                Expanded(
                                  child: Text(amount.isEmpty ? '-' : amount, style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Row(
                              crossAxisAlignment: CrossAxisAlignment.center,
                              children: [
                                SizedBox(
                                  width: 100,
                                  child: Text('From To', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                ),
                                const SizedBox(width: 36),
                                Expanded(
                                  child: Text('$origin   $destination', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Text('Courier Shipping Label: $consignmentNo', style: GoogleFonts.inter(fontWeight: FontWeight.w700, fontSize: 15)),
                      const SizedBox(height: 4),
                      if (detailList.isEmpty)
                        Text('No tracking history available.', style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 13, color: const Color(0xFF6B7280))),
                      ...detailList.map<Widget>((d) {
                        final status = d['status'] ?? '-';
                        final date = d['dateTime'] ?? '-';
                        return Padding(
                          padding: const EdgeInsets.only(bottom: 2),
                          child: Text(
                            '$date - $status',
                            style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 13, color: const Color(0xFF6B7280)),
                          ),
                        );
                      }).toList(),
                    ],
                  ),
                ),
              ),
            ),
        );
      },
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../utils/custom_snackbar.dart';
import 'package:flutter_svg/flutter_svg.dart';

class ChangePasswordScreen extends StatefulWidget {
  const ChangePasswordScreen({Key? key}) : super(key: key);

  @override
  State<ChangePasswordScreen> createState() => _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends State<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController oldPasswordController = TextEditingController();
  final TextEditingController newPasswordController = TextEditingController();
  final TextEditingController confirmPasswordController = TextEditingController();
  final AuthService _authService = Get.find<AuthService>();
  
  bool obscureOld = true;
  bool obscureNew = true;
  bool obscureConfirm = true;
  bool _isLoading = false;
  String _userId = '';
  String _acno = '';

  
  bool _oldPasswordError = false;
  bool _newPasswordError = false;
  bool _confirmPasswordError = false;
  
  
  String _oldPasswordErrorMessage = '';
  String _newPasswordErrorMessage = '';
  String _confirmPasswordErrorMessage = '';

  @override
  void initState() {
    super.initState();
    _loadUserData();
  }

  Future<void> _loadUserData() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _userId = prefs.getString('user_id') ?? '';
      _acno = prefs.getString('acno') ?? '';
    });
  }

  Future<void> _changePassword() async {
    
    setState(() {
      _oldPasswordError = false;
      _newPasswordError = false;
      _confirmPasswordError = false;
      _oldPasswordErrorMessage = '';
      _newPasswordErrorMessage = '';
      _confirmPasswordErrorMessage = '';
    });

    final oldPassword = oldPasswordController.text;
    final newPassword = newPasswordController.text;
    final confirmPassword = confirmPasswordController.text;

    bool hasError = false;

    
    if (oldPassword.isEmpty) {
      setState(() {
        _oldPasswordError = true;
        _oldPasswordErrorMessage = 'Old password is required';
      });
      hasError = true;
    }

    
    if (newPassword.isEmpty) {
      setState(() {
        _newPasswordError = true;
        _newPasswordErrorMessage = 'New password is required';
      });
      hasError = true;
    } else if (newPassword.length < 6) {
      setState(() {
        _newPasswordError = true;
        _newPasswordErrorMessage = 'Password must be at least 6 characters';
      });
      hasError = true;
    }

    
    if (confirmPassword.isEmpty) {
      setState(() {
        _confirmPasswordError = true;
        _confirmPasswordErrorMessage = 'Confirm password is required';
      });
      hasError = true;
    } else if (newPassword != confirmPassword) {
      setState(() {
        _confirmPasswordError = true;
        _confirmPasswordErrorMessage = 'Passwords do not match';
      });
      hasError = true;
    }

    if (hasError) {
      return; 
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final success = await _authService.changePassword(
        userId: _userId,
        acno: _acno,
        oldPassword: oldPasswordController.text,
        newPassword: newPasswordController.text,
        confirmPassword: confirmPasswordController.text,
      );

      if (success) {
        customSnackBar('Success', 'Password updated successfully');
        
        
        oldPasswordController.clear();
        newPasswordController.clear();
        confirmPasswordController.clear();
        
        
        Future.delayed(const Duration(seconds: 2), () {
          Get.back();
        });
      } else {
        customSnackBar('Error', _authService.errorMessage.value.isNotEmpty 
            ? _authService.errorMessage.value 
            : 'Failed to change password. Please try again.');
      }
    } catch (e) {
      customSnackBar('Error', _authService.errorMessage.value.isNotEmpty 
          ? _authService.errorMessage.value 
          : e.toString());
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Get.back(),
        ),
        title: const Text(
          'Change Password',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 24),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              _passwordField('Old Password', oldPasswordController, obscureOld, () => setState(() => obscureOld = !obscureOld)),
              const SizedBox(height: 16),
              _passwordField('New Password', newPasswordController, obscureNew, () => setState(() => obscureNew = !obscureNew)),
              const SizedBox(height: 16),
              _passwordField('Confirm Password', confirmPasswordController, obscureConfirm, () => setState(() => obscureConfirm = !obscureConfirm)),
              const SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF007AFF),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  onPressed: _isLoading ? null : _changePassword,
                  child: _isLoading
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                          ),
                        )
                      : const Text('Update Password', style: TextStyle(fontSize: 18, color: Colors.white)),
                ),
              ),
            ],
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
              bottomNavigationBar: const AppBottomBar(selectedIndex: 3),
    );
  }

  Widget _passwordField(String label, TextEditingController controller, bool obscure, VoidCallback toggle) {
    bool isError = false;
    String errorMessage = '';
    
    if (label == 'Old Password') {
      isError = _oldPasswordError;
      errorMessage = _oldPasswordErrorMessage;
    } else if (label == 'New Password') {
      isError = _newPasswordError;
      errorMessage = _newPasswordErrorMessage;
    } else if (label == 'Confirm Password') {
      isError = _confirmPasswordError;
      errorMessage = _confirmPasswordErrorMessage;
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          decoration: BoxDecoration(
            color: const Color(0xFFF7F8FA),
            borderRadius: BorderRadius.circular(10),
            border: isError ? Border.all(color: Colors.red, width: 1.5) : Border.all(color: Colors.transparent, width: 1),
          ),
          child: TextFormField(
            controller: controller,
            obscureText: obscure,
            decoration: InputDecoration(
              labelText: label,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(10),
                borderSide: BorderSide.none,
              ),
              filled: true,
              fillColor: Colors.transparent,
              contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(10),
                borderSide: BorderSide.none,
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(10),
                borderSide: BorderSide.none,
              ),
              suffixIcon: IconButton(
                icon: Icon(obscure ? Icons.visibility_off_rounded : Icons.visibility_rounded),
                onPressed: toggle,
              ),
            ),
          ),
        ),
        if (isError && errorMessage.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(left: 16, top: 4),
            child: Text(
              errorMessage,
              style: const TextStyle(color: Colors.red, fontSize: 12),
            ),
          ),
      ],
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../widgets/custom_date_selector.dart';
import '../widgets/courier_logo_widget.dart';
import '../services/auth_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'load_sheet_screen.dart';
import 'create_order.dart';
import 'order_list_screen.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../config/api_config.dart';

class CODStatement {
  final String refNo;
  final String name;
  final String date;
  final String accountNo;
  final int shipments;
  final String codAmount;
  final String courier;
  final String? status;
  final String? accountTitle;
  final String? courierId;
  final String? statementRef;

  CODStatement({
    required this.refNo,
    required this.name,
    required this.date,
    required this.accountNo,
    required this.shipments,
    required this.codAmount,
    required this.courier,
    this.status,
    this.accountTitle,
    this.courierId,
    this.statementRef,
  });

  factory CODStatement.fromJson(Map<String, dynamic> json) {
    try {
      return CODStatement(
        refNo: json['invoice_no']?.toString() ?? '',
        name: json['name']?.toString() ?? '',
        date: json['invoice_date']?.toString() ?? '',
        accountNo: json['acno']?.toString() ?? '',
        shipments: int.tryParse(json['total_shipments']?.toString() ?? '0') ?? 0,
        codAmount: json['total_amount']?.toString() ?? '',
        courier: json['courier_name']?.toString() ?? '',
        status: json['status']?.toString() ?? json['statement_status']?.toString() ?? json['invoice_status']?.toString() ?? 'Active',
        accountTitle: json['account_title']?.toString(),
        courierId: json['courier_id']?.toString(),
        statementRef: json['statement_ref']?.toString(),
      );
    } catch (e) {
      print('Error parsing CODStatement from JSON: $e');
      print('JSON data: $json');
      
      return CODStatement(
        refNo: '',
        name: '',
        date: '',
        accountNo: '',
        shipments: 0,
        codAmount: '',
        courier: '',
        status: 'Active',
        accountTitle: null,
        courierId: null,
        statementRef: null,
      );
    }
  }
}

class CODStatementScreen extends StatefulWidget {
  const CODStatementScreen({Key? key}) : super(key: key);
  @override
  State<CODStatementScreen> createState() => _CODStatementScreenState();
}

class _CODStatementScreenState extends State<CODStatementScreen> {
  List<CODStatement> statements = [];
  bool isLoading = true;
  bool isRefreshing = false;
  String? error;
  
  static Map<String, dynamic>? _lastParams;
  static List<CODStatement>? _cachedStatements;

  
  static void clearAllCODStatementCaches() {
    _lastParams = null;
    _cachedStatements = null;
  }
  DateTime _startDate = DateTime.now().subtract(const Duration(days: 3));
  DateTime _endDate = DateTime.now();
  
  String? _searchQuery;
  List<CODStatement> _filteredStatements = [];
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  final AuthService _authService = Get.find<AuthService>();
  Map<String, dynamic>? _activeFilters;

  String _formatToTwoDecimals(String value) {
    try {
      final normalized = value.replaceAll(',', '').trim();
      final parsed = double.tryParse(normalized);
      if (parsed == null) return value;
      return parsed.toStringAsFixed(2);
    } catch (_) {
      return value;
    }
  }

  @override
  void initState() {
    super.initState();
    _restoreOrFetchStatements();
    _searchController.addListener(_onSearchChanged);
  }

  void _restoreOrFetchStatements({bool force = false}) {
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
      'startDate': _startDate.toIso8601String().split('T')[0],
      'endDate': _endDate.toIso8601String().split('T')[0],
    };
    if (!force && _lastParams != null && _cachedStatements != null && _lastParams.toString() == params.toString()) {
      setState(() {
        statements = List<CODStatement>.from(_cachedStatements!);
        isLoading = false;
        error = null;
        _applySearch();
      });
      return;
    }
    _loadUserDataAndFetchStatements();
  }

  Future<void> _manualRefresh() async {
    setState(() => isRefreshing = true);
    await _loadUserDataAndFetchStatements();
    setState(() => isRefreshing = false);
    
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
      'startDate': _startDate.toIso8601String().split('T')[0],
      'endDate': _endDate.toIso8601String().split('T')[0],
    };
    _lastParams = params;
    _cachedStatements = List<CODStatement>.from(statements);
  }

  Future<void> _loadUserDataAndFetchStatements() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchStatements();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text;
      _applySearch();
    });
  }

  Future<void> fetchStatements({bool reset = false}) async {
    if (reset) {
      setState(() {
        statements = [];
      });
    }
    setState(() {
      isLoading = true;
      error = null;
    });
    try {
      final acno = _authService.getCurrentAcno();
      final requestBody = {
        'acno': acno,
        'start_date': _startDate.toIso8601String().split('T')[0],
        'end_date': _endDate.toIso8601String().split('T')[0],
      };
      if (_activeFilters != null) {
        if (_activeFilters!['courier_id'] != null && _activeFilters!['courier_id'].toString().isNotEmpty) {
          requestBody['courier_id'] = _activeFilters!['courier_id'];
        }
        if (_activeFilters!['customer_courier_id'] != null && _activeFilters!['customer_courier_id'].toString().isNotEmpty) {
          requestBody['customer_courier_id'] = _activeFilters!['customer_courier_id'];
        }
      }
      final response = await GetConnect().post(
        ApiConfig.getEndpointUrl(ApiConfig.statementEndpoint),
        
        requestBody,
      );
      List<CODStatement> newStatements = [];
      if (response.body['status'] == 1 && response.body['payload'] is List) {
        try {
          newStatements = (response.body['payload'] as List)
              .map((e) => CODStatement.fromJson(e))
              .toList();
        } catch (e) {
          print('Error parsing COD statements from response: $e');
          print('Response payload: ${response.body['payload']}');
          
          newStatements = [];
        }
      }
      setState(() {
        statements = newStatements;
        _cachedStatements = List<CODStatement>.from(statements); 
        _lastParams = {
          'acno': acno,
          'startDate': _startDate.toIso8601String().split('T')[0],
          'endDate': _endDate.toIso8601String().split('T')[0],
        };
        _applySearch();
      });
    } catch (e) {
      setState(() {
        error = e.toString();
      });
    } finally {
      setState(() => isLoading = false);
    }
  }

  void _applySearch() {
    List<CODStatement> tempStatements = statements;
    
    if (_searchQuery != null && _searchQuery!.isNotEmpty) {
      tempStatements = tempStatements.where((s) {
        return s.refNo.toLowerCase().contains(_searchQuery!.toLowerCase()) ||
               (s.statementRef ?? '').toLowerCase().contains(_searchQuery!.toLowerCase()) ||
               s.date.toLowerCase().contains(_searchQuery!.toLowerCase()) ||
               s.accountNo.toLowerCase().contains(_searchQuery!.toLowerCase()) ||
               s.codAmount.toLowerCase().contains(_searchQuery!.toLowerCase()) ||
               s.courier.toLowerCase().contains(_searchQuery!.toLowerCase());
      }).toList();
    }
    
    if (_activeFilters != null) {
      tempStatements = tempStatements.where((s) {
        
        if (_activeFilters!['order'] != null) {
          final status = s.codAmount.toLowerCase(); 
          if (_activeFilters!['order'] == 'Booked') {
            if (status != 'booked') return false;
          } else if (_activeFilters!['order'] == 'Unbooked') {
            if (status == 'booked') return false;
          }
        }
        
        if (_activeFilters!['status'] != null) {
          final statusList = _activeFilters!['status'];
          if (statusList is List && statusList.isNotEmpty) {
            final status = s.codAmount; 
            if (!statusList.contains(status)) {
              return false;
            }
          }
        }
        
        if (_activeFilters!['platform'] != null) {
          final platformList = _activeFilters!['platform'];
          if (platformList is List && platformList.isNotEmpty) {
            final platform = s.accountNo;
            if (!platformList.contains(platform)) {
              return false;
            }
          }
        }
        
        if (_activeFilters!['courier'] != null) {
          final courierList = _activeFilters!['courier'];
          if (courierList is List && courierList.isNotEmpty) {
            final courier = s.courier;
            if (!courierList.contains(courier)) {
              return false;
            }
          }
        }
        
        if (_activeFilters!['city'] != null) {
          final cityList = _activeFilters!['city'];
          if (cityList is List && cityList.isNotEmpty) {
            
            
            
            
            
          }
        }
        return true;
      }).toList();
    }
    _filteredStatements = tempStatements;
  }

  String _getDateRangeText() {
    final now = DateTime.now();
    final difference = now.difference(_startDate).inDays;
    
    if (difference == 0) {
      return 'Today';
    } else if (difference == 1) {
      return 'Last 1 day';
    } else if (difference <= 7) {
      return 'Last $difference days';
    } else if (difference <= 30) {
      final weeks = (difference / 7).round();
      return 'Last $weeks week${weeks > 1 ? 's' : ''}';
    } else if (difference <= 365) {
      final months = (difference / 30).round();
      return 'Last $months month${months > 1 ? 's' : ''}';
    } else {
      final years = (difference / 365).round();
      return 'Last $years year${years > 1 ? 's' : ''}';
    }
  }

  String _getDateRangeFormatted() {
    final start = _startDate;
    final end = _endDate;
    String format(DateTime d) =>
        '${d.day.toString().padLeft(2, '0')}-${d.month.toString().padLeft(2, '0')}-${d.year}';
    return '${format(start)} to ${format(end)}';
  }

  String _formatDateOnly(String dateString) {
    try {
      // Parse the date string and format it to show only date without time
      final date = DateTime.parse(dateString);
      return '${date.day.toString().padLeft(2, '0')}-${date.month.toString().padLeft(2, '0')}-${date.year}';
    } catch (e) {
      // If parsing fails, return the original string
      return dateString;
    }
  }

  String _getCODFilterSummary() {
    if (_activeFilters == null) return '';
    final summary = <String>[];
    if (_activeFilters!['order'] != null) summary.add('Order: ${_activeFilters!['order']}');
    
    final statusList = _activeFilters!['status'];
    if (statusList != null && statusList is List && statusList.isNotEmpty) {
      summary.add('Status: ${statusList.join(", ")}');
    }
    
    final platformList = _activeFilters!['platform'];
    if (platformList != null && platformList is List && platformList.isNotEmpty) {
      summary.add('Platform: ${platformList.join(", ")}');
    }
    
    final courierList = _activeFilters!['courier'];
    if (courierList != null && courierList is List && courierList.isNotEmpty) {
      summary.add('Courier: ${courierList.join(", ")}');
    }
    
    final cityList = _activeFilters!['city'];
    if (cityList != null && cityList is List && cityList.isNotEmpty) {
      summary.add('City: ${cityList.join(", ")}');
    }
    
    return summary.join(' | ');
  }

  @override
  Widget build(BuildContext context) {
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).maybePop(),
        ),
        title: const Text(
          'COD Statements',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
        actions: [
          if (_searchQuery != null && _searchQuery!.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.clear_rounded, color: Colors.grey),
              onPressed: () {
                setState(() {
                  _searchController.clear();
                  _searchQuery = null;
                  _applySearch();
                });
              },
            ),
          IconButton(
            icon: SvgPicture.asset(
    'assets/Filter.svg',
    width: 24,
    height: 24,
    color: Colors.black, 
  ),
            onPressed: () async {
              final result = await Navigator.push<Map<String, String?>>(
  context,
  MaterialPageRoute(
    fullscreenDialog: true,
                  builder: (context) => LoadSheetFilterScreen(
                    initialCourier: _activeFilters == null ? null : Map<String, String?>.from(_activeFilters!),
                    onApply: (courier) {
                      setState(() {
                        _activeFilters = courier;
                      });
                      fetchStatements(reset: true);
                    },
                    onReset: () {
                      setState(() {
                        _activeFilters = null;
                      });
                      fetchStatements(reset: true);
                    },
                  ),
  ),
);
              if (result != null) {
                setState(() {
                  _activeFilters = result;
                });
                await fetchStatements(reset: true);
              }
            },
          ),
          IconButton(
            icon: SvgPicture.asset(
    'assets/Calender.svg',
    width: 24,
    height: 24,
    
  ),
            onPressed: () async {
              final picked = await showModalBottomSheet<DateTimeRange>(
                context: context,
                isScrollControlled: true,
                backgroundColor: Colors.transparent,
                builder: (context) => Container(
                  width: MediaQuery.of(context).size.width,
                  height: MediaQuery.of(context).size.height * 0.6,
                  decoration: const BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                  ),
                  child: CustomDateSelector(
                    initialStartDate: _startDate,
                    initialEndDate: _endDate,
                  ),
                ),
              );
              if (picked != null) {
                setState(() {
                  _startDate = picked.start;
                  _endDate = picked.end;
                });
                await fetchStatements(reset: true);
              }
            },
          ),
        ],
      ),
      body: isLoading || isRefreshing
          ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
          : error != null
              ? Center(child: Text('Error: $error'))
              : GestureDetector(
                  behavior: HitTestBehavior.translucent,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        
                        Padding(
                          padding: const EdgeInsets.only(bottom: 4, top: 8),
                          child: Text(
                            _getDateRangeFormatted(),
                            style: GoogleFonts.poppins(
                              fontSize: 13,
                              fontWeight: FontWeight.w400,
                              color: Colors.grey,
                            ),
                          ),
                        ),
                        
                        Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4),
                          child: TextField(
                            controller: _searchController,
                            focusNode: _searchFocusNode,
                            decoration: InputDecoration(
                              hintText: 'Search',
                              suffixIcon: Icon(Icons.search_rounded),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              filled: true,
                              fillColor: const Color(0xFFF5F5F7),
                              contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                              focusedBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                              ),
                              enabledBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                            ),
                          ),
                        ),
                        
                        
                        if (_activeFilters != null && (_activeFilters!['courier_name']?.toString().isNotEmpty ?? false)) ...[
                          const SizedBox(height: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                            decoration: BoxDecoration(
                              color: Colors.blue.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: Colors.blue.withOpacity(0.3)),
                            ),
                            child: Row(
                              children: [
                                Icon(Icons.filter_list_rounded, size: 16, color: Colors.blue[700]),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: Text(
                                    'Courier: ${_activeFilters!['courier_name']} (${_filteredStatements.length})',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.blue[700],
                                      fontWeight: FontWeight.w400,
                                    ),
                                  ),
                                ),
                                GestureDetector(
                                  onTap: () {
                                    setState(() {
                                      _activeFilters = null;
                                    });
                                    fetchStatements(reset: true);
                                    final rootContext = Navigator.of(context, rootNavigator: true).context;
                                    ScaffoldMessenger.of(rootContext).showSnackBar(
                                      const SnackBar(
                                        content: Text('Filters cleared'),
                                        backgroundColor: Colors.green,
                                        behavior: SnackBarBehavior.floating,
                                        margin: EdgeInsets.all(16),
                                        duration: Duration(seconds: 2),
                                      ),
                                    );
                                  },
                                  child: Icon(Icons.clear_rounded, size: 16, color: Colors.blue[700]),
                                ),
                              ],
                            ),
                          ),
                        ],
                        const SizedBox(height: 16),
                        Expanded(
                          child: (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredStatements : statements).isEmpty
                              ? const Center(child: Text('No COD statements found.'))
                              : RefreshIndicator(
                                  onRefresh: _manualRefresh,
                                  child: ListView.separated(
                                    itemCount: (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredStatements : statements).length,
                                  separatorBuilder: (_, __) => const SizedBox(height: 12),
                                  padding: const EdgeInsets.only(bottom: 80), 
                                  itemBuilder: (context, i) {
                                    final list = (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredStatements : statements);
                                    final s = list[i];
                                    return Container(
                                      width: double.infinity,
                                      padding: const EdgeInsets.all(16),
                                      decoration: BoxDecoration(
                                        color: const Color(0xFFF5F5F7),
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                          
                                          Row(
                                            crossAxisAlignment: CrossAxisAlignment.start,
                                            children: [
                                              Expanded(
                                                child: Padding(
                                                  padding: const EdgeInsets.only(top: 8),
                                                  child: Text(
                                                    s.name.isNotEmpty ? s.name : 'Statement-${s.refNo}',
                                                    style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                                                  ),
                                                ),
                                              ),
                                              Column(
                                                children: [
                                                  SizedBox(height: 6),
                                                  Container(
                                                    constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                    decoration: BoxDecoration(
                                                      color: () {
                                                        final status = s.status?.toLowerCase() ?? '';
                                                        if (status == 'paid' || status == 'active') return Color(0xFF43A047).withOpacity(0.1); 
                                                        if (status == 'unpaid' || status == 'inactive') return Colors.red.withOpacity(0.1);
                                                        return Colors.grey.withOpacity(0.1);
                                                      }(),
                                                      borderRadius: BorderRadius.circular(16),
                                                    ),
                                                    alignment: Alignment.center,
                                                    child: Text(
                                                      () {
                                                        final status = s.status?.toLowerCase() ?? '';
                                                        if (status == 'active') return 'Paid';
                                                        if (status == 'inactive') return 'Unpaid';
                                                        if (status == 'paid') return 'Paid';
                                                        if (status == 'unpaid') return 'Unpaid';
                                                        return s.status?.isNotEmpty == true ? s.status![0].toUpperCase() + s.status!.substring(1).toLowerCase() : 'N/A';
                                                      }(),
                                                      style: GoogleFonts.inter(
                                                        color: () {
                                                          final status = s.status?.toLowerCase() ?? '';
                                                          if (status == 'paid' || status == 'active') return Color(0xFF43A047); 
                                                          if (status == 'unpaid' || status == 'inactive') return Colors.red;
                                                          return Colors.grey;
                                                        }(),
                                                        fontWeight: FontWeight.w500, 
                                                        fontSize: 15
                                                      ),
                                                      overflow: TextOverflow.ellipsis,
                                                    ),
                                                  ),
                                                ],
                                              ),
                                            ],
                                          ),
                                          const SizedBox(height: 4),
                                          if ((s.accountTitle ?? '').toLowerCase().trim() == 'managed')
                                            _CODRow(label: 'Statement Ref', value: s.statementRef ?? '' )
                                          else
                                            _CODRow(label: 'Invoice No', value: s.refNo),
                                          _CODRow(label: 'Date', value: _formatDateOnly(s.date)),
                                          _CODRow(label: 'Account No', value: s.accountNo),
                                          _CODRow(label: 'Shipments', value: s.shipments.toString()),
                                          _CODRow(label: 'COD Amount', value: _formatToTwoDecimals(s.codAmount)),
                                          Row(
                                            crossAxisAlignment: CrossAxisAlignment.center,
                                            children: [
                                              SizedBox(
                                                width: s.courier.isNotEmpty && s.courier.length > 10
                                                         ? 113
                                                         : 98,
                                                child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15)),
                                              ),
                                                const SizedBox(width: 26), 
                                                s.courier.isNotEmpty
                                                  ? CourierLogoWidget(
                                                      pngUrl: s.courier,
                                                      accountTitle: s.accountTitle, 
                                                     courierId: s.courierId,
                                                      width: 78,
                                                      height: 36,
                                                      fit: BoxFit.contain,
                                                    )
                                                  : const SizedBox(height: 24),
                                            ],
                                          ),
                                        ],
                                      ),
                                    );
                                  },
                                  ),
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              bottomNavigationBar: AppBottomBar(
                selectedIndex: 2,
                onOrderListTap: () => Get.to(() => OrderListScreen(from: 'cod_statement')),
              ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: MediaQuery.of(context).viewInsets.bottom == 0
          ? FloatingActionButton(
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const CreateOrderScreen(),
                  ),
                );
              },
              backgroundColor: const Color(0xFF0A253B),
              elevation: 4,
              shape: const CircleBorder(),
             child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
            )
          : null,
      ),
    );
  }
}

class _CODRow extends StatelessWidget {
  final String label;
  final String value;
  const _CODRow({required this.label, required this.value});
  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SizedBox(
            width: 100,
            child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15)),
          ),
          const SizedBox(width: 36), 
          Expanded(child: Text(value, style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 15))),
        ],
      ),
    );
  }
}

Widget _courierLogoOrText(String courierName) {
  if (courierName.isEmpty) {
    return const SizedBox(height: 32, width: 64);
  }
  final logoUrl = '${ApiConfig.assetBaseUrl}${Uri.encodeComponent(courierName.trim())}.svg';
  return SizedBox(
    height: 32,
    width: 64,
    child: Image.network(
      logoUrl,
      fit: BoxFit.contain,
      errorBuilder: (context, error, stackTrace) => Text(courierName, style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 15)),
    ),
  );
} 

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../models/courier_account.dart';
import '../services/courier_service.dart';
import '../services/auth_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'add_courier_company_screen.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../utils/custom_snackbar.dart';
import '../widgets/courier_logo_widget.dart';
import 'dart:convert';
import 'create_order.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;
import 'package:flutter_svg/flutter_svg.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';

class CourierCompaniesScreen extends StatefulWidget {
  CourierCompaniesScreen({Key? key}) : super(key: key);

  
  static void clearAllCourierCompaniesCaches() {
    _CourierCompaniesScreenState.clearAllCourierCompaniesCaches();
  }

  @override
  State<CourierCompaniesScreen> createState() => _CourierCompaniesScreenState();
}

class _CourierCompaniesScreenState extends State<CourierCompaniesScreen> {
  final CourierService _courierService = CourierService();
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  final AuthService _authService = Get.find<AuthService>();
  List<CourierAccount> _allCompanies = [];
  List<CourierAccount> _filteredCompanies = [];
  bool _loading = true;
  String? _error;

  
  static Map<String, dynamic>? _lastParams;
  static List<CourierAccount>? _cachedCompanies;
  static bool _needsRefresh = false;

  
  static void clearAllCourierCompaniesCaches() {
    _lastParams = null;
    _cachedCompanies = null;
    _needsRefresh = true;
  }

  @override
  void initState() {
    super.initState();
    _restoreOrFetchCompanies();
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    
    if (_lastParams == null || _cachedCompanies == null || _needsRefresh) {
      _needsRefresh = false; 
      _restoreOrFetchCompanies();
    }
  }





  
  void _restoreOrFetchCompanies() async {
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
    };
    if (_lastParams != null && _cachedCompanies != null && _lastParams.toString() == params.toString()) {
      setState(() {
        _allCompanies = List<CourierAccount>.from(_cachedCompanies!);
        _filteredCompanies = List<CourierAccount>.from(_cachedCompanies!);
        _loading = false;
      });
      
      // Clear search when restoring from cache
      _clearSearch();
      return;
    }
    await _loadUserDataAndFetchCompanies();
  }

  Future<void> _loadUserDataAndFetchCompanies() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await _fetchCompanies();
  }

  Future<void> _fetchCompanies() async {
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          _error = 'User not logged in';
          _loading = false;
        });
        return;
      }

      final companies = await _courierService.getCourierAccounts(acno);
      
      _lastParams = {'acno': acno};
      _cachedCompanies = List<CourierAccount>.from(companies);
      setState(() {
        _allCompanies = companies;
        _filteredCompanies = companies;
        _loading = false;
      });
      
      // Clear search when companies are refreshed
      _clearSearch();
    } catch (e) {
      setState(() {
        _error = e.toString();
        _loading = false;
      });
    }
  }

  
  Future<void> _manualRefresh() async {
    await _fetchCompanies();
    // Search is already cleared in _fetchCompanies
  }

  void _onSearchChanged() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredCompanies = _allCompanies.where((company) {
        return company.accountTitle.toLowerCase().contains(query) ||
               company.courierAcno.toLowerCase().contains(query) ||
               company.courierName.toLowerCase().contains(query);
      }).toList();
    });
  }

  void _clearSearch() {
    _searchController.clear();
    setState(() {
      _filteredCompanies = List<CourierAccount>.from(_allCompanies);
    });
  }

  @override
  Widget build(BuildContext context) {
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        resizeToAvoidBottomInset: false,
        appBar: AppBar(
          backgroundColor: Colors.white,
          elevation: 0,
          foregroundColor: Colors.white,
          surfaceTintColor: Colors.white,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black),
            onPressed: () => Navigator.of(context).maybePop(),
          ),
          title: const Text(
            'Courier Companies',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
        ),
        body: GestureDetector(
          behavior: HitTestBehavior.translucent,
          onTap: () {
            FocusScope.of(context).unfocus();
          },
          child: LayoutBuilder(
            builder: (context, constraints) => Stack(
              children: [
                _loading
                    ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
                    : _error != null
                        ? Center(child: Text('Error: $_error'))
                        : Column(
                            children: [
                              Padding(
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                  children: [
                                    Text('Total Courier Companies: ${_filteredCompanies.length.toString().padLeft(2, '0')}',
                                        style: const TextStyle(fontWeight: FontWeight.w500)),
                                    GestureDetector(
                                      onTap: () async {
                                        final result = await Get.toNamed('/add-courier');
                                        if (result == true) {
                                          await _fetchCompanies();
                                          setState(() {});
                                        }
                                      },
                                      child: const Text(
                                        'Add Courier',
                                        style: TextStyle(
                                          color: Color(0xFF007AFF),
                                          fontWeight: FontWeight.w600,
                                          decoration: TextDecoration.none,
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              Padding(
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                                child: TextField(
                                  controller: _searchController,
                                  focusNode: _searchFocusNode,
                                  decoration: InputDecoration(
                                    hintText: 'Search',
                                    suffixIcon: Icon(Icons.search_rounded),
                                    border: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                    ),
                                    filled: true,
                                    fillColor: const Color(0xFFF5F5F7),
                                    contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                                    focusedBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                                    ),
                                    enabledBorder: OutlineInputBorder(
                                      borderRadius: BorderRadius.circular(12),
                                      borderSide: BorderSide.none,
                                    ),
                                  ),
                                ),
                              ),
                              Expanded(
                                child: _filteredCompanies.isEmpty
                                    ? const Center(child: Text('No courier companies found.'))
                                    : RefreshIndicator(
                                        onRefresh: _manualRefresh,
                                        child: AnimationLimiter(
                                          child: ListView.builder(
                                            padding: const EdgeInsets.only(left: 12, right: 12, top: 4, bottom: 90),
                                            itemCount: _filteredCompanies.length,
                                            itemBuilder: (context, index) {
                                              final company = _filteredCompanies[index];
                                              return AnimationConfiguration.staggeredList(
                                                position: index,
                                                duration: const Duration(milliseconds: 450),
                                                child: SlideAnimation(
                                                  verticalOffset: 50.0,
                                                  child: FadeInAnimation(
                                                    child: Column(
                                                      children: [
                                                        Container(
                                                          decoration: BoxDecoration(
                                                            color: const Color(0xFFF5F5F7),
                                                            borderRadius: BorderRadius.circular(12),
                                                          ),
                                                          margin: const EdgeInsets.only(top: 4, bottom: 4),
                                                          padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                                                          child: Column(
                                                            crossAxisAlignment: CrossAxisAlignment.start,
                                                            children: [
                                                              
                                                              Row(
                                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                                children: [
                                                                  Expanded(
                                                                    child: Padding(
                                                                      padding: const EdgeInsets.only(top: 8),
                                                                      child: Text(
                                                                        'S.No: ${(index + 1).toString().padLeft(2, '0')}',
                                                                        style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                                                                      ),
                                                                    ),
                                                                  ),
                                                                  Column(
                                                                    children: [
                                                                      SizedBox(height: 6),
                                                                      Container(
                                                                        constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                                                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                                        decoration: BoxDecoration(
                                                                          color: company.status.toLowerCase() == 'active'
                                                                              ? const Color(0xFF28C76F).withOpacity(0.1)
                                                                              : const Color(0xFFFF0000).withOpacity(0.1),
                                                                          borderRadius: BorderRadius.circular(16),
                                                                        ),
                                                                        alignment: Alignment.center,
                                                                        child: Text(
                                                                          company.status.toLowerCase() == 'active' ? 'Active' : 'Inactive',
                                                                          style: GoogleFonts.inter(
                                                                            color: company.status.toLowerCase() == 'active'
                                                                                ? const Color(0xFF28C76F)
                                                                                : const Color(0xFFFF0000),
                                                                            fontWeight: FontWeight.w500,
                                                                            fontSize: 15
                                                                          ),
                                                                          overflow: TextOverflow.ellipsis,
                                                                        ),
                                                                      ),
                                                                    ],
                                                                  ),
                                                                ],
                                                              ),
                                                              const SizedBox(height: 4),
                                                              Row(
                                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                                children: [
                                                                  Expanded(
                                                                    child: Row(
                                                                      crossAxisAlignment: CrossAxisAlignment.center,
                                                                      children: [
                                                                        SizedBox(
                                                                          width: 100,
                                                                          child: Text('Account Title', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                                        ),
                                                                        const SizedBox(width: 36),
                                                                        Expanded(
                                                                          child: Text(company.accountTitle, style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                                        ),
                                                                      ],
                                                                    ),
                                                                  ),
                                                                ],
                                                              ),
                                                              const SizedBox(height: 4),
                                                              Row(
                                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                                children: [
                                                                  Expanded(
                                                                    child: Row(
                                                                      crossAxisAlignment: CrossAxisAlignment.center,
                                                                      children: [
                                                                        SizedBox(
                                                                          width: 100,
                                                                          child: Text('Account No', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                                        ),
                                                                        const SizedBox(width: 36),
                                                                        Expanded(
                                                                          child: Text(company.courierAcno, style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                                        ),
                                                                      ],
                                                                    ),
                                                                  ),
                                                                ],
                                                              ),
                                                              const SizedBox(height: 4),
                                                              Row(
                                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                                children: [
                                                                  Expanded(
                                                                    child: Row(
                                                                      crossAxisAlignment: CrossAxisAlignment.center,
                                                                      children: [
                                                                        SizedBox(
                                                                          width: 100,
                                                                          child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400, color: Colors.black)),
                                                                        ),
                                                                        SizedBox(
                                                                          width: (() {
                                                                            final compactNames = {'blue ex', 'tcs', 'leopards', 'trax', 'postex', 'tqs', 'm&p', 'daewoo express', 'fly courier', 'barqraftar', 'postex partner','stallion'};
                                                                            final name = company.courierName?.trim().toLowerCase() ?? '';
                                                                            if (name == 'tqs' || name == 'm&p') {
                                                                              return 17.0;
                                                                            }
                                                                            if (name == 'trax' || name == 'daewoo express') {
                                                                              return 29.0;
                                                                            }
                                                                            if (name =='postex partner') {
                                                                              return 27.0;
                                                                            }
                                                                            return compactNames.contains(name) ? 24.0 : 34.0;
                                                                          })(),
                                                                        ),
                                                                        company.courierName != null && company.courierName.toString().isNotEmpty
                                                                            ? CourierLogoWidget(
                                                                                pngUrl: company.courierName.toString(),
                                                                                courierId: company.courierId,
                                                                                accountTitle: company.accountTitle,
                                                                                width: 78,
                                                                                height: 36,
                                                                                fit: BoxFit.contain,
                                                                              )
                                                                            : const SizedBox(height: 24),
                                                                      ],
                                                                    ),
                                                                  ),
                                                                ],
                                                              ),
                                                              const SizedBox(height: 4),
                                                              Row(
                                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                                children: [
                                                                  Expanded(
                                                                    child: Row(
                                                                      crossAxisAlignment: CrossAxisAlignment.center,
                                                                      children: [
                                                                        SizedBox(
                                                                          width: 100,
                                                                          child: Text('Default', style: GoogleFonts.inter(fontWeight: FontWeight.w400, color: Colors.black)),
                                                                        ),
                                                                        const SizedBox(width: 36),
                                                                        Container(
                                                                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                                          decoration: BoxDecoration(
                                                                            color: company.isDefault == '1'
                                                                                ? const Color(0xFF28C76F).withOpacity(0.1)
                                                                                : const Color(0xFFFF0000).withOpacity(0.1),
                                                                            borderRadius: BorderRadius.circular(16),
                                                                          ),
                                                                          child: Text(
                                                                            company.isDefault == '1' ? 'Yes' : 'No',
                                                                            style: GoogleFonts.inter(
                                                                              color: company.isDefault == '1'
                                                                                  ? const Color(0xFF28C76F)
                                                                                  : const Color(0xFFFF0000),
                                                                              fontWeight: FontWeight.w500,
                                                                              fontSize: 15
                                                                            ),
                                                                            overflow: TextOverflow.ellipsis,
                                                                          ),
                                                                        ),
                                                                      ],
                                                                    ),
                                                                  ),
                                                                ],
                                                              ),
                                                              const SizedBox(height: 20), 
                                                              if (company.accountTitle.toLowerCase().trim() != 'managed') ...[
                                                                Row(
                                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                                  children: [
                                                                    Expanded(
                                                                      child: Row(
                                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                                        children: [
                                                                          SizedBox(
                                                                            width: 100,
                                                                            child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                                          ),
                                                                          const SizedBox(width: 36),
                                                                          Expanded(
                                                                            child: Row(
                                                                              children: [
                                                                                                                                                               GestureDetector(
                                                                                                                                                                     onTap: () async {
                                                                                                                                                                         final result = await Get.to(() => AddCourierCompanyScreen(courierAccount: company, isEdit: true));
                                                                                     if (result == true) {
                                                                                       await _fetchCompanies();
                                                                                       setState(() {});
                                                                                     }
                                                                                  },
                                                                                  child: Row(
                                                                                    children: [
                                                                                      SvgPicture.asset(
                                                                                        'assets/Edit.svg',
                                                                                        width: 20,
                                                                                        height: 20,
                                                                                        color: const Color(0xFF007AFF),
                                                                                      ),
                                                                                      const SizedBox(width: 4),
                                                                                      Text('Edit', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                                                    ],
                                                                                  ),
                                                                                ),
                                                                                const SizedBox(width: 24),
                                                                                GestureDetector(
                                                                                  onTap: () {
                                                                                    _showDeleteConfirmation(context, () {
                                                                                      _deleteCourier(context, company);
                                                                                    });
                                                                                  },
                                                                                  child: Row(
                                                                                    children: [
                                                                                      SvgPicture.asset(
                                                                                        'assets/Delete.svg',
                                                                                        width: 18,
                                                                                        height: 18,
                                                                                        color: const Color(0xFF007AFF),
                                                                                      ),
                                                                                      const SizedBox(width: 4),
                                                                                      Text('Delete', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                                                    ],
                                                                                  ),
                                                                                ),
                                                                              ],
                                                                            ),
                                                                          ),
                                                                        ],
                                                                      ),
                                                                    ),
                                                                  ],
                                                                ),
                                                              ],
                                                              if (company.accountTitle.toLowerCase().trim() == 'managed')
                                                                const SizedBox(height: 0)
                                                              else ...[
                                                                const SizedBox(height: 8),
                                                                GestureDetector(
                                                                  onTap: () {
                                                                    _showCourierDetailsBottomSheet(context, company);
                                                                  },
                                                                  child: Text(
                                                                    'View Details',
                                                                    style: GoogleFonts.inter(
                                                                      color: const Color(0xFF007AFF),
                                                                      fontWeight: FontWeight.w500,
                                                                      fontSize: 14,
                                                                      decoration: TextDecoration.none,
                                                                    ),
                                                                  ),
                                                                ),
                                                              ],
                                                            ],
                                                          ),
                                                        ),
                                                        SizedBox(
                                                          height: company.accountTitle.toLowerCase().trim() == 'managed' ? 2 : 8,
                                                        ),
                                                      ],
                                                    ),
                                                  ),
                                                ),
                                              );
                                            },
                                          ),
                                        ),
                                      ),
                              ),
                            ],
                          ),
              ],
            ),
          ),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            Get.to(() => CreateOrderScreen());
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
          child: SvgPicture.asset(
            'assets/Create Order.svg',
            width: 28,
            height: 28,
            color: Colors.white,
          ),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        bottomNavigationBar: AppBottomBar(
          selectedIndex: 3,
          onOrderListTap: () => Get.to(() => OrderListScreen(from: 'courier_companies')),
          onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'courier_companies')),
        ),
      ),
    );
  }

  Widget _infoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SizedBox(
            width: 100,
            child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w400), textAlign: TextAlign.left),
          ),
          const SizedBox(width: 36),
          Expanded(
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text(value, style: GoogleFonts.inter(fontWeight: FontWeight.w300), textAlign: TextAlign.left),
            ),
          ),
        ],
      ),
    );
  }

  Widget _navBarItem(IconData icon, String label, String route) {
    return InkWell(
      onTap: () {
        Get.offAllNamed(route);
      },
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 28, color: const Color(0xFF0A2A3A)),
          const SizedBox(height: 2),
          Text(label, style: const TextStyle(fontSize: 12, color: Color(0xFF0A2A3A))),
        ],
      ),
    );
  }

  void _showDeleteConfirmation(BuildContext context, VoidCallback onConfirm) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFE6F0FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(32),
                  child: SvgPicture.asset(
                    'assets/Delete.svg',
                    width: 48,
                    height: 48,
                    color: const Color(0xFF007AFF),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
                ),
                const SizedBox(height: 8),
                const Text(
                  'You want to delete this courier company',
                  style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 28),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF2F2F7),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 10),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.black)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          Navigator.of(context).pop();
                          onConfirm();
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 10),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void _deleteCourier(BuildContext context, CourierAccount company) async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        customSnackBar('Error', 'User not logged in');
        return;
      }

      final success = await _courierService.deleteCourier(company.id.toString(), acno);
      if (success) {
        customSnackBar('Success', 'Courier company deleted successfully');
        await _fetchCompanies();
      } else {
        customSnackBar('Error', 'Failed to delete courier company');
      }
    } catch (e) {
      customSnackBar('Error', 'Failed to delete courier company: ${e.toString()}');
    }
  }

  void _showCourierDetailsBottomSheet(BuildContext context, CourierAccount company) async {
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return const Center(
          child: CircularProgressIndicator(color: Color(0xFF007AFF)),
        );
      },
    );

    try {
      
      Navigator.of(context).pop();

      
      final courierDetails = {
        'id': company.id,
        'account_title': company.accountTitle,
        'account_no': company.courierAcno,
        'account_user': company.courierUser,
        'account_password': company.courierPassword,
        'apikey': company.courierApikey,
        'status': company.status,
        'default': company.isDefault,
        'courier_name': company.courierName,
        'courier_id': company.courierId,
        'acno': company.acno,
        'created_at': 'N/A',
        'updated_at': 'N/A',
      };

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (context) {
          return Container(
            width: double.infinity,
            padding: EdgeInsets.only(
              left: 0,
              right: 0,
              bottom: MediaQuery.of(context).viewInsets.bottom,
            ),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            child: AnimationLimiter(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 500),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Row(
                              children: [
                                Text(
                                  'Courier Details',
                                  style: TextStyle(
                                    fontWeight: FontWeight.w600,
                                    fontSize: 18,
                                    fontFamily: 'SF Pro Display',
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Container(
                                  constraints: const BoxConstraints(minWidth: 70, maxWidth: 100),
                                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                  decoration: BoxDecoration(
                                    color: company.status.toLowerCase() == 'active'
                                        ? const Color(0xFF28C76F).withOpacity(0.1)
                                        : const Color(0xFFFF0000).withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  alignment: Alignment.center,
                                  child: Text(
                                    company.status.toLowerCase() == 'active' ? 'Active' : 'Inactive',
                                    style: GoogleFonts.inter(
                                      color: company.status.toLowerCase() == 'active'
                                          ? const Color(0xFF28C76F)
                                          : const Color(0xFFFF0000),
                                      fontWeight: FontWeight.w500,
                                      fontSize: 15
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                            IconButton(
                              icon: const Icon(Icons.close_rounded),
                              onPressed: () => Navigator.of(context).pop(),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        _courierDetailRow('Account Title', courierDetails['account_title'] ?? ''),
                        SizedBox(height: 10),
                        // Only show account details if account is not managed
                        if (courierDetails['account_title']?.toString().toLowerCase().trim() != 'managed') ...[
                          _courierDetailRow('Account No', courierDetails['account_no'] ?? ''),
                          SizedBox(height: 10),
                          _courierDetailRow('Account User', courierDetails['account_user'] ?? ''),
                          SizedBox(height: 10),
                          _courierDetailRow('Account Password', courierDetails['account_password'] ?? ''),
                          SizedBox(height: 10),
                          _courierDetailRow('API Key', courierDetails['apikey'] ?? ''),
                          SizedBox(height: 10),
                        ],
                        _courierDetailRow('Default', courierDetails['default'] == '1' ? 'Y' : 'N'),
                        SizedBox(height: 10),
                        _courierDetailRow('Courier Name', courierDetails['courier_name'] ?? ''),
                        SizedBox(height: 10),
                        _courierDetailRow('Account Number', courierDetails['acno'] ?? ''),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      );
    } catch (e) {
      
      Navigator.of(context).pop();
      customSnackBar('Error', 'Failed to load courier details: ${e.toString()}');
    }
  }

  Widget _courierDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(
            label,
            style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14),
          ),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../services/courier_service.dart';
import '../services/cities_service.dart';
import '../services/statement_service.dart';
import '../services/auth_service.dart';
import 'package:dio/dio.dart';
import 'package:multi_select_flutter/multi_select_flutter.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../config/api_config.dart';

class CourierInsightsFilterScreen extends StatefulWidget {
  final Function(Map<String, dynamic> filters) onApply;
  final VoidCallback onReset;
  final Map<String, dynamic>? initialFilters;
  const CourierInsightsFilterScreen({Key? key, required this.onApply, required this.onReset, this.initialFilters}) : super(key: key);

  @override
  State<CourierInsightsFilterScreen> createState() => _CourierInsightsFilterScreenState();
}

class _CourierInsightsFilterScreenState extends State<CourierInsightsFilterScreen> {
  List<String> selectedStatuses = [];
  List<String> selectedCouriers = [];
  List<String> selectedCities = [];
  String? selectedPaymentMethod;
  String? selectedPaymentStatus;
  
  // Keep id-name mapping for cities so we can pass IDs to API
  List<Map<String, String>> _cityItems = [];

  List<String> statusOptions = ['Booked', 'In Transit', 'Delivered', 'Returned', 'Failed']; 
  List<String> courierOptions = [];
  List<String> statusApiOptions = [];
  
  String? statusError;
  String? courierError;
  List<String> cityOptions = [];
  List<String> paymentMethodOptions = ['COD', 'CC'];
  List<String> paymentStatusOptions = ['Paid', 'Unpaid']; 
  
  
  bool showValidationErrors = false;
  final AuthService _authService = Get.find<AuthService>();

  
  static List<String>? _cachedStatuses;
  static List<String>? _cachedCities;

  @override
  void initState() {
    super.initState();
    
    if (widget.initialFilters != null) {
      selectedStatuses = List<String>.from(widget.initialFilters!['status'] ?? []);
      selectedCouriers = List<String>.from(widget.initialFilters!['courier'] ?? []);
      selectedCities = List<String>.from(widget.initialFilters!['city'] ?? []);
      selectedPaymentMethod = widget.initialFilters!['paymentMethod'];
      selectedPaymentStatus = widget.initialFilters!['paymentStatus'];
    }
    _loadUserDataAndFetchData();
  }

  Future<void> _loadUserDataAndFetchData() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchDropdownData();
  }

  Future<void> fetchDropdownData() async {
    
    if (_cachedCities != null) {
      setState(() {
        cityOptions = List<String>.from(_cachedCities!);
      });
    }
    
    
    if (_cachedStatuses != null) {
      setState(() {
        statusApiOptions = List<String>.from(_cachedStatuses!);
      });
    }
    
    
    await _fetchCouriersFromCache();
    
    
    if (_cachedCities == null) {
      // Use CitiesService to get proper id-name pairs (cached internally)
      try {
        final cached = CitiesService.getCachedCities();
        if (cached != null) {
          setState(() {
            _cityItems = cached.map((c) => {
              'id': c['id'].toString(),
              'name': c['name'].toString(),
            }).toList();
            cityOptions = _cityItems.map((e) => e['name']!).toList();
            _cachedCities = List<String>.from(cityOptions);
          });
        } else {
          final cities = await CitiesService().getCities();
          setState(() {
            _cityItems = cities.map((c) => {
              'id': c['id'].toString(),
              'name': c['name'].toString(),
            }).toList();
            cityOptions = _cityItems.map((e) => e['name']!).toList();
            _cachedCities = List<String>.from(cityOptions);
          });
        }
      } catch (_) {
        setState(() {
          _cityItems = [];
          cityOptions = [];
        });
      }
    } else {
      // Also hydrate _cityItems from cached service if available
      final cached = CitiesService.getCachedCities();
      if (cached != null) {
        _cityItems = cached.map((c) => {
          'id': c['id'].toString(),
          'name': c['name'].toString(),
        }).toList();
      }
    }
    
    
    if (_cachedStatuses == null) {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        return;
      }
      
      
      try {
        final response = await Dio().post(
          ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
          data: {"status_type": ["System","Rider"]},
          options: Options(headers: {'Content-Type': 'application/json'}),
        );
        final List<dynamic> data = response.data is List
            ? response.data
            : (response.data['data'] ?? []);
        setState(() {
          statusApiOptions = data.map((s) => (s['name'] ?? s['status_name'] ?? '').toString()).where((s) => s.isNotEmpty).toList();
          
          _cachedStatuses = List<String>.from(statusApiOptions);
        });
      } catch (_) {
        setState(() {
          statusApiOptions = [];
        });
      }
    }
  }

  Future<void> _fetchCouriersFromCache() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          courierOptions = [];
        });
        return;
      }
      
      
      final cachedCouriers = CourierService.getCachedCouriers(acno);
      if (cachedCouriers != null) {
        setState(() {
          courierOptions = cachedCouriers.map((c) {
            final accountTitle = c['account_title']?.toString() ?? '';
            final courierName = c['courier_name']?.toString() ?? c['name']?.toString() ?? '';
            if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
              return '$accountTitle ($courierName)';
            } else if (accountTitle.isNotEmpty) {
              return accountTitle;
            } else {
              return courierName;
            }
          }).where((s) => s.isNotEmpty).toList();
        });
      } else {
        
        final response = await Dio().post(
          ApiConfig.getEndpointUrl(ApiConfig.courierAccountsEndpoint),
          data: {"acno": acno},
          options: Options(headers: {'Content-Type': 'application/json'}),
        );
        final List<dynamic> data = response.data is List
            ? response.data
            : (response.data['data'] ?? []);
        setState(() {
          courierOptions = data.map((c) {
            final accountTitle = c['account_title']?.toString() ?? '';
            final courierName = c['courier_name']?.toString() ?? c['name']?.toString() ?? '';
            if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
              return '$accountTitle ($courierName)';
            } else if (accountTitle.isNotEmpty) {
              return accountTitle;
            } else {
              return courierName;
            }
          }).where((s) => s.isNotEmpty).toList();
        });
      }
    } catch (_) {
      setState(() {
        courierOptions = [];
      });
    }
  }

  Future<void> _fetchStatuses() async {
    
    if (_cachedStatuses != null) {
      setState(() {
        statusApiOptions = List<String>.from(_cachedStatuses!);
      });
      return;
    }

    setState(() {
      statusError = null;
    });
    try {
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
        data: {"status_type": ["System", "Rider"]},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      final List<dynamic> data = response.data is List
          ? response.data
          : (response.data['data'] ?? []);
      setState(() {
        statusApiOptions = data.map((e) => e['name'].toString()).toList();
      });
      
      _cachedStatuses = List<String>.from(statusApiOptions);
    } catch (e) {
      setState(() {
        statusError = 'Failed to load statuses';
      });
    }
  }

  void _showSearchDialog({
    required String title,
    required List<String> options,
    required String? selectedValue,
    required ValueChanged<String> onSelected,
  }) {
    showDialog(
      context: context,
      builder: (context) => _SearchDialog(
        title: title,
        options: options,
        selectedValue: selectedValue,
        onSelected: (val) {
          onSelected(val);
          Navigator.of(context).pop();
        },
      ),
    );
  }

  void customSnackBar(String title, String message) {
    final snackBar = SnackBar(
      content: Text(message),
      backgroundColor: Colors.red,
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
      ),
      margin: const EdgeInsets.all(16),
      duration: const Duration(seconds: 3),
    );
    final rootContext = Navigator.of(context, rootNavigator: true).context;
    ScaffoldMessenger.of(rootContext).showSnackBar(snackBar);
  }

  Future<void> _showMultiSelectDialog({
    required String title,
    required List<String> options,
    required List<String> selectedValues,
    required ValueChanged<List<String>> onConfirm,
  }) async {
    final result = await showModalBottomSheet<List<String>>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => _CustomMultiSelectDialog(
        items: options,
        initialValue: selectedValues,
        title: title,
      ),
    );
    if (result != null) {
      onConfirm(result);
    }
  }

  @override
  Widget build(BuildContext context) {
    final String? selectedCourierLabel = selectedCouriers.isEmpty ? null : selectedCouriers.first;
    final List<String> courierLabels = courierOptions;
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Padding(
          padding: const EdgeInsets.only(left: 8),
          child: const Text(
            'Filter',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
              child: AnimationLimiter(
                child: Column(
                  children: AnimationConfiguration.toStaggeredList(
                    duration: const Duration(milliseconds: 500),
                    childAnimationBuilder: (widget) => SlideAnimation(
                      verticalOffset: 50.0,
                      child: FadeInAnimation(
                        child: widget,
                      ),
                    ),
                    children: [
                      const SizedBox(height: 2),
                      
                      GestureDetector(
                        onTap: () => _showMultiSelectDialog(
                          title: 'Select Status',
                          options: statusApiOptions,
                          selectedValues: selectedStatuses,
                          onConfirm: (values) => setState(() => selectedStatuses = values),
                        ),
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(color: Colors.transparent, width: 1),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedStatuses.isEmpty ? 'Select Status' : selectedStatuses.join(', '),
                                  style: GoogleFonts.poppins(fontSize: 15, color: selectedStatuses.isEmpty ? Colors.black : Colors.black),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 2),
                      
                      GestureDetector(
                        onTap: () => _showMultiSelectDialog(
                              title: 'Select Courier',
                          options: courierLabels,
                          selectedValues: selectedCouriers,
                          onConfirm: (values) => setState(() => selectedCouriers = values),
                        ),
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(color: Colors.transparent, width: 1),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedCouriers.isEmpty ? 'Select Courier' : selectedCouriers.join(', '),
                                  style: GoogleFonts.poppins(fontSize: 15, color: selectedCouriers.isEmpty ? Colors.black : Colors.black),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 2),
                      
                      GestureDetector(
                        onTap: () => _showMultiSelectDialog(
                          title: 'Select City',
                          options: cityOptions,
                          selectedValues: selectedCities,
                          onConfirm: (values) => setState(() => selectedCities = values),
                        ),
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(color: Colors.transparent, width: 1),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedCities.isEmpty ? 'Select City' : selectedCities.join(', '),
                                  style: GoogleFonts.poppins(fontSize: 15, color: selectedCities.isEmpty ? Colors.black : Colors.black),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 2),
                      
                      GestureDetector(
                        onTap: () async {
                          final selected = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (context) => _PaymentMethodDialog(
                              paymentMethods: paymentMethodOptions,
                              selectedPaymentMethod: selectedPaymentMethod,
                            ),
                          );
                          if (selected != null) {
                            setState(() {
                              selectedPaymentMethod = selected;
                            });
                          }
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(color: Colors.transparent, width: 1),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedPaymentMethod ?? 'Select Payment Method',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15,
                                    color: selectedPaymentMethod == null ? Colors.black: Colors.black,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 2),
                      
                      GestureDetector(
                        onTap: () async {
                          final selected = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (context) => _PaymentStatusDialog(
                              paymentStatuses: paymentStatusOptions,
                              selectedPaymentStatus: selectedPaymentStatus,
                            ),
                          );
                          if (selected != null) {
                            setState(() {
                              selectedPaymentStatus = selected;
                            });
                          }
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(color: Colors.transparent, width: 1),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedPaymentStatus ?? 'Select Payment Status',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15,
                                    color: selectedPaymentStatus == null ? Colors.black : Colors.black,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      SizedBox(
                        width: double.infinity,
                        height: 48,
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF007AFF),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          onPressed: () {
                            
                            setState(() {
                              showValidationErrors = false;
                            });
                            
                            final noFilter = (selectedStatuses.isEmpty || (selectedStatuses.length == 1 && (selectedStatuses.first == '' || selectedStatuses.first == null))) &&
                              (selectedCouriers.isEmpty || (selectedCouriers.length == 1 && (selectedCouriers.first == '' || selectedCouriers.first == null))) &&
                              (selectedCities.isEmpty || (selectedCities.length == 1 && (selectedCities.first == '' || selectedCities.first == null))) &&
                              (selectedPaymentMethod == null || selectedPaymentMethod == '') &&
                              (selectedPaymentStatus == null || selectedPaymentStatus == '');
                            if (noFilter) {
                              customSnackBar('Error', 'Please select at least one filter');
                              return;
                            }
                            
                            final selectedCityIds = <String>[];
                            for (final cityName in selectedCities) {
                              try {
                                final match = _cityItems.firstWhere((e) => (e['name'] ?? '').toLowerCase().trim() == cityName.toLowerCase().trim());
                                if ((match['id'] ?? '').isNotEmpty) {
                                  selectedCityIds.add(match['id']!);
                                }
                              } catch (_) {}
                            }
                            widget.onApply({
                              'status': selectedStatuses,
                              'courier': selectedCouriers,
                              'city': selectedCities, // keep names for UI summary
                              'city_ids': selectedCityIds, // pass IDs for API
                              'paymentMethod': selectedPaymentMethod,
                              'paymentStatus': selectedPaymentStatus,
                            });
                            Navigator.of(context).pop();
                          },
                          child: const Text('Apply Filters', style: TextStyle(fontSize: 18, color: Colors.white)),
                        ),
                      ),
                      const SizedBox(height: 16),
                      GestureDetector(
                        onTap: () {
                          setState(() {
                            selectedStatuses = [];
                            selectedCouriers = [];
                            selectedCities = [];
                            selectedPaymentMethod = null;
                            selectedPaymentStatus = null;
                          });
                          widget.onReset();
                        },
                        child: const Text('Reset Filter', style: TextStyle(color: Colors.red, fontWeight: FontWeight.w600, fontSize: 16)),
                      ),
                    ],
                  ),
                ),
              ),
            ),
    );
  }

  Widget _searchableField({
    required String label,
    required String? value,
    required bool isLoading,
    required VoidCallback onTap,
    bool isError = false,
  }) {
    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: isError ? Colors.red : const Color(0xFFE5E7EB)),
        borderRadius: BorderRadius.circular(12),
        color: isError ? const Color(0xFFFFEBEE) : const Color(0xFFF5F5F7),
      ),
      child: isLoading
          ? const Padding(
              padding: EdgeInsets.symmetric(vertical: 14, horizontal: 16),
              child: SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
            )
          : InkWell(
              onTap: onTap,
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                child: Row(
                  children: [
                    Expanded(
                      child: Text(
                        value ?? label,
                        style: TextStyle(
                          color: value != null ? Colors.black : Colors.black,
                        ),
                      ),
                    ),
                    const Icon(Icons.arrow_drop_down_rounded, color: Colors.grey),
                  ],
                ),
              ),
            ),
    );
  }

  
  static void clearAllCourierInsightsFilterCaches() {
    _CourierInsightsFilterScreenState._cachedStatuses = null;
    _CourierInsightsFilterScreenState._cachedCities = null;
  }
}

class _SearchDialog extends StatefulWidget {
  final String title;
  final List<String> options;
  final String? selectedValue;
  final ValueChanged<String> onSelected;

  const _SearchDialog({
    Key? key,
    required this.title,
    required this.options,
    required this.selectedValue,
    required this.onSelected,
  }) : super(key: key);

  @override
  State<_SearchDialog> createState() => _SearchDialogState();
}

class _SearchDialogState extends State<_SearchDialog> {
  late List<String> _filteredOptions;
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _filteredOptions = widget.options;
  }

  void _filterOptions(String query) {
    setState(() {
      if (query.isEmpty) {
        _filteredOptions = widget.options;
      } else {
        _filteredOptions = widget.options.where((option) => option.toLowerCase().contains(query.toLowerCase())).toList();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Container(
        height: MediaQuery.of(context).size.height * 0.7,
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  widget.title,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close_rounded),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                hintText: 'Search...',
                prefixIcon: Icon(Icons.search_rounded),
                border: InputBorder.none,
                contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              ),
              onChanged: _filterOptions,
            ),
            const SizedBox(height: 16),
            Expanded(
              child: _filteredOptions.isEmpty
                  ? const Center(
                      child: Text(
                        'No options found',
                        style: TextStyle(color: Colors.grey),
                      ),
                    )
                  : ListView.builder(
                      itemCount: _filteredOptions.length,
                      itemBuilder: (context, index) {
                        final option = _filteredOptions[index];
                        final isSelected = option == widget.selectedValue;
                        return ListTile(
                          title: Text(option),
                          leading: isSelected
                              ? const Icon(Icons.check_circle_rounded, color: Color(0xFF007AFF))
                              : const Icon(Icons.radio_button_unchecked_rounded, color: Colors.grey),
                          onTap: () => widget.onSelected(option),
                          tileColor: isSelected ? const Color(0xFFE6F0FF) : null,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
} 


class _StatusSelectDialog extends StatefulWidget {
  final List<String> options;
  final String? selected;
  const _StatusSelectDialog({Key? key, required this.options, this.selected}) : super(key: key);

  @override
  State<_StatusSelectDialog> createState() => _StatusSelectDialogState();
}

class _StatusSelectDialogState extends State<_StatusSelectDialog> {
  String _search = '';

  @override
  Widget build(BuildContext context) {
    final filtered = widget.options.where((e) => e.toLowerCase().contains(_search.toLowerCase())).toList();
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Container(
        width: MediaQuery.of(context).size.width * 0.9,
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('Select Status', style: GoogleFonts.poppins(fontWeight: FontWeight.bold, fontSize: 18)),
            const SizedBox(height: 12),
            TextField(
              decoration: InputDecoration(
                hintText: 'Search status',
                prefixIcon: Icon(Icons.search_rounded),
                border: InputBorder.none,
                contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 12),
              ),
              onChanged: (val) => setState(() => _search = val),
            ),
            const SizedBox(height: 12),
            SizedBox(
              height: 250,
              child: filtered.isEmpty
                  ? const Center(child: Text('No statuses found.'))
                  : ListView.separated(
                      itemCount: filtered.length,
                      separatorBuilder: (context, i) => Container(
                        height: 1,
                        color: const Color(0xFFB3D4FC), 
                        margin: const EdgeInsets.symmetric(horizontal: 8),
                      ),
                      itemBuilder: (context, i) {
                        final status = filtered[i];
                        return ListTile(
                          title: Text(status, style: GoogleFonts.poppins()),
                          selected: status == widget.selected,
                          onTap: () {
                            Navigator.of(context).pop(status);
                          },
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
} 


class _SingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _SingleSelectDialog({Key? key, required this.items, required this.initialValue, required this.title}) : super(key: key);

  @override
  State<_SingleSelectDialog> createState() => _SingleSelectDialogState();
}

class _SingleSelectDialogState extends State<_SingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      insetPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 24),
      child: SingleChildScrollView(
        child: AnimationLimiter(
          child: Container(
            width: 500,
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: AnimationConfiguration.toStaggeredList(
                duration: const Duration(milliseconds: 400),
                childAnimationBuilder: (widget) => SlideAnimation(
                  verticalOffset: 30.0,
                  child: FadeInAnimation(
                    child: widget,
                  ),
                ),
                children: [
                  Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                  const SizedBox(height: 12),
                  TextField(
                    decoration: InputDecoration(
                      hintText: 'Search',
                      prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                      border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                    ),
                    onChanged: (val) => setState(() => _search = val),
                  ),
                  const SizedBox(height: 12),
                  SizedBox(
                    height: 300,
                    child: ListView.separated(
                      itemCount: filteredItems.length,
                      separatorBuilder: (_, __) => Container(
                        height: 1,
                        color: Colors.black.withOpacity(0.08),
                        margin: const EdgeInsets.symmetric(horizontal: 8),
                      ),
                      itemBuilder: (context, i) {
                        final item = filteredItems[i];
                        final isSelected = selected == item;
                        return ListTile(
                          title: Text(item),
                          trailing: isSelected
                              ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                              : null,
                          onTap: () {
                            setState(() {
                              selected = item;
                            });
                            Navigator.of(context).pop(item);
                          },
                          selected: isSelected,
                          selectedTileColor: const Color(0xFFE6F0FF),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
} 


class _OverlayDropdownField extends StatefulWidget {
  final String hint;
  final String? value;
  final List<String> items;
  final ValueChanged<String?> onChanged;
  const _OverlayDropdownField({Key? key, required this.hint, required this.value, required this.items, required this.onChanged}) : super(key: key);

  @override
  State<_OverlayDropdownField> createState() => _OverlayDropdownFieldState();
}

class _OverlayDropdownFieldState extends State<_OverlayDropdownField> {
  final GlobalKey _fieldKey = GlobalKey();
  OverlayEntry? _overlayEntry;

  void _showDropdown() {
    final RenderBox renderBox = _fieldKey.currentContext!.findRenderObject() as RenderBox;
    final Offset offset = renderBox.localToGlobal(Offset.zero);
    final Size size = renderBox.size;
    _overlayEntry = OverlayEntry(
      builder: (context) => Positioned(
        left: offset.dx,
        top: offset.dy + size.height,
        width: size.width,
        child: Material(
          color: Colors.transparent,
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.08),
                  blurRadius: 8,
                  offset: Offset(0, 2),
                ),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: widget.items.map((item) => Column(
                children: [
                  ListTile(
                    title: Text(item, style: GoogleFonts.poppins(fontSize: 15)),
                    dense: true,
                    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),
                    selected: widget.value == item,
                    selectedTileColor: const Color(0xFF007AFF).withOpacity(0.08),
                    onTap: () {
                      widget.onChanged(item);
                      _removeDropdown();
                    },
                  ),
                  if (item != widget.items.last)
                    Container(
                      height: 1,
                      color: const Color(0xFFB3D4FC),
                      margin: const EdgeInsets.symmetric(horizontal: 8),
                    ),
                ],
              )).toList(),
            ),
          ),
        ),
      ),
    );
    Overlay.of(context).insert(_overlayEntry!);
  }

  void _removeDropdown() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }

  @override
  void dispose() {
    _removeDropdown();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      key: _fieldKey,
      onTap: () {
        if (_overlayEntry == null) {
          _showDropdown();
        } else {
          _removeDropdown();
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: InputDecorator(
          decoration: InputDecoration(
            hintText: widget.hint,
            hintStyle: GoogleFonts.poppins(fontSize: 15, color: Color(0xFF6B6B6B)),
            filled: true,
            fillColor: Colors.white,
            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: Colors.blue[300]!, width: 1.5),
            ),
          ),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  widget.value ?? widget.hint,
                  style: GoogleFonts.poppins(fontSize: 15, color: widget.value == null ? Color(0xFF6B6B6B) : Colors.black),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
            ],
          ),
        ),
      ),
    );
  }
} 

class _CustomMultiSelectDialog extends StatefulWidget {
  final List<String> items;
  final List<String> initialValue;
  final String title;
  const _CustomMultiSelectDialog({required this.items, required this.initialValue, required this.title});
  @override
  State<_CustomMultiSelectDialog> createState() => _CustomMultiSelectDialogState();
}

class _CustomMultiSelectDialogState extends State<_CustomMultiSelectDialog> {
  late List<String> _selected;
  String _search = '';
  @override
  void initState() {
    super.initState();
    _selected = List<String>.from(widget.initialValue);
  }
  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: ListView.separated(
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isChecked = _selected.contains(item);
                              return ListTile(
                                title: Text(item),
                                trailing: Checkbox(
                                  value: isChecked,
                                  activeColor: Color(0xFF007AFF),
                                  onChanged: (checked) {
                                    setState(() {
                                      if (checked == true) {
                                        _selected.add(item);
                                      } else {
                                        _selected.remove(item);
                                      }
                                    });
                                  },
                                ),
                                onTap: () {
                                  setState(() {
                                    if (isChecked) {
                                      _selected.remove(item);
                                    } else {
                                      _selected.add(item);
                                    }
                                  });
                                },
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: 100,
                          child: ElevatedButton(
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Color(0xFF007AFF),
                              elevation: 0,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                              padding: const EdgeInsets.symmetric(vertical: 14),
                            ),
                          onPressed: () {
                            Navigator.of(context).pop(_selected);
                          },
                            child: const Text('OK', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 

class _PaymentMethodDialog extends StatefulWidget {
  final List<String> paymentMethods;
  final String? selectedPaymentMethod;
  const _PaymentMethodDialog({Key? key, required this.paymentMethods, this.selectedPaymentMethod}) : super(key: key);

  @override
  State<_PaymentMethodDialog> createState() => _PaymentMethodDialogState();
}

class _PaymentMethodDialogState extends State<_PaymentMethodDialog> {
  late List<String> filteredPaymentMethods;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredPaymentMethods = widget.paymentMethods;
    searchController = TextEditingController();
    selected = widget.selectedPaymentMethod;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredPaymentMethods = widget.paymentMethods.where((p) => p.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select Payment Method', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredPaymentMethods.isEmpty
                              ? const Center(child: Text('No payment methods found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredPaymentMethods.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final paymentMethod = filteredPaymentMethods[i];
                                    final isSelected = paymentMethod == selected;
                                    return ListTile(
                                      title: Text(
                                        paymentMethod,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(paymentMethod);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _PaymentStatusDialog extends StatefulWidget {
  final List<String> paymentStatuses;
  final String? selectedPaymentStatus;
  const _PaymentStatusDialog({Key? key, required this.paymentStatuses, this.selectedPaymentStatus}) : super(key: key);

  @override
  State<_PaymentStatusDialog> createState() => _PaymentStatusDialogState();
}

class _PaymentStatusDialogState extends State<_PaymentStatusDialog> {
  late List<String> filteredPaymentStatuses;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredPaymentStatuses = widget.paymentStatuses;
    searchController = TextEditingController();
    selected = widget.selectedPaymentStatus;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredPaymentStatuses = widget.paymentStatuses.where((p) => p.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select Payment Status', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredPaymentStatuses.isEmpty
                              ? const Center(child: Text('No payment statuses found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredPaymentStatuses.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final paymentStatus = filteredPaymentStatuses[i];
                                    final isSelected = paymentStatus == selected;
                                    return ListTile(
                                      title: Text(
                                        paymentStatus,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(paymentStatus);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../network/order_service.dart';
import '../services/auth_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'filter_screen.dart';
import 'dashboard_screen.dart' as dash;
import 'menu.dart' as menu;
import 'report.dart' as report;

import '../widgets/custom_date_selector.dart';
import 'courier_insights_filter_screen.dart';
import '../utils/custom_snackbar.dart';
import 'order_list_screen.dart';
import 'create_order.dart';
import '../widgets/courier_logo_widget.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../widgets/tracking_details_dialog.dart';

class CourierInsightsScreen extends StatefulWidget {
  const CourierInsightsScreen({Key? key}) : super(key: key);

  @override
  State<CourierInsightsScreen> createState() => _CourierInsightsScreenState();
}

class _CourierInsightsScreenState extends State<CourierInsightsScreen> {
  int totalReports = 0;
  List<Map<String, dynamic>> reports = [];
  bool isLoading = true;
  final Set<int> expanded = {};
  DateTime _startDate = DateTime.now().subtract(const Duration(days: 3));
  DateTime _endDate = DateTime.now();
  
  String? _searchQuery;
  List<Map<String, dynamic>> _filteredReports = [];
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  final AuthService _authService = Get.find<AuthService>();
  
  List<String> filterStatuses = [];
  List<String> filterCouriers = [];
  // City names for display in UI
  List<String> filterCities = [];
  // City IDs for API filtering
  List<String> filterCityIds = [];
  String? filterPaymentMethod;
  String? filterPaymentStatus;

  
  static Map<String, dynamic>? _lastParams;
  static List<Map<String, dynamic>>? _cachedReports;

  
  static void clearAllCourierInsightsCaches() {
    _lastParams = null;
    _cachedReports = null;
  }

  @override
  void initState() {
    super.initState();
    _restoreOrFetchCourierInsights();
    _searchController.addListener(_onSearchChanged);
  }

  void _restoreOrFetchCourierInsights() async {
    final acno = _authService.getCurrentAcno();
      final params = {
      'acno': acno,
      'startDate': _startDate.toIso8601String().split('T')[0],
      'endDate': _endDate.toIso8601String().split('T')[0],
      'filterStatuses': filterStatuses.join(','),
      'filterCouriers': filterCouriers.join(','),
        'filterCities': filterCities.join(','), // names for readability
        'filterCityIds': filterCityIds.join(','),
      'filterPaymentMethod': filterPaymentMethod ?? '',
      'filterPaymentStatus': filterPaymentStatus ?? '',
    };
    if (_lastParams != null && _cachedReports != null && _lastParams.toString() == params.toString()) {
      setState(() {
        reports = List<Map<String, dynamic>>.from(_cachedReports!);
        totalReports = reports.length;
        _applySearch();
        isLoading = false;
      });
      return;
    }
    await _loadUserDataAndFetchInsights();
  }

  Future<void> _loadUserDataAndFetchInsights() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchCourierInsights();
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text;
      _applySearch();
    });
  }

  Future<void> fetchCourierInsights() async {
    setState(() {
      isLoading = true;
    });
    
    final acno = _authService.getCurrentAcno();
    if (acno == null) {
      setState(() => isLoading = false);
      return;
    }
    
    final startDateStr = _startDate.toIso8601String().split('T')[0];
    final endDateStr = _endDate.toIso8601String().split('T')[0];
      final params = {
      'acno': acno,
      'startDate': startDateStr,
      'endDate': endDateStr,
      'filterStatuses': filterStatuses.join(','),
      'filterCouriers': filterCouriers.join(','),
        'filterCities': filterCities.join(','), // names for readability
        'filterCityIds': filterCityIds.join(','),
      'filterPaymentMethod': filterPaymentMethod ?? '',
      'filterPaymentStatus': filterPaymentStatus ?? '',
    };
    try {
      final data = await OrderService.fetchCourierInsights(
        acno: acno,
        startLimit: 1,
        endLimit: 50000,
        startDate: startDateStr,
        endDate: endDateStr,
        filterCities: filterCityIds.isNotEmpty ? filterCityIds : null,
      );
      
      
      List<Map<String, dynamic>> filteredData = List<Map<String, dynamic>>.from(data);
      
      
      if (filterStatuses.isNotEmpty) {
        filteredData = filteredData.where((report) {
          final reportStatus = report['status_name']?.toString() ?? '';
          return filterStatuses.any((status) => 
            reportStatus.toLowerCase().contains(status.toLowerCase()) ||
            status.toLowerCase().contains(reportStatus.toLowerCase())
          );
        }).toList();
      }
      
      
      if (filterCouriers.isNotEmpty) {
        filteredData = filteredData.where((report) {
          final reportCourierName = report['courier_name']?.toString() ?? '';
          final reportAccountTitle = report['account_title']?.toString() ?? '';
          
          
          bool hasMatch = filterCouriers.any((courier) {
            
            if (courier.toLowerCase().contains('managed')) {
              return reportAccountTitle.toLowerCase().contains('managed');
            }
            
            else {
              
              bool courierMatches = reportCourierName.toLowerCase().contains(courier.toLowerCase()) ||
                                   courier.toLowerCase().contains(reportCourierName.toLowerCase());
              
              
              if (courierMatches) {
                return !reportAccountTitle.toLowerCase().contains('managed');
              }
              return false;
            }
          });
          
          return hasMatch;
        }).toList();
      }
      
      
      // City filtering is now handled by the API call
      
      
      if (filterPaymentMethod != null && filterPaymentMethod!.isNotEmpty) {
        filteredData = filteredData.where((report) {
          final reportPaymentMethod = report['payment_type']?.toString() ?? '';
          return reportPaymentMethod.toLowerCase().contains(filterPaymentMethod!.toLowerCase()) ||
                 filterPaymentMethod!.toLowerCase().contains(reportPaymentMethod.toLowerCase());
        }).toList();
      }
      
      
      if (filterPaymentStatus != null && filterPaymentStatus!.isNotEmpty) {
        filteredData = filteredData.where((report) {
          final paymentStatus = report['payment_status']?.toString() ?? '';
          final reportPaymentStatus = report['payment_status']?.toString() ?? '';
          
          switch (filterPaymentStatus!.toLowerCase()) {
            case 'paid':
              return reportPaymentStatus == '1';
            case 'unpaid':
              return reportPaymentStatus == '0';
            case 'partial':
              return reportPaymentStatus == '2';
            default:
              return true;
          }
        }).toList();
      }
      
      setState(() {
        reports = filteredData;
        totalReports = filteredData.length;
        _cachedReports = List<Map<String, dynamic>>.from(filteredData); 
        _lastParams = params;
        _applySearch();
      });
    } catch (e) {
      
      setState(() {
        reports = [];
        totalReports = 0;
        _applySearch();
      });
    } finally {
      setState(() => isLoading = false);
    }
  }

  void _applySearch() {
    if (_searchQuery != null && _searchQuery!.isNotEmpty) {
      _filteredReports = reports.where((report) {
        return report.values.any((v) => v != null && v.toString().toLowerCase().contains(_searchQuery!.toLowerCase()));
      }).toList();
    } else {
      _filteredReports = reports;
    }
  }

  bool _hasActiveFilters() {
    return filterStatuses.isNotEmpty || 
           filterCouriers.isNotEmpty || 
           filterCities.isNotEmpty || 
           (filterPaymentMethod != null && filterPaymentMethod!.isNotEmpty) ||
           (filterPaymentStatus != null && filterPaymentStatus!.isNotEmpty);
  }

  String _getFilterSummary() {
    final summary = <String>[];
    if (filterStatuses.isNotEmpty) {
      summary.add('Status: ${filterStatuses.join(', ')}');
    }
    if (filterCouriers.isNotEmpty) {
      summary.add('Courier: ${filterCouriers.join(', ')}');
    }
    if (filterCities.isNotEmpty) {
      summary.add('City: ${filterCities.join(', ')}');
    }
    if (filterPaymentMethod != null && filterPaymentMethod!.isNotEmpty) {
      summary.add('Payment Method: ${filterPaymentMethod}');
    }
    if (filterPaymentStatus != null && filterPaymentStatus!.isNotEmpty) {
      summary.add('Payment Status: ${filterPaymentStatus}');
    }
    
    
    final currentList = (_searchQuery != null && _searchQuery!.isNotEmpty) ? _filteredReports : reports;
    final count = currentList.length;
    final summaryString = summary.where((s) => s.isNotEmpty).join(", ");
    return summaryString.isNotEmpty ? (summaryString + (count > 0 ? ' ($count)' : '')) : (count > 0 ? '($count)' : '');
  }

  void _showTrackingDialog(BuildContext context, Map<String, dynamic> report) async {
    final acno = _authService.getCurrentAcno();
    if (acno == null) {
      customSnackBar('Error', 'User account not found');
      return;
    }

    final orderId = int.tryParse(report['id']?.toString() ?? '0') ?? 0;
    final consignmentNo = report['consigment_no']?.toString() ?? '';
    
    if (consignmentNo.isEmpty) {
      customSnackBar('Error', 'Consignment No not found.');
      return;
    }

    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final orderService = OrderService();
      final payload = await orderService.fetchTrackingDetails(
        acno: acno,
        orderId: orderId,
        consignmentNo: consignmentNo,
      );
      
      Navigator.pop(context); 
      
      if (payload != null) {
        showModalBottomSheet(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (context) {
            return Container(
              width: double.infinity,
              padding: EdgeInsets.only(
                left: 0,
                right: 0,
                bottom: MediaQuery.of(context).viewInsets.bottom,
              ),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
              ),
              child: TrackingDetailsDialog(payload: payload),
            );
          },
        );
      } else {
        customSnackBar('Error', 'No tracking data available');
      }
    } catch (e) {
      Navigator.pop(context); 
      customSnackBar('Error', 'Failed to fetch tracking details: ${e.toString()}');
    }
  }



  void _showCourierInsightsDetailsBottomSheet(BuildContext context, Map<String, dynamic> report) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: AnimationLimiter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: AnimationConfiguration.toStaggeredList(
                    duration: const Duration(milliseconds: 500),
                    childAnimationBuilder: (widget) => SlideAnimation(
                      verticalOffset: 30.0,
                      child: FadeInAnimation(
                        child: widget,
                      ),
                    ),
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            children: [
                              const Text(
                                'Courier Insights Details',
                                style: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  fontSize: 14,
                                  fontFamily: 'SF Pro Display',
                                ),
                              ),
                              const SizedBox(width: 12),
                              Container(
                                constraints: const BoxConstraints(minWidth: 70, maxWidth: 100),
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                decoration: BoxDecoration(
                                  color: _statusColor(report['status_name'] ?? report['status']).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(16),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  (() {
                                    final status = (report['status_name'] ?? report['status'] ?? '').toString();
                                    return status.isNotEmpty ? status.capitalize : '';
                                  })().toString(),
                                  style: GoogleFonts.inter(color: _statusColor(report['status_name'] ?? report['status']), fontWeight: FontWeight.w500, fontSize: 15),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                          IconButton(
                            icon: const Icon(Icons.close_rounded),
                            onPressed: () => Navigator.of(context).pop(),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      _orderDetailRow('Order ID', report['id']?.toString() ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Name', report['consignee_name'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Weight', report['weight']?.toString() ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Arrival Weight', report['arrival_weight']?.toString() ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('City', report['destination_city'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Web Order ID', report['order_ref'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Amount', report['order_amount'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Charges', report['charges'] ?? report['shipping_charges'] ?? report['delivery_charges'] ?? report['courier_charges'] ?? report['service_charges'] ?? report['total_charges'] ?? '--'),
                      SizedBox(height: 10),
                      _orderDetailRow('Courier', report['courier_name'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Consignment No', report['consigment_no'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Payment Status', report['payment_status']?.toString() == '1' ? 'Paid' : 'Unpaid'),
                      SizedBox(height: 10),
                      _orderDetailRow('Created Date', _formatDate(report['created_date'])),
                      SizedBox(height: 10),
                      _orderDetailRow('Origin City', report['origin_city'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Tracking Remarks', report['tracking_remarks'] ?? ''),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _orderDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14)),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }

  String _getDateRangeFormatted() {
    String format(DateTime d) =>
        '${d.day.toString().padLeft(2, '0')}-${d.month.toString().padLeft(2, '0')}-${d.year}';
    return '${format(_startDate)} to ${format(_endDate)}';
  }

  Color _statusColor(String? status) {
    final s = status?.toLowerCase().trim();
    if (s == 'cancelled' || s == 'deleted') return Colors.red;
    if (s == 'booked') return const Color(0xFF8e24aa); 
    if (s == 'new') return Color(0xFF1DA1F2); 
    if (s == 'pickup ready' || s == 'delivered') return Color(0xFF43A047);
    if(s == 'return to shipper' || s == 'ready to return') return Colors.red;
    if(s == 'arrived at courier facility') return const Color(0xFF8e24aa); 
    return Colors.red;
  }

  Color _statusTextColor(Color bg) {
    final brightness = ThemeData.estimateBrightnessForColor(bg);
    return brightness == Brightness.light ? Colors.black : Colors.white;
  }

  @override
  Widget build(BuildContext context) {
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          backgroundColor: Colors.white,
          
          foregroundColor: Colors.black,
          surfaceTintColor: Colors.white,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
            onPressed: () => Navigator.of(context).maybePop(),
          ),
          title: const Text(
            'Courier Insights',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
          actions: [
            if (_searchQuery != null && _searchQuery!.isNotEmpty)
              IconButton(
                icon: const Icon(Icons.clear_rounded, color: Colors.grey),
                onPressed: () {
                  setState(() {
                    _searchController.clear();
                    _searchQuery = null;
                    _applySearch();
                  });
                },
              ),
            Padding(
              padding: const EdgeInsets.only(right: 8.0),
              child: Stack(
                children: [
                  IconButton(
                    icon: SvgPicture.asset(
                      'assets/Filter.svg', 
                      width: 24,
                      height: 24,
                      color: Colors.black, 
                    ),
                    onPressed: () async {
                      await Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (_) => CourierInsightsFilterScreen(
                            onApply: (filters) {
                              setState(() {
                                filterStatuses = List<String>.from(filters['status'] ?? []);
                                filterCouriers = List<String>.from(filters['courier'] ?? []);
                                filterCities = List<String>.from(filters['city'] ?? []); // names
                                filterCityIds = List<String>.from(filters['city_ids'] ?? []); // ids
                                filterPaymentMethod = filters['paymentMethod'];
                                filterPaymentStatus = filters['paymentStatus'];
                              });
                              fetchCourierInsights();
                              customSnackBar('Success', 'Filters applied successfully');
                            },
                            onReset: () {
                              setState(() {
                                filterStatuses = [];
                                filterCouriers = [];
                                filterCities = [];
                                filterPaymentMethod = null;
                                filterPaymentStatus = null;
                              });
                              fetchCourierInsights();
                              customSnackBar('Success', 'Filters reset successfully');
                            },
                            initialFilters: {
                              'status': filterStatuses,
                              'courier': filterCouriers,
                              'city': filterCities,
                              'paymentMethod': filterPaymentMethod,
                              'paymentStatus': filterPaymentStatus,
                            },
                          ),
                        ),
                      );
                    },
                  ),
                  if (_hasActiveFilters())
                    Positioned(
                      right: 8,
                      top: 8,
                      child: Container(
                        width: 8,
                        height: 8,
                        decoration: const BoxDecoration(
                          color: Colors.blue,
                          shape: BoxShape.circle,
                        ),
                      ),
                    ),
                ],
              ),
            ),
            IconButton(
              icon: SvgPicture.asset(
                'assets/Calender.svg',
                width: 24,
                height: 24,
                color: Colors.black,
              ),
              onPressed: () async {
                final picked = await showModalBottomSheet<DateTimeRange>(
                  context: context,
                  isScrollControlled: true,
                  backgroundColor: Colors.transparent,
                  builder: (context) => Container(
                    width: MediaQuery.of(context).size.width,
                    height: MediaQuery.of(context).size.height * 0.6,
                    decoration: const BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                    ),
                    child: CustomDateSelector(
                      initialStartDate: _startDate,
                      initialEndDate: _endDate,
                    ),
                  ),
                );
                if (picked != null) {
                  setState(() {
                    _startDate = picked.start;
                    _endDate = picked.end;
                  });
                  await fetchCourierInsights();
                }
              },
            ),
          ],
        ),
        body: isLoading
            ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
            : GestureDetector(
                behavior: HitTestBehavior.translucent,
                onTap: () {
                  FocusScope.of(context).unfocus();
                },
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      
                      Padding(
                        padding: const EdgeInsets.only(bottom: 4, top: 8),
                        child: Text(
                          _getDateRangeFormatted(),
                          style: const TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w400,
                            fontSize: 14,
                            color: Colors.grey,
                          ),
                        ),
                      ),
                      
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 4),
                        child: TextField(
                          controller: _searchController,
                          focusNode: _searchFocusNode,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            suffixIcon: Icon(Icons.search_rounded),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(12),
                            ),
                            filled: true,
                            fillColor: const Color(0xFFF5F5F7),
                            contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                            focusedBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(12),
                              borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(12),
                              borderSide: BorderSide.none,
                            ),
                          ),
                        ),
                      ),
                      
                      Text(
                        'Total Courier Insights Reports: ${_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredReports.length : totalReports}',
                        style: const TextStyle(
                          fontFamily: 'SF Pro Display',
                          fontWeight: FontWeight.w400,
                          fontSize: 15,
                          color: Colors.black,
                        ),
                      ),
                      
                      if (_hasActiveFilters()) ...[
                        const SizedBox(height: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                          decoration: BoxDecoration(
                            color: Colors.blue.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.blue.withOpacity(0.3)),
                          ),
                          child: Row(
                            children: [
                              Icon(Icons.filter_list_rounded, size: 16, color: Colors.blue[700]),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  _getFilterSummary(),
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: Colors.blue[700],
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ),
                              GestureDetector(
                                onTap: () async {
                                  setState(() {
                                    filterStatuses = [];
                                    filterCouriers = [];
                                    filterCities = [];
                                    filterPaymentMethod = null;
                                    filterPaymentStatus = null;
                                  });
                                  await fetchCourierInsights();
                                  customSnackBar('Success', 'Filters cleared');
                                },
                                child: Icon(Icons.clear_rounded, size: 16, color: Colors.blue[700]),
                              ),
                            ],
                          ),
                        ),
                      ],
                      const SizedBox(height: 8),
                      
                      Expanded(
                        child: RefreshIndicator(
                          onRefresh: () async {
                            await fetchCourierInsights();
                          },
                          child: (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredReports : reports).isEmpty
                              ? const Center(child: Text('No courier insights found.'))
                              : AnimationLimiter(
                                  child: ListView.builder(
                                    physics: const AlwaysScrollableScrollPhysics(),
                                    padding: const EdgeInsets.only(bottom: 80, top: 8),
                                    itemCount: (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredReports : reports).length,
                              itemBuilder: (context, i) {
                                final report = (_searchQuery != null && _searchQuery!.isNotEmpty ? _filteredReports : reports)[i];
                                final isExpanded = expanded.contains(i);
                                return AnimationConfiguration.staggeredList(
                                  position: i,
                                  duration: const Duration(milliseconds: 450),
                                  child: SlideAnimation(
                                    verticalOffset: 50.0,
                                    child: FadeInAnimation(
                                      child: Column(
                                        children: [
                                          Container(
                                            width: double.infinity,
                                            margin: const EdgeInsets.only(top: 4, bottom: 4),
                                            padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                                            decoration: BoxDecoration(
                                              color: const Color(0xFFF5F5F7),
                                              borderRadius: BorderRadius.circular(12),
                                            ),
                                            child: Column(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Padding(
                                                        padding: const EdgeInsets.only(top: 8),
                                                        child: Text(
                                                          'Order ID: ${report['id'] ?? ''}',
                                                          style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                                                        ),
                                                      ),
                                                    ),
                                                    Column(
                                                      children: [
                                                        SizedBox(height: 6),
                                                        Builder(
                                                          builder: (context) {
                                                            final status = (report['status_name']?.toString() ?? report['status']?.toString() ?? '').trim();
                                                            final bgColor = _statusColor(status).withOpacity(0.1);
                                                            final txtColor = _statusColor(status);
                                                            return Container(
                                                              constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                                              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                              decoration: BoxDecoration(
                                                                color: bgColor,
                                                                borderRadius: BorderRadius.circular(16),
                                                              ),
                                                              alignment: Alignment.center,
                                                              child: Text(
                                                                status.isNotEmpty
                                                                    ? (() {
                                                                        final s = status.toLowerCase();
                                                                        if (s == 'booked') return 'Booked';
                                                                        if (s == 'arrival') return 'Arrival';
                                                                        if (s == 'in transit') return 'In Transit';
                                                                        if (s == 'failed') return 'Failed';
                                                                        return status.capitalize ?? status;
                                                                      })()
                                                                    : '-',
                                                                style: GoogleFonts.inter(color: txtColor, fontWeight: FontWeight.w500, fontSize: 15),
                                                                overflow: TextOverflow.ellipsis,
                                                              ),
                                                            );
                                                          },
                                                        ),
                                                      ],
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Name', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['consignee_name'] ?? '').isEmpty ? '-' : (report['consignee_name'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                // Web Order ID (card) - moved after Name
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Web Order ID', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['order_ref'] ?? '').isEmpty ? '-' : (report['order_ref'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('City', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['destination_city'] ?? '').isEmpty ? '-' : (report['destination_city'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Amount', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['order_amount'] ?? '').isEmpty ? '-' : (report['order_amount'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                // Charges (card)
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Charges', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text(
                                                              (() {
                                                                final v = (report['charges'] ??
                                                                    report['shipping_charges'] ??
                                                                    report['delivery_charges'] ??
                                                                    report['courier_charges'] ??
                                                                    report['service_charges'] ??
                                                                    report['total_charges'] ??
                                                                    '').toString();
                                                                return v.isEmpty ? '--' : v;
                                                              })(),
                                                              style: GoogleFonts.inter(fontWeight: FontWeight.w300),
                                                            ),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Weight', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['weight'] ?? '').isEmpty ? '-' : (report['weight'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Arrival Weight', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['arrival_weight'] ?? '').isEmpty ? '-' : (report['arrival_weight'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Consignment No', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text((report['consigment_no'] ?? '').isEmpty ? '-' : (report['consigment_no'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Payment Status', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Builder(
                                                            builder: (context) {
                                                              final isPaid = report['payment_status']?.toString() == '1';
                                                              final bgColor = isPaid
                                                                  ? const Color(0xFF28C76F).withOpacity(0.1)
                                                                  : const Color(0xFFFF0000).withOpacity(0.1);
                                                              final txtColor = isPaid
                                                                  ? const Color(0xFF28C76F)
                                                                  : const Color(0xFFFF0000);
                                                              final txt = isPaid ? 'Paid' : 'Unpaid';
                                                              return Container(
                                                                constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                                                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                                decoration: BoxDecoration(
                                                                  color: bgColor,
                                                                  borderRadius: BorderRadius.circular(16),
                                                                ),
                                                                alignment: Alignment.center,
                                                                child: Text(
                                                                  txt,
                                                                  style: GoogleFonts.inter(color: txtColor, fontWeight: FontWeight.w500, fontSize: 15),
                                                                  overflow: TextOverflow.ellipsis,
                                                                ),
                                                              );
                                                            },
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: report['courier_name'] != null &&
                                                                   report['courier_name'].toString().length > 10
                                                                 ? 113
                                                                 : 98,
                                                            child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 26),
                                                          report['courier_name'] != null && report['courier_name'].toString().isNotEmpty
                                                            ? CourierLogoWidget(
                                                                pngUrl: report['courier_name'].toString(),
                                                                courierId: report['courier_id']?.toString(),
                                                                accountTitle: report['account_title']?.toString(),
                                                                width: 78,
                                                                height: 36,
                                                                fit: BoxFit.contain,
                                                              )
                                                            : const SizedBox(height: 24),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                                                                                  GestureDetector(
                                                          onTap: () {
                                                            _showTrackingDialog(context, report);
                                                          },
                                                            child: Row(
                                                              children: [
                                                                SvgPicture.asset('assets/Tracking.svg', width: 20, height: 20, color: const Color(0xFF007AFF)),
                                                                const SizedBox(width: 0),
                                                                Text('Tracking', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                              ],
                                                            ),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                              ],
                                            ),
                                          ),
                                          const SizedBox(height: 8),
                                        ],
                                      ),
                                    ),
                                  ),
                                );
                              },
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
        bottomNavigationBar: AppBottomBar(
          selectedIndex: 2,
          onHomeTap: () {
            Get.offAll(() => dash.DashboardScreen());
          },
          onMenuTap: () {
            Get.offAll(() => menu.MenuScreen());
          },
          onReportsTap: () {
            Get.offAll(() => report.ReportsScreen());
          },
          onOrderListTap: () {
            Get.to(() => OrderListScreen(from: 'courier_insights'));
          },
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        floatingActionButton: MediaQuery.of(context).viewInsets.bottom == 0
            ? FloatingActionButton(
                onPressed: () {
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(builder: (_) => CreateOrderScreen(from: 'courier_insights')),
                    (route) => false,
                  );
                },
                backgroundColor: const Color(0xFF0A253B),
                elevation: 4,
                shape: const CircleBorder(),
                child: SvgPicture.asset(
                  'assets/Create Order.svg',
                  width: 28,
                  height: 28,
                  color: Colors.white,
                ),
              )
            : null,
      ),
    );
  }
}

Widget _insightDetailRow(String label, String value) {
  return Padding(
    padding: const EdgeInsets.only(bottom: 4),
    child: Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Expanded(
          flex: 2,
          child: Align(
            alignment: Alignment.centerLeft,
            child: Text(label, style: const TextStyle(fontWeight: FontWeight.w400, fontFamily: 'SF Pro Display', fontSize: 15)),
          ),
        ),
        Expanded(
          flex: 3,
          child: Align(
            alignment: Alignment.center,
            child: Text(value, style: const TextStyle(fontWeight: FontWeight.w300, fontFamily: 'SF Pro Display', fontSize: 15)),
          ),
        ),
      ],
    ),
  );
}

Widget _courierLogoOrText(String courierName) {
  final normalized = courierName.trim().toLowerCase().replaceAll(' ', '').replaceAll('-', '').replaceAll('_', '');
  final assetMap = {
    'blueex': 'assets/icon/bluex.jpeg',
    'tcs': 'assets/icon/tcs.png',
    
  };
  final asset = assetMap[normalized];
  if (asset != null) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: Image.asset(asset, height: 24, width: 60, fit: BoxFit.contain),
    );
  }
  return Text(courierName, style: const TextStyle(fontWeight: FontWeight.w400, fontFamily: 'SF Pro Display', fontSize: 15));
}

String _formatDate(dynamic dateString) {
  if (dateString == null || dateString.toString().isEmpty || dateString == '--') return '-';
  try {
    final date = DateTime.parse(dateString.toString().split(' ')[0]);
    return '${date.day}-${date.month}-${date.year}';
  } catch (e) {
    return dateString.toString();
  }
} 

Widget _defListRowInsights(String label, dynamic value) {
  return Row(
    crossAxisAlignment: CrossAxisAlignment.center,
    children: [
      SizedBox(
        width: 100,
        child: Text(label, style: TextStyle(fontWeight: FontWeight.w400, fontSize: 14, color: Colors.black)),
      ),
      const SizedBox(width: 36), 
      Expanded(
        child: Align(
          alignment: Alignment.centerLeft,
          child: Text(value?.toString() ?? '', style: TextStyle(fontWeight: FontWeight.w300, fontSize: 14)),
        ),
      ),
    ],
  );
}

// Status color functions for courier insights
Color _statusColor(String? status) {
  final s = status?.toLowerCase().trim();
  
  // Comprehensive status color mapping
  if (s == 'cancelled' || s == 'deleted') return const Color(0xFF464646);
  if (s == 'booked') return const Color(0xFF8e24aa); 
  if (s == 'new') return const Color(0xFF1DA1F2); 
  if (s == 'pickup ready') return const Color(0xFF43A047); 
  if (s == 'in transit') return const Color(0xFFea7317);
  if (s == 'out for delivery') return const Color(0xFFf2d016);
  if (s == 'delivered') return const Color(0xFF15ad38);
  if (s == 'shipped') return const Color(0xFF4191ff);
  if (s == 'onroute') return const Color(0xFFf2d016);
  
  if (s == 'accepted') return const Color(0xFF9b51e0);
  if (s == 'rejected') return const Color(0xFFff7400);
  if (s == 'returned') return const Color(0xFFf83245);
  if (s == 'replacement') return const Color(0xFF66cccc);
  if (s == 'error' || s == 'badge-error') return const Color(0xFFf64e60);
  
  // Default color for unknown statuses
  return const Color(0xFF8e24aa);
}

Color _statusTextColor(Color bg) {
  final brightness = ThemeData.estimateBrightnessForColor(bg);
  return brightness == Brightness.light ? Colors.black : Colors.white;
}

Color _statusBackgroundColor(String? status) {
  final s = status?.toLowerCase().trim();
  
  // Background colors matching the CSS scheme
  if (s == 'cancelled' || s == 'deleted') return const Color(0xFF46464629);
  if (s == 'booked') return const Color(0xFF8e24aa); 
  if (s == 'new') return const Color(0xFF1DA1F2); 
  if (s == 'pickup ready') return const Color(0xFF43A047); 
  if (s == 'in transit') return const Color(0xFFf3b98cad);
  if (s == 'out for delivery') return const Color(0xFFf2d01636);
  if (s == 'delivered') return const Color(0xFF1bc9432b);
  if (s == 'shipped') return const Color(0xFF4191ff2e);
  if (s == 'onroute') return const Color(0xFFf2d01636);
  if (s == 'accepted') return const Color(0xFF9b51e029);
  if (s == 'rejected') return const Color(0xFFff740036);
  if (s == 'returned') return const Color(0xFFf832452e);
  if (s == 'replacement') return const Color(0xFF66cccc2e);
  if (s == 'error' || s == 'badge-error') return const Color(0xFFffe2e6);
  
  // Default background color for unknown statuses
  return const Color(0xFF1DA1F2);
} 

 import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import '../controllers/courier_performance_controller.dart';
import '../models/courier_performance_model.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../widgets/custom_date_selector.dart';
import '../utils/custom_snackbar.dart';
import '../widgets/courier_logo_widget.dart';

import 'dashboard_screen.dart';
import 'report.dart';
import 'order_list_screen.dart';
import 'create_order.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter/widgets.dart';
import 'load_sheet_screen.dart';




class CourierPerformanceScreen extends StatefulWidget {
  const CourierPerformanceScreen({Key? key}) : super(key: key);

  @override
  State<CourierPerformanceScreen> createState() => _CourierPerformanceScreenState();
}

class _CourierPerformanceScreenState extends State<CourierPerformanceScreen> {
  final CourierPerformanceController controller = Get.put(CourierPerformanceController());
  bool _isRefreshing = false;
  String _errorMessage = '';
  Map<String, String?>? _activeFilters;

  
  static Map<String, dynamic>? _lastParams;
  static CourierPerformanceModel? _cachedPerformanceData;

  String _formatToTwoDecimals(String? value) {
    try {
      if (value == null) return '0.00';
      final normalized = value.replaceAll(',', '').trim();
      final parsed = double.tryParse(normalized);
      if (parsed == null) return '0.00';
      return parsed.toStringAsFixed(2);
    } catch (_) {
      return '0.00';
    }
  }

  @override
  void initState() {
    super.initState();
    _fetchPerformance();
  }

  Future<void> _fetchPerformance() async {
    
    final params = {
      'courierId': _activeFilters?['courier_id'],
      'customerCourierId': _activeFilters?['customer_courier_id'],
    };
    
    if (_lastParams != null && _cachedPerformanceData != null &&
        _lastParams!['courierId'] == params['courierId'] &&
        _lastParams!['customerCourierId'] == params['customerCourierId']) {
      
      controller.performanceData.value = _cachedPerformanceData;
      controller.errorMessage.value = '';
      controller.isLoading.value = false;
      setState(() {
        _errorMessage = '';
      });
      return;
    }

    setState(() {
      _errorMessage = '';
    });
    try {
      
      String? courierId;
      String? customerCourierId;
      if (_activeFilters != null) {
        courierId = _activeFilters!['courier_id'];
        customerCourierId = _activeFilters!['customer_courier_id'];
      }

      await controller.fetchCourierPerformance(
        courierId: courierId,
        customerCourierId: customerCourierId,
      );
      
      
      _lastParams = params;
      _cachedPerformanceData = controller.performanceData.value;
      
      setState(() {
        _errorMessage = controller.errorMessage.value;
      });
    } catch (e) {
      setState(() {
        _errorMessage = e.toString();
      });
    }
  }

  Future<void> _manualRefresh() async {
    setState(() => _isRefreshing = true);
    await _fetchPerformance();
    setState(() => _isRefreshing = false);
  }

  @override
  Widget build(BuildContext context) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: [SystemUiOverlay.top, SystemUiOverlay.bottom]);

        return ConnectivityWrapper(
          showOfflineUI: true,
          child: AnnotatedRegion<SystemUiOverlayStyle>(
            value: const SystemUiOverlayStyle(
              statusBarColor: Colors.white,
              statusBarIconBrightness: Brightness.dark,
              statusBarBrightness: Brightness.light,
              systemNavigationBarColor: Colors.white,
              systemNavigationBarIconBrightness: Brightness.dark,
            ),
            child: Scaffold(
            backgroundColor: Colors.white,
            extendBody: true,
            appBar: AppBar(
              backgroundColor: Colors.white,
             
              foregroundColor: Colors.black,
              surfaceTintColor: Colors.white,
              elevation: 0,
              leading: IconButton(
                icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
                onPressed: () => Get.offAll(() => ReportsScreen()),
              ),
              title: const Text(
                'Courier Performance',
                style: TextStyle(
                  fontFamily: 'SF Pro Display',
                  fontWeight: FontWeight.w600,
                  fontSize: 20,
                  color: Colors.black,
                ),
              ),
              centerTitle: false,
              bottom: PreferredSize(
                preferredSize: Size.fromHeight(1),
                child: Container(
                  height: 1,
                  color: Colors.grey[300],
                ),
              ),
              actions: [
                IconButton(
              icon: SvgPicture.asset('assets/Filter.svg', width: 24, height: 24, color: Colors.black),
              onPressed: () async {
                final result = await Navigator.push<Map<String, String?>>(
                  context,
                  MaterialPageRoute(
                    fullscreenDialog: true,
                    builder: (context) => LoadSheetFilterScreen(
                      initialCourier: _activeFilters == null ? null : Map<String, String?>.from(_activeFilters!),
                      onApply: (courier) {
                        setState(() {
                          _activeFilters = courier;
                        });
                        _fetchPerformance();
                      },
                      onReset: () {
                        setState(() {
                          _activeFilters = null;
                        });
                        _fetchPerformance();
                        customSnackBar('Success', 'Filters cleared');
                      },
                    ),
                  ),
                );
                if (result != null) {
                  setState(() {
                    _activeFilters = result;
                  });
                  await _fetchPerformance();
                }
              },
            ),
            IconButton(
              icon: SvgPicture.asset('assets/Calender.svg', width: 24, height: 24),
                  onPressed: () async {
                    final picked = await showModalBottomSheet<DateTimeRange>(
                      context: context,
                      isScrollControlled: true,
                      backgroundColor: Colors.transparent,
                      builder: (context) => Container(
                        width: MediaQuery.of(context).size.width,
                        height: MediaQuery.of(context).size.height * 0.6,
                        decoration: const BoxDecoration(
                          color: Colors.white,
                          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                        ),
                        child: CustomDateSelector(
                          initialStartDate: DateTime.parse(controller.selectedStartDate.value),
                          initialEndDate: DateTime.parse(controller.selectedEndDate.value),
                        ),
                      ),
                    );
                    if (picked != null) {
                      final start = '${picked.start.year}-${picked.start.month.toString().padLeft(2, '0')}-${picked.start.day.toString().padLeft(2, '0')}';
                      final end = '${picked.end.year}-${picked.end.month.toString().padLeft(2, '0')}-${picked.end.day.toString().padLeft(2, '0')}';
                      controller.updateDateRange(start, end);
                  await _fetchPerformance();
                    }
                  },
                ),
              ],
            ),
        body: Obx(() => controller.isLoading.value && !_isRefreshing
            ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
            : _isRefreshing
                ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
                : _errorMessage.isNotEmpty
                    ? const Center(child: Text('No performance data found.'))
                    : SingleChildScrollView(
                        physics: const AlwaysScrollableScrollPhysics(),
                        padding: const EdgeInsets.all(11),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                            
                            if (_activeFilters != null && (_activeFilters!['courier_name']?.toString().isNotEmpty ?? false)) ...[
                              const SizedBox(height: 8),
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                decoration: BoxDecoration(
                                  color: Colors.blue.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(8),
                                  border: Border.all(color: Colors.blue.withOpacity(0.3)),
                                ),
                                child: Row(
                                  children: [
                                    Icon(Icons.filter_list_rounded, size: 16, color: Colors.blue[700]),
                                    const SizedBox(width: 8),
                                    Expanded(
                                      child: Text(
                                        'Courier: ${_activeFilters!['courier_name']}',
                                        style: TextStyle(
                                          fontSize: 12,
                                          color: Colors.blue[700],
                                          fontWeight: FontWeight.w500,
                                        ),
                                      ),
                                    ),
                                    GestureDetector(
                                      onTap: () {
                                        setState(() {
                                          _activeFilters = null;
                                        });
                                        _fetchPerformance();
                                        customSnackBar('Success', 'Filters cleared');
                                      },
                                      child: Icon(Icons.clear_rounded, size: 16, color: Colors.blue[700]),
                                    ),
                                  ],
                                ),
                              ),
                            ],
                      Padding(
                        padding: const EdgeInsets.only(bottom: 2, top: 2),
                        child: Text(
                          _getDateRangeFormatted(controller),
                          style: TextStyle(
                            fontSize: 13,
                            fontWeight: FontWeight.w400,
                            color: Colors.grey,
                          ),
                        ),
                      ),
                                                                    _buildSummaryCards(controller),
                       const SizedBox(height: 20),
                       _buildCourierWiseTable(controller),
                       const SizedBox(height: 20),
                       _buildProvinceWiseTable(controller),
                       const SizedBox(height: 20),
                       _buildCodAmountSummary(controller),
                      const SizedBox(height: 120), 
                    ],
                  ),
                      )),
            bottomNavigationBar: AppBottomBar(
              selectedIndex: 2,
              onOrderListTap: () => Get.to(() => OrderListScreen(from: 'courier_performance')),
            ),
            floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
            floatingActionButton: FloatingActionButton(
              onPressed: () {
                Get.to(() => CreateOrderScreen(from: 'courier_performance'));
              },
              backgroundColor: const Color(0xFF0A253B),
              elevation: 4,
              shape: const CircleBorder(),
                child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
            ),
          ),
        ),
    );
  }

  String _getDateRangeFormatted(CourierPerformanceController controller) {
    String format(String d) {
      final parts = d.split('-');
      if (parts.length == 3) {
        return '${parts[2]}-${parts[1]}-${parts[0]}';
      }
      return d;
    }
    return '${format(controller.selectedStartDate.value)} to ${format(controller.selectedEndDate.value)}';
  }

  Widget _buildDateFilter(CourierPerformanceController controller) {
    return Container(
      padding: const EdgeInsets.all(6),
      decoration: BoxDecoration(
        color: const Color(0xFFF8F9FA),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey[300]!),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Date Range',
            style: GoogleFonts.inter(
              fontWeight: FontWeight.w500,
              fontSize: 16,
              color: Colors.black,
            ),
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: GestureDetector(
                  onTap: () async {
                    final date = await showDatePicker(
                      context: Get.context!,
                      initialDate: DateTime.parse(controller.selectedStartDate.value),
                      firstDate: DateTime(2020),
                      lastDate: DateTime.now(),
                    );
                    if (date != null) {
                      final formattedDate = '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
                      controller.updateDateRange(formattedDate, controller.selectedEndDate.value);
                    }
                  },
                  child: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey[300]!),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Start Date',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[600],
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          controller.selectedStartDate.value,
                          style: const TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: GestureDetector(
                  onTap: () async {
                    final date = await showDatePicker(
                      context: Get.context!,
                      initialDate: DateTime.parse(controller.selectedEndDate.value),
                      firstDate: DateTime(2020),
                      lastDate: DateTime.now(),
                    );
                    if (date != null) {
                      final formattedDate = '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
                      controller.updateDateRange(controller.selectedStartDate.value, formattedDate);
                    }
                  },
                  child: Container(
                    padding: const EdgeInsets.all(6),
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey[300]!),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'End Date',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[600],
                          ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          controller.selectedEndDate.value,
                          style: const TextStyle(
                            fontSize: 14,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSummaryCards(CourierPerformanceController controller) {
    final summary = controller.courierwiseSummary;
    if (summary.isEmpty) return const SizedBox.shrink();

    int totalBooked = 0;
    int totalDelivered = 0;
    int totalFailed = 0;
    double totalAmount = 0;

    for (var item in summary) {
      totalBooked += int.tryParse(item.bookedOrders) ?? 0;
      totalDelivered += int.tryParse(item.deliveredOrders) ?? 0;
      totalFailed += int.tryParse(item.failedOrders) ?? 0;
      totalAmount += double.tryParse(item.bookedAmount.replaceAll(',', '')) ?? 0;
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Summary',
          style: GoogleFonts.inter(
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: Colors.black,
          ),
        ),
        const SizedBox(height: 6),
        Container(
          width: double.infinity,
          margin: const EdgeInsets.only(top: 6, bottom: 6),
          padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 8),
                     decoration: BoxDecoration(
             color: const Color(0xFFE6F1FF),
             borderRadius: BorderRadius.circular(12),
           ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              _SummaryColumn(label: 'Total Orders', value: totalBooked.toString()),
              _SummaryColumn(label: 'Delivered', value: totalDelivered.toString()),
              _SummaryColumn(label: 'Failed', value: totalFailed.toString()),
              _SummaryColumn(label: 'Amount', value: 'Rs. ${totalAmount.toStringAsFixed(2)}'),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildCodAmountSummary(CourierPerformanceController controller) {
    final summary = controller.courierwiseSummary;
    if (summary.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'COD Amount wise Summary',
          style: GoogleFonts.inter(
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: Colors.black,
          ),
        ),
        const SizedBox(height: 12),
        Container(
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey[300]!),
            borderRadius: BorderRadius.circular(8),
          ),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
                         child: DataTable(
               columnSpacing: 16,
               headingRowColor: MaterialStateProperty.all(const Color(0xFFE6F1FF)),
               columns: const [
                 DataColumn(label: Text('COURIER')),
                 DataColumn(label: Text('BOOKED')),
                 DataColumn(label: Text('ARRIVED')),
                 DataColumn(label: Text('INPROCESS')),
                 DataColumn(label: Text('FAILED ATTEMPT')),
                 DataColumn(label: Text('DELIVERED')),
                 DataColumn(label: Text('RETURN')),
               ],
              rows: summary.map((item) {
                return DataRow(
                  cells: [
                    DataCell(
                      _buildCourierIcon(item.courierName),
                    ),
                    DataCell(
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            item.bookedOrders,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                          Text(
                            '(${_formatToTwoDecimals(item.bookedAmount)})',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                    DataCell(
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            item.arrivedOrders,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                          Text(
                            '(${_formatToTwoDecimals(item.arrivedAmount ?? '0.00')})',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                    DataCell(
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            item.inprocessOrders,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                          Text(
                            '(${_formatToTwoDecimals(item.inprocessAmount ?? '0.00')})',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                    DataCell(
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            item.failedOrders,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                          Text(
                            '(${_formatToTwoDecimals(item.failedAmount ?? '0.00')})',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                    DataCell(
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            item.deliveredOrders,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                          Text(
                            '(${_formatToTwoDecimals(item.deliveredAmount ?? '0.00')})',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                    DataCell(
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text(
                            item.returnedOrders,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                          Text(
                            '(${_formatToTwoDecimals(item.returnedAmount ?? '0.00')})',
                            style: TextStyle(
                              fontSize: 11,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildCourierWiseTable(CourierPerformanceController controller) {
    final summary = controller.courierwiseSummary;
    if (summary.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Courier Performance',
          style: GoogleFonts.inter(
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: Colors.black,
          ),
        ),
        const SizedBox(height: 12),
        Container(
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey[300]!),
            borderRadius: BorderRadius.circular(8),
          ),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
                         child: DataTable(
               columnSpacing: 20,
               headingRowColor: MaterialStateProperty.all(const Color(0xFFE6F1FF)),
               columns: const [
                 DataColumn(label: Text('Courier')),
                 DataColumn(label: Text('Booked')),
                 DataColumn(label: Text('Arrived')),
                 DataColumn(label: Text('Delivered')),
                 DataColumn(label: Text('Failed')),
                 DataColumn(label: Text('In Process')),
                 DataColumn(label: Text('Returned')),
                 DataColumn(label: Text('Success %')),
                 DataColumn(label: Text('Failed %')),
                 DataColumn(label: Text('In Process %')),
                 DataColumn(label: Text('Avg Days')),
               ],
              rows: summary.map((item) {
                return DataRow(
                  cells: [
                    DataCell(
                      _buildCourierIcon(item.courierName),
                    ),
                    DataCell(Text(item.bookedOrders)),
                    DataCell(Text(item.arrivedOrders)),
                    DataCell(Text(item.deliveredOrders)),
                    DataCell(Text(item.failedOrders)),
                    DataCell(Text(item.inprocessOrders)),
                    DataCell(Text(item.returnedOrders)),
                    DataCell(
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 2),
                        decoration: BoxDecoration(
                          color: (double.tryParse(item.successRate) ?? 0) >= 80 ? Colors.green[100] : 
                                 (double.tryParse(item.successRate) ?? 0) >= 60 ? Colors.orange[100] : Colors.red[100],
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Text(
                          '${item.successRate}%',
                          style: TextStyle(
                            color: (double.tryParse(item.successRate) ?? 0) >= 80 ? Colors.green[700] : 
                                   (double.tryParse(item.successRate) ?? 0) >= 60 ? Colors.orange[700] : Colors.red[700],
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ),
                    DataCell(Text('${item.failedRate}%')),
                    DataCell(Text('${item.inprocessRate}%')),
                    DataCell(Text('${item.avgDeliveryDays} days')),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildDeliveryTimeChart(CourierPerformanceController controller) {
    final avgDeliveryGraph = controller.avgDeliveryGraph;
    if (avgDeliveryGraph.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Average Delivery Time',
          style: GoogleFonts.inter(
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: Colors.black,
          ),
        ),
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.all(7),
          decoration: BoxDecoration(
            color: const Color(0xFFF8F9FA),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey[300]!),
          ),
          child: Column(
            children: avgDeliveryGraph.entries.map((entry) {
              final courierName = entry.key;
              final avgDays = entry.value.avgDays;
              
                             return Padding(
                 padding: const EdgeInsets.symmetric(vertical: 4),
                 child: Row(
                   children: [
                     _buildCourierIconLarge(courierName),
                     const SizedBox(width: 12),
                     Expanded(
                       child: Container(
                         padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
                         decoration: BoxDecoration(
                           color: avgDays <= 2 ? Colors.green[100] : 
                                  avgDays <= 4 ? Colors.orange[100] : Colors.red[100],
                           borderRadius: BorderRadius.circular(16),
                         ),
                         child: Text(
                           '$avgDays days',
                           style: TextStyle(
                             color: avgDays <= 2 ? Colors.green[700] : 
                                    avgDays <= 4 ? Colors.orange[700] : Colors.red[700],
                             fontWeight: FontWeight.w600,
                           ),
                         ),
                       ),
                     ),
                   ],
                 ),
               );
            }).toList(),
          ),
        ),
      ],
    );
  }

  Widget _buildSuccessRateChart(CourierPerformanceController controller) {
    final rateGraph = controller.rateGraph;
    if (rateGraph.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Success Rates',
          style: GoogleFonts.inter(
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: Colors.black,
          ),
        ),
        const SizedBox(height: 12),
        Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: const Color(0xFFF8F9FA),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey[300]!),
          ),
          child: Column(
            children: rateGraph.entries.map((entry) {
              final courierName = entry.key;
              final rates = entry.value;
              
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        _buildCourierIconLarge(courierName),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        Expanded(
                          child: _buildProgressBar('Success', rates.successRate, Colors.green),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: _buildProgressBar('Failed', rates.failedRate, Colors.red),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: _buildProgressBar('In Process', rates.inprocessRate, Colors.orange),
                        ),
                      ],
                    ),
                  ],
                ),
              );
            }).toList(),
          ),
        ),
      ],
    );
  }

  Widget _buildProgressBar(String label, int percentage, Color color) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
        const SizedBox(height: 4),
        Container(
          height: 8,
          decoration: BoxDecoration(
            color: Colors.grey[300],
            borderRadius: BorderRadius.circular(4),
          ),
          child: FractionallySizedBox(
            alignment: Alignment.centerLeft,
            widthFactor: percentage / 100,
            child: Container(
              decoration: BoxDecoration(
                color: color,
                borderRadius: BorderRadius.circular(4),
              ),
            ),
          ),
        ),
        const SizedBox(height: 2),
        Text(
          '$percentage%',
          style: TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w500,
            color: color,
          ),
        ),
      ],
    );
  }

  Widget _buildProvinceWiseTable(CourierPerformanceController controller) {
    final summary = controller.provincewiseSummary;
    if (summary.isEmpty) return const SizedBox.shrink();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Regional Performance by Courier',
          style: GoogleFonts.inter(
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: Colors.black,
          ),
        ),
        const SizedBox(height: 12),
        Container(
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey[300]!),
            borderRadius: BorderRadius.circular(8),
          ),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
                         child: DataTable(
               columnSpacing: 16,
               headingRowColor: MaterialStateProperty.all(const Color(0xFFE6F1FF)),
               columns: const [
                 DataColumn(label: Text('Courier')),
                 DataColumn(label: Text('Province')),
                 DataColumn(label: Text('Booked')),
                 DataColumn(label: Text('Arrived')),
                 DataColumn(label: Text('Delivered')),
                 DataColumn(label: Text('Failed')),
                 DataColumn(label: Text('In Process')),
                 DataColumn(label: Text('Returned')),
                 DataColumn(label: Text('Success %')),
                 DataColumn(label: Text('Failed %')),
                 DataColumn(label: Text('In Process %')),
                 DataColumn(label: Text('Avg Days')),
               ],
              rows: summary.map((item) {
                return DataRow(
                  cells: [
                    DataCell(
                      _buildCourierIcon(item.courierName),
                    ),
                    DataCell(Text(item.provinceName)),
                    DataCell(Text(item.bookedOrders)),
                    DataCell(Text(item.arrivedOrders)),
                    DataCell(Text(item.deliveredOrders)),
                    DataCell(Text(item.failedOrders)),
                    DataCell(Text(item.inprocessOrders)),
                    DataCell(Text(item.returnedOrders)),
                    DataCell(
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 2),
                        decoration: BoxDecoration(
                          color: (double.tryParse(item.successRate ?? '0') ?? 0) >= 80 ? Colors.green[100] : 
                                 (double.tryParse(item.successRate ?? '0') ?? 0) >= 60 ? Colors.orange[100] : Colors.red[100],
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Text(
                          item.successRate ?? '0%',
                          style: TextStyle(
                            color: (double.tryParse(item.successRate ?? '0') ?? 0) >= 80 ? Colors.green[700] : 
                                   (double.tryParse(item.successRate ?? '0') ?? 0) >= 60 ? Colors.orange[700] : Colors.red[700],
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ),
                    DataCell(Text(item.failedRate ?? '0%')),
                    DataCell(Text(item.inprocessRate ?? '0%')),
                    DataCell(Text(item.avgDeliveryDays ?? '0 days')),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildCourierIcon(String courierName) {
    return CourierLogoWidget(
      pngUrl: courierName,
      courierId: null, 
      accountTitle: null, 
      width: 48,
      height: 48,
      fit: BoxFit.contain,
    );
  }

  Widget _buildCourierIconLarge(String courierName) {
    return CourierLogoWidget(
      pngUrl: courierName,
      courierId: null, 
      accountTitle: null, 
      width: 64,
      height: 64,
      fit: BoxFit.contain,
    );
  }

  
  static void clearAllCourierPerformanceCaches() {
    _CourierPerformanceScreenState._lastParams = null;
    _CourierPerformanceScreenState._cachedPerformanceData = null;
  }
}

class _SummaryColumn extends StatelessWidget {
  final String label;
  final String value;
  const _SummaryColumn({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(
          value, 
          style: const TextStyle(
            fontFamily: 'SF Pro Display', 
            fontWeight: FontWeight.w700, 
            fontSize: 16, 
            color: Colors.black
          )
        ),
        const SizedBox(height: 2),
        Text(
          label, 
          style: const TextStyle(
            fontFamily: 'SF Pro Display', 
            fontWeight: FontWeight.w400, 
            fontSize: 13, 
            color: Color(0xFF8E8E93)
          )
        ),
      ],
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'sign_in_screen.dart';
import 'package:google_fonts/google_fonts.dart';

class CreateAccountController extends GetxController {
  var obscurePassword = true.obs;
  var obscureRePassword = true.obs;
  var agreedToTerms = false.obs;
  
  
  final emailController = TextEditingController();
  final fullNameController = TextEditingController();
  final phoneController = TextEditingController();
  final passwordController = TextEditingController();
  final rePasswordController = TextEditingController();
  
  
  final emailError = false.obs;
  final fullNameError = false.obs;
  final phoneError = false.obs;
  final passwordError = false.obs;
  final rePasswordError = false.obs;
  
  
  final emailErrorMessage = ''.obs;
  final fullNameErrorMessage = ''.obs;
  final phoneErrorMessage = ''.obs;
  final passwordErrorMessage = ''.obs;
  final rePasswordErrorMessage = ''.obs;
  
  @override
  void onClose() {
    emailController.dispose();
    fullNameController.dispose();
    phoneController.dispose();
    passwordController.dispose();
    rePasswordController.dispose();
    super.onClose();
  }
  
  Future<void> createAccount() async {
    
    Get.focusScope?.unfocus();
    
    
    emailError.value = false;
    fullNameError.value = false;
    phoneError.value = false;
    passwordError.value = false;
    rePasswordError.value = false;
    emailErrorMessage.value = '';
    fullNameErrorMessage.value = '';
    phoneErrorMessage.value = '';
    passwordErrorMessage.value = '';
    rePasswordErrorMessage.value = '';
    
    final email = emailController.text.trim();
    final fullName = fullNameController.text.trim();
    final phone = phoneController.text.trim();
    final password = passwordController.text;
    final rePassword = rePasswordController.text;
    
    
    final emailValid = RegExp(r"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}").hasMatch(email);
    bool hasError = false;
    
    
    if (email.isEmpty) {
      emailError.value = true;
      emailErrorMessage.value = 'Email is required';
      hasError = true;
    } else if (!emailValid) {
      emailError.value = true;
      emailErrorMessage.value = 'Invalid email';
      hasError = true;
    }
    
    
    if (fullName.isEmpty) {
      fullNameError.value = true;
      fullNameErrorMessage.value = 'Full name is required';
      hasError = true;
    }
    
    
    if (phone.isEmpty) {
      phoneError.value = true;
      phoneErrorMessage.value = 'Phone number is required';
      hasError = true;
    }
    
    
    if (password.isEmpty) {
      passwordError.value = true;
      passwordErrorMessage.value = 'Password is required';
      hasError = true;
    } else if (password.length < 6) {
      passwordError.value = true;
      passwordErrorMessage.value = 'Password must be at least 6 characters';
      hasError = true;
    }
    
    
    if (rePassword.isEmpty) {
      rePasswordError.value = true;
      rePasswordErrorMessage.value = 'Please re-enter your password';
      hasError = true;
    } else if (password != rePassword) {
      rePasswordError.value = true;
      rePasswordErrorMessage.value = 'Passwords do not match';
      hasError = true;
    }
    
    
    if (!agreedToTerms.value) {
      Get.snackbar(
        'Error!',
        'Please agree to the Privacy Policy and Terms and Conditions',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red,
        colorText: Colors.white,
        margin: const EdgeInsets.all(16),
        borderRadius: 12,
      );
      return;
    }
    
    if (hasError) {
      return; 
    }
    
    
    Get.snackbar(
      'Success!',
      'Account created successfully!',
      snackPosition: SnackPosition.BOTTOM,
      backgroundColor: Colors.green,
      colorText: Colors.white,
      margin: const EdgeInsets.all(16),
      borderRadius: 12,
    );
  }
}

class CreateAccountScreen extends StatelessWidget {
  CreateAccountScreen({Key? key}) : super(key: key);
  final CreateAccountController controller = Get.put(CreateAccountController());

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    final width = size.width;
    final height = size.height;
    
    double blockH = height / 100;
    double blockW = width / 100;

    
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
    ));

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: SingleChildScrollView(
          physics: const BouncingScrollPhysics(),
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: blockW * 6),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                SizedBox(height: blockH * 14),
                Text(
                  'Create Account',
                  style: GoogleFonts.poppins(
                    fontWeight: FontWeight.w700,
                    fontSize: blockW * 8.2, 
                    color: Colors.black,
                  ),
                  textAlign: TextAlign.center,
                ),
                SizedBox(height: blockH * 2),
                Obx(() => _buildTextField(
                  context,
                  'Email',
                  controller: controller.emailController,
                  keyboardType: TextInputType.emailAddress,
                  hasError: controller.emailError.value,
                )),
                if (controller.emailError.value)
                  Padding(
                    padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                    child: Obx(() => Text(
                      controller.emailErrorMessage.value,
                      style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                    )),
                  ),
                SizedBox(height: blockH * 1),
                Obx(() => _buildTextField(
                  context,
                  'Full Name',
                  controller: controller.fullNameController,
                  hasError: controller.fullNameError.value,
                )),
                if (controller.fullNameError.value)
                  Padding(
                    padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                    child: Obx(() => Text(
                      controller.fullNameErrorMessage.value,
                      style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                    )),
                  ),
                SizedBox(height: blockH * 1),
                Obx(() => _buildTextField(
                  context,
                  'Phone Number',
                  controller: controller.phoneController,
                  keyboardType: TextInputType.phone,
                  hasError: controller.phoneError.value,
                )),
                if (controller.phoneError.value)
                  Padding(
                    padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                    child: Obx(() => Text(
                      controller.phoneErrorMessage.value,
                      style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                    )),
                  ),
                SizedBox(height: blockH * 1),
                Obx(() => _buildTextField(
                  context,
                  'Password',
                  controller: controller.passwordController,
                  obscureText: controller.obscurePassword.value,
                  hasError: controller.passwordError.value,
                  suffixIcon: IconButton(
                    icon: Icon(
                      controller.obscurePassword.value ? Icons.visibility_off_rounded : Icons.visibility_rounded,
                      color: Colors.black,
                      size: blockW * 6,
                    ),
                    onPressed: () => controller.obscurePassword.value = !controller.obscurePassword.value,
                  ),
                )),
                if (controller.passwordError.value)
                  Padding(
                    padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                    child: Obx(() => Text(
                      controller.passwordErrorMessage.value,
                      style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                    )),
                  ),
                SizedBox(height: blockH * 1),
                Obx(() => _buildTextField(
                  context,
                  'Re-Enter Password',
                  controller: controller.rePasswordController,
                  obscureText: controller.obscureRePassword.value,
                  hasError: controller.rePasswordError.value,
                  suffixIcon: IconButton(
                    icon: Icon(
                      controller.obscureRePassword.value ? Icons.visibility_off_rounded : Icons.visibility_rounded,
                      color: Colors.black,
                      size: blockW * 6,
                    ),
                    onPressed: () => controller.obscureRePassword.value = !controller.obscureRePassword.value,
                  ),
                )),
                if (controller.rePasswordError.value)
                  Padding(
                    padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                    child: Obx(() => Text(
                      controller.rePasswordErrorMessage.value,
                      style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                    )),
                  ),
                SizedBox(height: blockH * 0.8),
                Obx(() => Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Checkbox(
                      value: controller.agreedToTerms.value,
                      onChanged: (val) => controller.agreedToTerms.value = val ?? false,
                      activeColor: const Color(0xFF007AFF),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      visualDensity: VisualDensity.compact,
                    ),
                    SizedBox(width: blockW * 1),
                    Expanded(
                      child: Padding(
                        padding: EdgeInsets.only(top: blockH * 0.2),
                        child: Text(
                          'I have read and agreed to the Privacy Policy and Terms and Conditions',
                          style: GoogleFonts.inter(
                            fontWeight: FontWeight.w400,
                            fontSize: 11,
                            color: const Color(0xFF222222),
                          ),
                        ),
                      ),
                    ),
                  ],
                )),
                SizedBox(height: blockH * 1.1),
                SizedBox(
                  height: blockH * 6.2, 
                  child: ElevatedButton(
                    onPressed: controller.createAccount,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(blockW * 2), 
                      ),
                      elevation: 0,
                    ),
                    child: Text(
                      'Create Account',
                      style: GoogleFonts.inter(
                        fontWeight: FontWeight.w600,
                        fontSize: blockW * 4.4, 
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
                SizedBox(height: blockH * 3.1),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      'Already have an account? ',
                      style: GoogleFonts.inter(
                        fontWeight: FontWeight.w400,
                        fontSize: blockW * 3.6, 
                        color: Colors.black,
                      ),
                    ),
                    GestureDetector(
                      onTap: () => Get.to(() => SignInScreen()),
                      child: Text(
                        'Click here to Sign In',
                        style: GoogleFonts.inter(
                          fontWeight: FontWeight.w500,
                          fontSize: blockW * 3.6, 
                          color: const Color(0xFF007AFF),
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    ),
                  ],
                ),
                SizedBox(height: blockH * 2.2),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildTextField(BuildContext context, String hint, {
    bool obscureText = false, 
    Widget? suffixIcon, 
    TextInputType keyboardType = TextInputType.text,
    TextEditingController? controller,
    bool hasError = false,
  }) {
    final size = MediaQuery.of(context).size;
    final width = size.width;
    final height = size.height;
    
    double blockH = height / 100;
    double blockW = width / 100;

    return Container(
      decoration: BoxDecoration(
        color: const Color(0xFFF3F3F3),
        borderRadius: BorderRadius.circular(blockW * 2), 
        border: hasError ? Border.all(color: Colors.red, width: 1.5) : null,
      ),
      child: TextField(
        controller: controller,
        obscureText: obscureText,
        keyboardType: keyboardType,
        style: GoogleFonts.inter(
          fontWeight: FontWeight.w400,
          fontSize: blockW * 3.5, 
          color: Colors.black,
        ),
        decoration: InputDecoration(
          hintText: hint,
          hintStyle: GoogleFonts.inter(
            fontWeight: FontWeight.w400,
            fontSize: blockW * 3.5, 
            color: Colors.black,
          ),
          border: InputBorder.none,
          contentPadding: EdgeInsets.symmetric(horizontal: blockW * 4, vertical: blockH * 2.2), 
          suffixIcon: suffixIcon,
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'order_list_screen.dart';
import 'create_order.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../services/statement_service.dart';
import '../services/auth_service.dart';
import '../services/cities_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'package:get/get.dart';
import 'package:dio/dio.dart';
import '../services/courier_service.dart';
import '../models/courier_account.dart';
import '../utils/custom_snackbar.dart';
import '../config/api_config.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';


const Color kBlue = Color(0xFF007AFF);

class _SearchDialog extends StatefulWidget {
  final String title;
  final List<String> options;
  final String? selectedValue;
  final ValueChanged<String> onSelected;

  const _SearchDialog({
    Key? key,
    required this.title,
    required this.options,
    required this.selectedValue,
    required this.onSelected,
  }) : super(key: key);

  @override
  State<_SearchDialog> createState() => _SearchDialogState();
}

class _SearchDialogState extends State<_SearchDialog> {
  late List<String> _filteredOptions;
  final TextEditingController _searchController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _filteredOptions = widget.options;
    if (widget.options.length > 2) {
      _searchController.addListener(() {
        setState(() {
          final query = _searchController.text.toLowerCase();
          _filteredOptions = widget.options.where((option) => option.toLowerCase().contains(query)).toList();
        });
      });
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        if (widget.options.length > 2) ...[
                          const SizedBox(height: 12),
                          TextField(
                            controller: _searchController,
                            decoration: InputDecoration(
                              hintText: 'Search',
                              prefixIcon: const Icon(Icons.search_rounded, color: Colors.grey),
                              border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                              focusedBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: Colors.grey, width: 2)),
                              contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 12),
                            ),
                          ),
                        ],
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 250,
                          child: _filteredOptions.isEmpty
                              ? const Center(child: Text('No options found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: _filteredOptions.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.grey.withOpacity(0.2),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final option = _filteredOptions[i];
                                    final isSelected = option == widget.selectedValue;
                                    return ListTile(
                                      title: Text(option, style: TextStyle(color: isSelected ? Colors.black : Colors.black, fontWeight: isSelected ? FontWeight.bold : FontWeight.normal)),
                                      selected: isSelected,
                                      selectedTileColor: Colors.grey.withOpacity(0.08),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        widget.onSelected(option);
                                        Navigator.of(context).pop();
                                      },
                                      trailing: isSelected ? const Icon(Icons.check_circle, color: Colors.black) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

Widget SearchableField({
  required BuildContext context,
  required String label,
  required String? value,
  required List<String> options,
  required ValueChanged<String> onSelected,
}) {
  return Container(
    margin: const EdgeInsets.only(bottom: 8),
    padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 0),
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.circular(14),
      border: Border.all(color: Colors.grey[300]!, width: 1),
      boxShadow: [
        BoxShadow(
          color: Colors.grey.withOpacity(0.08),
          blurRadius: 8,
          offset: Offset(0, 2),
        ),
      ],
    ),
    child: InkWell(
      onTap: () async {
        final selected = await showModalBottomSheet<String>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (context) => _SearchDialog(
            title: label,
            options: options,
            selectedValue: value,
            onSelected: onSelected,
          ),
        );
        if (selected != null) {
          onSelected(selected);
        }
      },
      borderRadius: BorderRadius.circular(14),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Row(
          children: [
            Expanded(
              child: Text(
                (value == null || value.isEmpty) ? label : value,
                style: GoogleFonts.poppins(
                  fontSize: 15,
                  color: (value == null || value.isEmpty) ? const Color(0xFF6B6B6B) : Colors.black,
                ),
                overflow: TextOverflow.ellipsis,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    ),
  );
}

class _SingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _SingleSelectDialog({Key? key, required this.items, required this.initialValue, required this.title}) : super(key: key);

  @override
  State<_SingleSelectDialog> createState() => _SingleSelectDialogState();
}

class _SingleSelectDialogState extends State<_SingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                         SizedBox(
                           height: 300,
                           child: filteredItems.isEmpty
                               ? const Center(child: Text('No data', style: TextStyle(color: Colors.grey)))
                               : ListView.separated(
                                   itemCount: filteredItems.length,
                                   separatorBuilder: (_, __) => Container(
                                     height: 1,
                                     color: Colors.black.withOpacity(0.08),
                                     margin: const EdgeInsets.symmetric(horizontal: 8),
                                   ),
                                   itemBuilder: (context, i) {
                                     final item = filteredItems[i];
                                     final isSelected = selected == item;
                                     return ListTile(
                                       title: Text(item),
                                       trailing: isSelected
                                           ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                           : null,
                                       onTap: () {
                                         setState(() {
                                           selected = item;
                                         });
                                         Navigator.of(context).pop(item);
                                       },
                                       selected: isSelected,
                                       selectedTileColor: const Color(0xFFE6F0FF),
                                       shape: RoundedRectangleBorder(
                                         borderRadius: BorderRadius.circular(8),
                                       ),
                                     );
                                   },
                                 ),
                         ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class CreateCnScreen extends StatefulWidget {
  final List<dynamic> orders;
  const CreateCnScreen({Key? key, required this.orders}) : super(key: key);

  @override
  State<CreateCnScreen> createState() => _CreateCnScreenState();
}

class _CreateCnScreenState extends State<CreateCnScreen> {
  
  String? selectedAccount = null; 
  String? selectedType = 'Parcel';
  String? selectedFragile = null; 
  String? selectedCourier = null; 
  String? selectedCity = null; 
  String? selectedInsurance = null; 
  List<String> cityList = [];
  bool _isLoadingCities = false;
  final AuthService _authService = Get.find<AuthService>();
  List<CourierAccount> _accounts = [];
  bool _isLoadingAccounts = false;
  final CourierService _courierService = CourierService();

  
  String fragileRequire = ''; 
  String insuranceRequire = ''; 
  String parcelType = ''; 
  bool isSubmitting = false;

  
  List<String> pickupOptions = [];
  String? selectedPickup = null; 
  bool _isLoadingPickup = false;
  String? selectedCityDropdown = null; 
  
  
  List<Map<String, dynamic>> pickupLocationsWithIds = [];
  List<Map<String, dynamic>> citiesWithIds = [];

  
  List<Map<String, dynamic>> serviceCodes = [];
  Map<String, dynamic>? selectedServiceCode;
  bool _isLoadingServiceCodes = false;

  
  int? selectedPickupLocationId;

  bool _isInitialLoading = true;
  int _loadingCount = 0;

  
  bool _showValidationErrors = false;
  Map<String, bool> _fieldErrors = {
    'account': false,
    'pickup': false,
    'serviceCode': false,
    'fragile': false,
    'insurance': false,
    'parcelType': false,
    'city': false,
  };

  @override
  void initState() {
    super.initState();
    _startInitialLoad();
  }

  void _startInitialLoad() async {
    setState(() {
      _isInitialLoading = true;
      _loadingCount = 4; 
    });
    await Future.wait([
      _fetchAccountsWrapper(),
      _fetchCitiesWrapper(),
      _fetchServiceCodesWrapper(),
      _fetchPickupLocationsWrapper(),
    ]);
    setState(() {
      _isInitialLoading = false;
    });
  }

  Future<void> _fetchAccountsWrapper() async {
    await _fetchAccounts();
    setState(() { _loadingCount--; });
  }
  Future<void> _fetchCitiesWrapper() async {
    await _fetchCities();
    setState(() { _loadingCount--; });
  }
  Future<void> _fetchServiceCodesWrapper() async {
    await _fetchServiceCodes();
    setState(() { _loadingCount--; });
  }
  Future<void> _fetchPickupLocationsWrapper() async {
    await _fetchPickupLocations();
    setState(() { _loadingCount--; });
  }

  Future<void> _fetchCities() async {
    setState(() { _isLoadingCities = true; });
    try {
      
      String? destinationCityFromOrder;
      if (widget.orders.isNotEmpty) {
        destinationCityFromOrder = widget.orders.first['destination_city']?.toString();
        
      }

      
      final cachedCities = CitiesService.getCachedCities();
      if (cachedCities != null && cachedCities.isNotEmpty) {
        List<String> cities = [];
        List<Map<String, dynamic>> cityObjs = List<Map<String, dynamic>>.from(cachedCities);
        cities = cachedCities.map<String>((c) => c['name']?.toString() ?? '').where((c) => c.isNotEmpty).toList();
        setState(() {
          cityList = cities;
          citiesWithIds = cityObjs.map((c) => {
            'name': c['name']?.toString() ?? '',
            'id': int.tryParse(c['id']?.toString() ?? '0') ?? 0,
          }).where((c) => c['id'] != 0).toList();
          
          
          if (destinationCityFromOrder != null && cityList.contains(destinationCityFromOrder)) {
            selectedCityDropdown = destinationCityFromOrder;
          } else if (cityList.isNotEmpty && (selectedCityDropdown == null || !cityList.contains(selectedCityDropdown))) {
            selectedCityDropdown = cityList.first;
          }
          _isLoadingCities = false;
        });
        return;
      }
      
      
      final countryId = 1;
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
        data: {"country_id": countryId},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<String> cities = [];
        List<Map<String, dynamic>> cityObjs = [];
        if (data is List) {
          cityObjs = List<Map<String, dynamic>>.from(data);
          cities = data.map<String>((c) => c['city_name']?.toString() ?? '').where((c) => c.isNotEmpty).toList();
        } else if (data is Map && data['payload'] is List) {
          cityObjs = List<Map<String, dynamic>>.from(data['payload']);
          cities = (data['payload'] as List)
              .map<String>((c) => c['city_name']?.toString() ?? '')
              .where((c) => c.isNotEmpty)
              .toList();
        }
        setState(() {
          cityList = cities;
          citiesWithIds = cityObjs.map((c) => {
            'name': c['city_name']?.toString() ?? '',
            'id': int.tryParse(c['city_id']?.toString() ?? '0') ?? 0,
          }).where((c) => c['id'] != 0).toList();
          
          
          if (destinationCityFromOrder != null && cityList.contains(destinationCityFromOrder)) {
            selectedCityDropdown = destinationCityFromOrder;
          } else if (cityList.isNotEmpty && (selectedCityDropdown == null || !cityList.contains(selectedCityDropdown))) {
            selectedCityDropdown = cityList.first;
          }
          _isLoadingCities = false;
        });
      } else {
        setState(() {
          cityList = [];
          selectedCityDropdown = null;
          _isLoadingCities = false;
        });
      }
    } catch (e) {
      setState(() {
        cityList = [];
        selectedCityDropdown = null;
        _isLoadingCities = false;
      });
    }
  }

  Future<void> _fetchAccounts() async {
    setState(() { _isLoadingAccounts = true; });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null || acno.isEmpty) {
        setState(() { _isLoadingAccounts = false; });
        return;
      }
      final accounts = await _courierService.getCourierAccounts(acno);
      setState(() {
        _accounts = accounts;
        
        if (_accounts.any((a) => _accountDropdownValue(a) == selectedAccount)) {
          
        } else {
          selectedAccount = null;
        }
        _isLoadingAccounts = false;
      });
    } catch (e) {
      setState(() { _isLoadingAccounts = false; });
    }
  }

  Future<void> _fetchServiceCodes() async {
    setState(() { _isLoadingServiceCodes = true; });
    try {
      final user = _authService.currentUser.value;
      final acno = user?.acno ?? widget.orders.first['acno'] ?? '';
      
      
      String? courierId;
      String? customerCourierId;
      
      if (selectedAccount != null && selectedAccount != 'Select Your Account') {
        try {
          final selectedAccountObj = _accounts.firstWhere(
            (account) => _accountDropdownValue(account) == selectedAccount,
          );
          courierId = selectedAccountObj.courierId;
          customerCourierId = selectedAccountObj.id;
        } catch (e) {
          
          setState(() {
            serviceCodes = [];
            selectedServiceCode = null;
            _isLoadingServiceCodes = false;
          });
          return;
        }
      } else {
        
        setState(() {
          serviceCodes = [];
          selectedServiceCode = null;
          _isLoadingServiceCodes = false;
        });
        return;
      }
      
      
      if (courierId == null || customerCourierId == null) {
        setState(() {
          serviceCodes = [];
          selectedServiceCode = null;
          _isLoadingServiceCodes = false;
        });
        return;
      }
      
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderGetServiceCodeEndpoint),
        data: {
          "acno": acno,
          "courier_id": int.tryParse(courierId) ?? 1,
          "customer_courier_id": int.tryParse(customerCourierId) ?? 55,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<Map<String, dynamic>> codes = [];
        if (data is Map && data['service_code'] is List) {
          
          final rawList = data['service_code'];
          if (rawList.isNotEmpty && rawList.first is Map && rawList.first.containsKey('service_code')) {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e['service_code']?.toString() ?? '',
              'service_name': e['service_name']?.toString() ?? e['service_code']?.toString() ?? '',
            }));
          } else {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e.toString(),
              'service_name': e.toString(),
            }));
          }
        } else if (data is Map && data['payload'] is List) {
          final rawList = data['payload'];
          if (rawList.isNotEmpty && rawList.first is Map && rawList.first.containsKey('service_code')) {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e['service_code']?.toString() ?? '',
              'service_name': e['service_name']?.toString() ?? e['service_code']?.toString() ?? '',
            }));
          } else {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e.toString(),
              'service_name': e.toString(),
            }));
          }
        }
        setState(() {
          serviceCodes = codes;
          
          if (selectedServiceCode != null && !serviceCodes.any((e) => e['service_code'] == selectedServiceCode!['service_code'])) {
            selectedServiceCode = null;
          }
          _isLoadingServiceCodes = false;
        });
      } else {
        setState(() {
          serviceCodes = [];
          selectedServiceCode = null;
          _isLoadingServiceCodes = false;
        });
      }
    } catch (e) {
      setState(() {
        serviceCodes = [];
        selectedServiceCode = null;
        _isLoadingServiceCodes = false;
      });
    }
  }

  Future<void> _fetchPickupLocations({int? courierId, int? customerCourierId}) async {
    setState(() { _isLoadingPickup = true; });
    try {
      final user = _authService.currentUser.value;
      final acno = user?.acno ?? widget.orders.first['acno'] ?? '';

      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.pickupShowEndpoint),
        data: {
          "acno": acno,
          "courier_id": courierId ?? 1,
          "customer_courier_id": customerCourierId ?? 55,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
     
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<String> pickups = [];
        List<Map<String, dynamic>> pickupLocationsWithIdsList = [];
        if (data is Map && data['pickuplocation'] is List) {
          
          pickups = List<String>.from(data['pickuplocation'].map((e) => e['pickuplocation_name'].toString()));
          pickupLocationsWithIdsList = List<Map<String, dynamic>>.from(data['pickuplocation'].map((e) => {
            'name': e['pickuplocation_name']?.toString() ?? '',
            'id': int.tryParse(e['id']?.toString() ?? '0') ?? 0,
          }).where((p) => p['id'] != 0).toList());
          
        } else if (data is Map && data['payload'] is List) {
          
          pickups = List<String>.from(data['payload'].map((e) => e['pickuplocation_name'].toString()));
          pickupLocationsWithIdsList = List<Map<String, dynamic>>.from(data['payload'].map((e) => {
            'name': e['pickuplocation_name']?.toString() ?? '',
            'id': int.tryParse(e['id']?.toString() ?? '0') ?? 0,
          }).where((p) => p['id'] != 0).toList());
          
        }
        setState(() {
          pickupOptions = pickups;
          pickupLocationsWithIds = pickupLocationsWithIdsList;
          
          if (!pickupOptions.contains(selectedPickup)) {
            selectedPickup = null;
            selectedPickupLocationId = null;
          }
          _isLoadingPickup = false;
        });
      } else {
        
        setState(() {
          pickupOptions = [];
          selectedPickup = null;
          selectedPickupLocationId = null;
          _isLoadingPickup = false;
        });
      }
    } catch (e) {
      print('Error fetching pickup locations: $e');
      setState(() {
        pickupOptions = [];
        selectedPickup = null;
        selectedPickupLocationId = null;
        _isLoadingPickup = false;
      });
    }
  }

  String _accountDropdownValue(CourierAccount account) {
    return '${account.accountTitle} (${account.courierName})';
  }

  
  bool _validateFields() {
    setState(() {
      _fieldErrors['account'] = selectedAccount == null || selectedAccount == 'Select your Account';
      _fieldErrors['pickup'] = selectedPickup == null || selectedPickup!.isEmpty;
              _fieldErrors['serviceCode'] = selectedServiceCode == null;
      _fieldErrors['fragile'] = fragileRequire.isEmpty;
      _fieldErrors['insurance'] = insuranceRequire.isEmpty;
      _fieldErrors['parcelType'] = parcelType.isEmpty;
      _fieldErrors['city'] = selectedCityDropdown == null || selectedCityDropdown!.isEmpty;
      _showValidationErrors = true;
    });

    return !_fieldErrors.values.any((error) => error);
  }

  
  void _clearFieldError(String fieldName) {
    if (_showValidationErrors && _fieldErrors[fieldName] == true) {
      setState(() {
        _fieldErrors[fieldName] = false;
      });
    }
  }

  Future<void> _showCitySearchDialog() async {
    if (_isLoadingCities) return;
    
    
    final selected = await showDialog<String>(
      context: context,
      builder: (context) => _CitySearchDialog(
        cities: cityList,
        initialCity: selectedCityDropdown,
      ),
    );
    if (selected != null) {
      setState(() {
        selectedCityDropdown = selected;
      });
    }
  }

  void _showCnSuccessSheet(BuildContext context, List<String> cnList) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) {
        return DraggableScrollableSheet(
          expand: false,
          initialChildSize: 0.4,
          minChildSize: 0.2,
          maxChildSize: 0.8,
          builder: (context, scrollController) {
            return Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.check_circle, color: Colors.green, size: 48),
                  const SizedBox(height: 16),
                  const Text('CNs Created', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20)),
                  const SizedBox(height: 12),
                  Expanded(
                    child: ListView.builder(
                      controller: scrollController,
                      itemCount: cnList.length,
                      itemBuilder: (context, i) => ListTile(
                        leading: const Icon(Icons.local_shipping, color: Colors.blue),
                        title: Text('CN: ${cnList[i]}'),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Close'),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }

  void _showCnStatusDialog(BuildContext context, List<Map<String, String>> cnStatusList, [List<Map<String, dynamic>>? fullPayload]) {
    showDialog(
      context: context,
      barrierDismissible: true,
      builder: (context) {
        return AlertDialog(
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
          title: const Text('CN Creation Status', textAlign: TextAlign.center),
          content: SizedBox(
            width: 340,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (fullPayload != null && fullPayload.isNotEmpty)
                    ...fullPayload.map((item) => Card(
                          margin: const EdgeInsets.symmetric(vertical: 8),
                          child: Padding(
                            padding: const EdgeInsets.all(12),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Row(
                                  children: [
                                    Icon(
                                      (item['consigment_no'] != null && item['consigment_no'].toString().isNotEmpty)
                                          ? Icons.check_circle
                                          : Icons.error,
                                      color: (item['consigment_no'] != null && item['consigment_no'].toString().isNotEmpty)
                                          ? Colors.green
                                          : Colors.red,
                                    ),
                                    const SizedBox(width: 8),
                                    Text(
                                      (item['consigment_no'] != null && item['consigment_no'].toString().isNotEmpty)
                                          ? 'Success'
                                          : 'Failed',
                                      style: TextStyle(
                                        color: (item['consigment_no'] != null && item['consigment_no'].toString().isNotEmpty)
                                            ? Colors.green
                                            : Colors.red,
                                        fontWeight: FontWeight.bold,
                                      ),
                                    ),
                                  ],
                                ),
                                const SizedBox(height: 8),
                                ...item.entries.map((entry) => Padding(
                                      padding: const EdgeInsets.symmetric(vertical: 2),
                                      child: Row(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                          Text('${entry.key}: ', style: const TextStyle(fontWeight: FontWeight.bold)),
                                          Expanded(child: Text('${entry.value}')),
                                        ],
                                      ),
                                    )),
                              ],
                            ),
                          ),
                        )),
                  if (fullPayload == null || fullPayload.isEmpty)
                    ...cnStatusList.map((item) => ListTile(
                          leading: Icon(
                            item['status'] == 'success' ? Icons.check_circle : Icons.error,
                            color: item['status'] == 'success' ? Colors.green : Colors.red,
                          ),
                          title: Text('Order: ${item['order_id'] ?? '-'}'),
                          subtitle: Text('CN: ${item['cn'] ?? '-'}'),
                          trailing: Text(
                            item['status'] == 'success' ? 'Success' : 'Failed',
                            style: TextStyle(
                              color: item['status'] == 'success' ? Colors.green : Colors.red,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        )),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );
  }

  
  Future<void> _refreshOrderListInBackground() async {
    try {
      
      final acno = _authService.getCurrentAcno();
      
      if (acno?.isEmpty ?? true) {
        
        return;
      }

      
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderIndexEndpoint),
        data: {
          "acno": acno,
          "start_limit": 1,
          "end_limit": 15,
          "start_date": DateTime.now().subtract(const Duration(days: 30)).toIso8601String().split('T')[0],
          "end_date": DateTime.now().toIso8601String().split('T')[0],
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );

      if (response.statusCode == 200) {
        
      } else {
      
      }
    } catch (e) {
      print('CN Creation: Error refreshing order list in background: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isInitialLoading) {
      
      return ConnectivityWrapper(
        showOfflineUI: true,
        child: const Scaffold(
          backgroundColor: Colors.white,
          body: Center(
            child: CircularProgressIndicator(
              color:Color(0xFF007AFF), 
              strokeWidth: 4,
            ),
          ),
        ),
      );
    }
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          backgroundColor: Colors.white,
          elevation: 0,
          
          foregroundColor: Colors.black,
          surfaceTintColor: Colors.white,
          title: const Text(
            'Create CN',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
        ),
        body: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: AnimationLimiter(
            child: ListView(
              children: AnimationConfiguration.toStaggeredList(
                duration: const Duration(milliseconds: 500),
                childAnimationBuilder: (widget) => SlideAnimation(
                  verticalOffset: 50.0,
                  child: FadeInAnimation(
                    child: widget,
                  ),
                ),
                children: [
                  
                  GestureDetector(
                    onTap: () async {
                      _clearFieldError('account');
                      final options = _accounts.map((a) => _accountDropdownValue(a)).toList();
                      final result = await showModalBottomSheet<String>(
                        context: context,
                        isScrollControlled: true,
                        backgroundColor: Colors.transparent,
                        builder: (ctx) => _SingleSelectDialog(
                          items: options,
                          initialValue: selectedAccount,
                          title: 'Select Account',
                        ),
                      );
                      if (result != null) {
                        setState(() => selectedAccount = result);
                        if (result != null && result != 'Select your Account') {
                          final selectedAccountObj = _accounts.firstWhere(
                            (account) => _accountDropdownValue(account) == result,
                          );
                          final courierId = int.tryParse(selectedAccountObj.courierId) ?? 1;
                          final customerCourierId = int.tryParse(selectedAccountObj.id) ?? 55;
                          _fetchPickupLocations(courierId: courierId, customerCourierId: customerCourierId);
                          _fetchServiceCodes();
                        }
                      }
                    },
                    child: Container(
                      margin: const EdgeInsets.only(bottom: 8),
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                      decoration: BoxDecoration(
                        color: const Color(0xFFF5F5F7),
                        borderRadius: BorderRadius.circular(14),
                        border: Border.all(
                          color: _showValidationErrors && _fieldErrors['account']! 
                              ? Colors.red 
                              : Colors.transparent,
                          width: 2,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.grey.withOpacity(0.08),
                            blurRadius: 8,
                            offset: Offset(0, 2),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              (selectedAccount == null || selectedAccount!.isEmpty)
                                  ? 'Select Account'
                                  : selectedAccount!,
                              style: TextStyle(
                                fontSize: 15,
                                color: (selectedAccount == null || selectedAccount!.isEmpty || selectedAccount == 'Select your Account')
                                    ? Colors.black
                                    : Colors.black,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                        ],
                      ),
                    ),
                  ),
                  
                  GestureDetector(
                    onTap: (selectedAccount == null || selectedAccount == 'Select your Account') ? null : () async {
                      _clearFieldError('pickup');
                      final options = pickupOptions.isNotEmpty ? pickupOptions : ['Pickup 1', 'Hazari'];
                      final result = await showModalBottomSheet<String>(
                        context: context,
                        isScrollControlled: true,
                        backgroundColor: Colors.transparent,
                        builder: (ctx) => _PickupSelectDialog(
                          items: options,
                          initialValue: selectedPickup,
                          title: 'Pickup',
                          isLoading: _isLoadingPickup,
                        ),
                      );
                      if (result != null) {
                        setState(() => selectedPickup = result);
                        final pickupLocation = pickupLocationsWithIds.firstWhere(
                          (p) => (p['name']?.toString()?.trim() ?? '') == result.trim(),
                          orElse: () => <String, Object>{},
                        );
                        selectedPickupLocationId = int.tryParse(pickupLocation['id']?.toString() ?? '0') ?? 0;
                      }
                    },
                    child: Container(
                      margin: const EdgeInsets.only(bottom: 8),
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                      decoration: BoxDecoration(
                        color: const Color(0xFFF5F5F7),
                        borderRadius: BorderRadius.circular(14),
                        border: Border.all(
                          color: _showValidationErrors && _fieldErrors['pickup']! 
                              ? Colors.red 
                              : Colors.transparent,
                          width: 2,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.grey.withOpacity(0.08),
                            blurRadius: 8,
                            offset: Offset(0, 2),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              (selectedAccount == null || selectedAccount == 'Select your Account')
                                  ? 'Pickup'
                                  : (selectedPickup == null || selectedPickup!.isEmpty)
                                      ? 'Pickup'
                                      : selectedPickup!,
                              style: TextStyle(
                                fontSize: 15,
                                color: (selectedAccount == null || selectedAccount == 'Select your Account')
                                    ? Colors.black
                                    : (selectedPickup == null || selectedPickup!.isEmpty)
                                        ? Colors.black
                                        : Colors.black,
                              ),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          if (_isLoadingPickup)
                            Padding(
                              padding: const EdgeInsets.only(left: 8),
                              child: SizedBox(
                                width: 18,
                                height: 18,
                                child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF007AFF)),
                              ),
                            ),
                          Icon(Icons.keyboard_arrow_down_rounded, color: (selectedAccount == null || selectedAccount == 'Select your Account') ? Colors.grey : Color(0xFF222222)),
                        ],
                      ),
                    ),
                  ),
                  
                  Column(
                    children: [
                      
                      
                      GestureDetector(
                        onTap: (serviceCodes.isEmpty || _isLoadingServiceCodes)
                            ? null
                            : () async {
                                _clearFieldError('serviceCode');
                                final options = serviceCodes
                                    .map((e) => (e['service_name']?.toString() ?? e['service_code']?.toString() ?? ''))
                                    .map((s) => s.trim())
                                    .where((s) => s.isNotEmpty)
                                    .toList();
                                if (options.isEmpty) {
                                  await showModalBottomSheet<void>(
                                    context: context,
                                    backgroundColor: Colors.transparent,
                                    builder: (ctx) => _SingleSelectDialog(
                                      items: const [],
                                      initialValue: null,
                                      title: 'Service Code',
                                    ),
                                  );
                                  return;
                                }
                                final result = await showModalBottomSheet<String>(
                                  context: context,
                                  isScrollControlled: true,
                                  backgroundColor: Colors.transparent,
                                  builder: (ctx) => _SingleSelectDialog(
                                    items: options,
                                    initialValue: selectedServiceCode?['service_name']?.toString() ?? selectedServiceCode?['service_code']?.toString(),
                                    title: 'Service Code',
                                  ),
                                );
                                if (result != null) {
                                  setState(() => selectedServiceCode = serviceCodes.firstWhere(
                                    (e) => (e['service_name']?.toString() ?? e['service_code']?.toString() ?? '') == result,
                                    orElse: () => {'service_code': result, 'service_name': result},
                                  ));
                                }
                              },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(
                              color: _showValidationErrors && _fieldErrors['serviceCode']! 
                                  ? Colors.red 
                                  : Colors.transparent,
                              width: 2,
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  (selectedServiceCode == null)
                                      ? 'Service Code'
                                      : selectedServiceCode!['service_name'] ?? selectedServiceCode!['service_code'] ?? 'Service Code',
                                  style: TextStyle(
                                    fontSize: 15,
                                    color: (selectedServiceCode == null)
                                        ? Colors.black
                                        : Colors.black,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              if (_isLoadingServiceCodes)
                                Padding(
                                  padding: const EdgeInsets.only(left: 8),
                                  child: SizedBox(
                                    width: 18,
                                    height: 18,
                                    child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF007AFF)),
                                  ),
                                ),
                              Icon(Icons.keyboard_arrow_down_rounded, color: (selectedServiceCode == null) ? Colors.grey : Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      
                      GestureDetector(
                        onTap: () async {
                          _clearFieldError('fragile');
                          final options = ['Yes', 'No'];
                          final result = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (ctx) => _SingleSelectDialog(
                              items: options,
                              initialValue: fragileRequire == 'Y' ? 'Yes' : fragileRequire == 'N' ? 'No' : null,
                              title: 'Fragile',
                            ),
                          );
                          if (result != null) {
                            setState(() => fragileRequire = result == 'Yes' ? 'Y' : result == 'No' ? 'N' : '');
                          }
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(
                              color: _showValidationErrors && _fieldErrors['fragile']! 
                                  ? Colors.red 
                                  : Colors.transparent,
                              width: 2,
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  fragileRequire.isEmpty ? 'Fragile' : (fragileRequire == 'Y' ? 'Yes' : 'No'),
                                  style: TextStyle(
                                    fontSize: 15,
                                    color: fragileRequire.isEmpty ? Colors.black : Colors.black,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              Icon(Icons.keyboard_arrow_down_rounded, color: fragileRequire.isEmpty ? Colors.grey : Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      
                      GestureDetector(
                        onTap: () async {
                          _clearFieldError('insurance');
                          final options = ['Yes', 'No'];
                          final result = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (ctx) => _SingleSelectDialog(
                              items: options,
                              initialValue: insuranceRequire == 'Y' ? 'Yes' : insuranceRequire == 'N' ? 'No' : null,
                              title: 'Insurance',
                            ),
                          );
                          if (result != null) {
                            setState(() => insuranceRequire = result == 'Yes' ? 'Y' : result == 'No' ? 'N' : '');
                          }
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(
                              color: _showValidationErrors && _fieldErrors['insurance']! 
                                  ? Colors.red 
                                  : Colors.transparent,
                              width: 2,
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  insuranceRequire.isEmpty ? 'Insurance' : (insuranceRequire == 'Y' ? 'Yes' : 'No'),
                                  style: TextStyle(
                                    fontSize: 15,
                                    color: insuranceRequire.isEmpty ? Colors.black : Colors.black,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              Icon(Icons.keyboard_arrow_down_rounded, color: insuranceRequire.isEmpty ? Colors.grey : Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                      
                      GestureDetector(
                        onTap: () async {
                          _clearFieldError('parcelType');
                          final options = ['Parcel', 'Document'];
                          final result = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (ctx) => _SingleSelectDialog(
                              items: options,
                              initialValue: parcelType.isEmpty ? null : parcelType,
                              title: 'Parcel Type',
                            ),
                          );
                          if (result != null) {
                            setState(() => parcelType = result);
                          }
                        },
                        child: Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF5F5F7),
                            borderRadius: BorderRadius.circular(14),
                            border: Border.all(
                              color: _showValidationErrors && _fieldErrors['parcelType']! 
                                  ? Colors.red 
                                  : Colors.transparent,
                              width: 2,
                            ),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.08),
                                blurRadius: 8,
                                offset: Offset(0, 2),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  parcelType.isEmpty ? 'Parcel Type' : parcelType,
                                  style: TextStyle(
                                    fontSize: 15,
                                    color: parcelType.isEmpty ? Colors.black : Colors.black,
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              Icon(Icons.keyboard_arrow_down_rounded, color: parcelType.isEmpty ? Colors.grey : Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),

                  if (widget.orders.isNotEmpty) ...[
                    const SizedBox(height: 16),
                    const Text(
                      'Selected Orders',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.w700,
                        color: Colors.black,
                      ),
                    ),
                    const SizedBox(height: 12),
                    ...widget.orders.map((order) => Container(
                      width: double.infinity,
                      margin: const EdgeInsets.only(bottom: 12),
                      decoration: BoxDecoration(
                        color: const Color(0xFFF5F5F7),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      padding: const EdgeInsets.all(12),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Row(
                                children: [
                                  const Text('Order ID', style: TextStyle(fontWeight: FontWeight.w700)),
                                  const SizedBox(width: 8),
                                  Text(order['id']?.toString() ?? '', style: TextStyle(fontWeight: FontWeight.w400)),
                                ],
                              ),
                              GestureDetector(
                                onTap: () {
                                  setState(() {
                                    widget.orders.remove(order);
                                  });
                                },
                                child: Container(
                                  padding: const EdgeInsets.all(8),
                                  decoration: BoxDecoration(
                                    color: const Color(0xFF007AFF).withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                  child: SvgPicture.asset(
                                    'assets/Delete.svg',
                                    width: 20,
                                    height: 20,
                                    color: const Color(0xFF007AFF),
                                  ),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 6),
                          _summaryRow('Name', order['consignee_name'] ?? ''),
                          Padding(
                            padding: const EdgeInsets.symmetric(vertical: 2),
                            child: Row(
                              children: [
                                const Text('Destination City', style: TextStyle(fontWeight: FontWeight.w700)),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: _isLoadingCities
                                      ? const Center(child: SizedBox(height: 24, width: 24, child: CircularProgressIndicator(strokeWidth: 2)))
                                      : GestureDetector(
                                          onTap: () async {
                                            _clearFieldError('city');
                                            if (_isLoadingCities) return;
                                            final selected = await showModalBottomSheet<String>(
                                              context: context,
                                              isScrollControlled: true,
                                              backgroundColor: Colors.transparent,
                                              builder: (context) => _CitySearchDialog(
                                                cities: cityList,
                                                initialCity: selectedCityDropdown,
                                              ),
                                            );
                                            if (selected != null) {
                                              setState(() {
                                                selectedCityDropdown = selected;
                                              });
                                            }
                                          },
                                          child: Container(
                                            margin: const EdgeInsets.only(bottom: 8),
                                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                            decoration: BoxDecoration(
                                              color: const Color(0xFFF5F5F7),
                                              borderRadius: BorderRadius.circular(14),
                                              border: Border.all(
                                                color: _showValidationErrors && _fieldErrors['city']! 
                                                    ? Colors.red 
                                                    : Colors.transparent,
                                                width: 2,
                                              ),
                                              boxShadow: [
                                                BoxShadow(
                                                  color: Colors.grey.withOpacity(0.08),
                                                  blurRadius: 8,
                                                  offset: Offset(0, 2),
                                                ),
                                              ],
                                            ),
                                            child: Row(
                                              children: [
                                                Expanded(
                                                  child: Text(
                                                    (selectedCityDropdown == null || selectedCityDropdown == '' || selectedCityDropdown == 'Select City')
                                                        ? 'Select City'
                                                        : selectedCityDropdown!,
                                                    style: TextStyle(
                                                      fontSize: 15,
                                                      color: (selectedCityDropdown == null || selectedCityDropdown == '' || selectedCityDropdown == 'Select City')
                                                          ? Colors.black
                                                          : Colors.black,
                                                    ),
                                                    overflow: TextOverflow.ellipsis,
                                                  ),
                                                ),
                                                Icon(Icons.keyboard_arrow_down_rounded, color: (selectedCityDropdown == null || selectedCityDropdown == '' || selectedCityDropdown == 'Select City') ? Colors.grey : Color(0xFF222222)),
                                              ],
                                            ),
                                          ),
                                        ),
                                ),
                              ],
                            ),
                          ),
                          _summaryRow('Weight', order['weight']?.toString() ?? ''),
                          const SizedBox(height: 6),
                        ],
                      ),
                    )).toList(),
                  ],
                  const SizedBox(height: 24),
                  SizedBox(
                    width: double.infinity,
                    height: 48,
                    child: ElevatedButton(
                      onPressed: isSubmitting ? null : () async {
                        
                        if (!_validateFields() || widget.orders.isEmpty) {
                          customSnackBar('Error', 'Please fill all required fields');
                          return;
                        }
                        setState(() { isSubmitting = true; });
                        
                        try {
                          final user = _authService.currentUser.value;
                          final acno = user?.acno ?? '';
                          final userId = int.tryParse(user?.userId?.toString() ?? '0') ?? 0;
                          final customerId = int.tryParse(user?.customerId?.toString() ?? '0') ?? 0;
                          final order = widget.orders.first;
                          
                          
                          int courierId = 1;
                          int customerCourierId = 55;
                          
                          if (selectedAccount != null && selectedAccount != 'Select your Account') {
                            try {
                              final selectedAccountObj = _accounts.firstWhere(
                                (account) => _accountDropdownValue(account) == selectedAccount,
                              );
                              courierId = int.tryParse(selectedAccountObj.courierId) ?? 1;
                              customerCourierId = int.tryParse(selectedAccountObj.id) ?? 55;
                            } catch (e) {
                              if (_accounts.isNotEmpty) {
                                courierId = int.tryParse(_accounts.first.courierId) ?? 1;
                                customerCourierId = int.tryParse(_accounts.first.id) ?? 55;
                              }
                            }
                          }
                          
                          
                          final serviceCode = selectedServiceCode?['service_code'] ?? '';
                          
                          
                          final fragileRequireValue = this.fragileRequire == 'Y' ? 'Y' : 'N';
                          final insuranceRequireValue = this.insuranceRequire == 'Y' ? 'Y' : 'N';
                          
                          
                          final parcelTypeValue = this.parcelType == 'Parcel' ? 'P' : 'D';
                          
                          
                          final pickupLocationIdInt = selectedPickupLocationId ?? 0;
                          
                          
                          final orderId = int.tryParse(order?['id']?.toString() ?? order?['order_id']?.toString() ?? '0') ?? 0;
                          
                          
                          int destinationCityId = 655; 
                          if (selectedCityDropdown != null && selectedCityDropdown!.isNotEmpty) {
                            final city = citiesWithIds.firstWhere(
                              (c) => c['name'] == selectedCityDropdown,
                              orElse: () => <String, Object>{},
                            );
                            destinationCityId = city['id'] ?? 655;
                          }
                          
                          
                          final detailEntries = widget.orders.map((order) => {
                            "order_id": int.tryParse(order?['id']?.toString() ?? order?['order_id']?.toString() ?? '0') ?? 0,
                            "destination_city_id": destinationCityId,
                          }).toList();
                          
                          final body = {
                            "acno": acno,
                            "user_id": userId,
                            "customer_id": customerId,
                            "courier_id": courierId,
                            "customer_courier_id": customerCourierId,
                            "service_code": serviceCode,
                            "fragile_require": fragileRequireValue,
                            "insurance_require": insuranceRequireValue,
                            "insurance_value": 0,
                            "parcel_type": parcelTypeValue,
                            "pickup_location_id": pickupLocationIdInt,
                            "detail": detailEntries
                          };
                          
                          
                          
                          final dio = Dio();
                          final response = await dio.post(
                            ApiConfig.getEndpointUrl(ApiConfig.shipmentCreateEndpoint),
                            data: body,
                            options: Options(headers: {'Content-Type': 'application/json'}),
                          );
                          
                          
                          
                          if (response.data['is_shipment'] == '1') {
                            customSnackBar('Error', 'Consignment no already generated. Please try another cn');
                          }
                          
                          if (response.statusCode == 200 && (response.data['status'] == 1 || response.data['success'] == true)) {
                            
                            final List<Map<String, dynamic>> fullPayload = response.data['payload'] is List
                                ? List<Map<String, dynamic>>.from(response.data['payload'])
                                : [];
                            
                            
                            final Set<String> successOrderIds = fullPayload
                                .where((item) => (item['cnno'] != null && item['cnno'].toString().isNotEmpty))
                                .map((item) => item['order_id']?.toString() ?? '')
                                .where((id) => id.isNotEmpty)
                                .toSet();
                            
                            final List<Map<String, dynamic>> dialogList = widget.orders.map((order) {
                              final orderId = order['id']?.toString() ?? order['order_id']?.toString() ?? '';
                              final payloadItem = fullPayload.firstWhere(
                                (item) => (item['order_id']?.toString() ?? '') == orderId,
                                orElse: () => <String, dynamic>{},
                              );
                              return {
                                'order_id': orderId,
                                ...payloadItem,
                                'status': (payloadItem['cnno'] != null && payloadItem['cnno'].toString().isNotEmpty)
                                    ? 'success'
                                    : 'failed',
                              };
                            }).toList();
                            
                            
                            setState(() { isSubmitting = false; });
                            
                            
                            await showModalBottomSheet(
                              context: context,
                              isScrollControlled: true,
                              backgroundColor: Colors.transparent,
                              builder: (context) => _CnStatusDialog(
                                dialogList: dialogList,
                                onClose: () {
                                  
                                  setState(() {
                                    widget.orders.removeWhere((order) {
                                      final orderId = order['id']?.toString() ?? order['order_id']?.toString() ?? '';
                                      return successOrderIds.contains(orderId);
                                    });
                                  });
                                  
                                  
                                  _refreshOrderListInBackground();
                                  
                                  
                                  final allSucceeded = widget.orders.isEmpty;
                                  if (allSucceeded) {
                                    
                                    setState(() {
                                      selectedAccount = null;
                                      selectedType = 'Parcel';
                                      selectedFragile = null;
                                      selectedCourier = null;
                                      selectedCity = null;
                                      selectedInsurance = null;
                                      cityList = [];
                                      fragileRequire = '';
                                      insuranceRequire = '';
                                      parcelType = '';
                                      pickupOptions = [];
                                      selectedPickup = null;
                                      _isLoadingPickup = false;
                                      selectedCityDropdown = null;
                                      pickupLocationsWithIds = [];
                                      citiesWithIds = [];
                                      serviceCodes = [];
                                      selectedServiceCode = null;
                                      _isLoadingServiceCodes = false;
                                      selectedPickupLocationId = null;
                                    });
                                    Navigator.of(context).pop(true);
                                  }
                                  
                                },
                              ),
                            );
                          } else {
                            
                          }
                        } catch (e) {
                          print('Error creating shipment: $e');
                          
                        } finally {
                          setState(() { isSubmitting = false; });
                        }
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF007AFF),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      child: isSubmitting
                          ? Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: const [
                                SizedBox(
                                  width: 22,
                                  height: 22,
                                  child: CircularProgressIndicator(
                                    color: Color(0xFF007AFF),
                                    strokeWidth: 2.5,
                                  ),
                                ),
                                SizedBox(width: 12),
                                Text('Creating CN...', style: TextStyle(fontSize: 18, color: Colors.white)),
                              ],
                            )
                          : const Text('Create CN', style: TextStyle(fontSize: 18, color: Colors.white)),
                    ),
                  ),
                  
                  const SizedBox(height: 80),
                ],
              ),
            ),
          ),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            Get.to(() => CreateOrderScreen(from: 'create_cn'));
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
           child: SvgPicture.asset(
    'assets/Create Order.svg',
    width: 28,
    height: 28,
    color: Colors.white,
),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
                bottomNavigationBar: const AppBottomBar(selectedIndex: 1),
      ),
    );
  }

  Widget _dropdown(String label, String? value, List<String> items, ValueChanged<String?> onChanged, {bool dense = false}) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.grey[300]!, width: 1),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.08),
            blurRadius: 8,
            offset: Offset(0, 2),
          ),
        ],
      ),
      padding: const EdgeInsets.symmetric(horizontal: 10),
      child: DropdownButtonFormField<String>(
        value: value,
        items: items.map((e) => DropdownMenuItem(value: e, child: Text(e))).toList(),
        onChanged: onChanged,
        decoration: InputDecoration(
          border: InputBorder.none,
          isDense: dense,
          contentPadding: EdgeInsets.symmetric(vertical: dense ? 8 : 14),
        ),
        style: const TextStyle(fontSize: 15, color: Colors.black),
        icon: const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
      ),
    );
  }

  Widget _summaryRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        children: [
          Text(label, style: const TextStyle(fontWeight: FontWeight.w700)),
          const SizedBox(width: 8),
          Text(value, style: const TextStyle(fontWeight: FontWeight.w400)),
        ],
      ),
    );
  }
}

class _CnSuccessBottomSheet extends StatelessWidget {
  const _CnSuccessBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(32),
              child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
            ),
            const SizedBox(height: 24),
            const Text(
              'Success!',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
            ),
            const SizedBox(height: 8),
            const Text(
              'CN are successfully generated',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  Navigator.of(context).popUntil((route) => route.isFirst);
                  Navigator.of(context).pushReplacement(
                    MaterialPageRoute(builder: (_) => const OrderListScreen()),
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  elevation: 0,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _CitySearchDialog extends StatefulWidget {
  final List<String> cities;
  final String? initialCity;
  const _CitySearchDialog({Key? key, required this.cities, this.initialCity}) : super(key: key);

  @override
  State<_CitySearchDialog> createState() => _CitySearchDialogState();
}

class _CitySearchDialogState extends State<_CitySearchDialog> {
  late List<String> filteredCities;
  late TextEditingController searchController;
  String? selected;

  @override
  void initState() {
    super.initState();
    filteredCities = widget.cities;
    searchController = TextEditingController();
    selected = widget.initialCity;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredCities = widget.cities.where((c) => c.toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        const Text('Select City', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          controller: searchController,
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredCities.isEmpty
                              ? const Center(child: Text('No cities found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredCities.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final city = filteredCities[i];
                                    final isSelected = city == selected;
                                    return ListTile(
                                      title: Text(
                                        city,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(city);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 

class _CnStatusDialog extends StatelessWidget {
  final List<Map<String, dynamic>> dialogList;
  final Function()? onClose;
  const _CnStatusDialog({Key? key, required this.dialogList, this.onClose}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Padding(
            padding: const EdgeInsets.all(20),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'CN Creation Status',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: Colors.black,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close_rounded),
                  onPressed: () {
                    Navigator.of(context).pop();
                    onClose?.call();
                  },
                ),
              ],
            ),
          ),
          
          Flexible(
            child: SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: dialogList.map((item) {
                  final cn = item['cnno']?.toString() ?? '';
                  final isBooked = cn.isNotEmpty;
                  final statusText = isBooked ? 'Success' : 'Failed';
                  final statusColor = isBooked ? const Color(0xFF4CAF50) : const Color(0xFFF44336);
                  
                  
                  final remarks = _formatApiResponse(item);
                  
                  return Card(
                    margin: const EdgeInsets.symmetric(vertical: 8),
                    child: Padding(
                      padding: const EdgeInsets.all(12),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Row(
                                      children: [
                                        const Text('Order ID: ', style: TextStyle(fontWeight: FontWeight.bold)),
                                        Text(item['order_id']?.toString() ?? '-', style: const TextStyle(fontWeight: FontWeight.w400)),
                                      ],
                                    ),
                                    const SizedBox(height: 4),
                                    Row(
                                      children: [
                                        const Text('CN: ', style: TextStyle(fontWeight: FontWeight.bold)),
                                        Text(cn.isNotEmpty ? cn : '-', style: const TextStyle(fontWeight: FontWeight.w400)),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                              Container(
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                                decoration: BoxDecoration(
                                  color: statusColor,
                                  borderRadius: BorderRadius.circular(20),
                                ),
                                child: Text(
                                  statusText,
                                  style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w600, fontSize: 14),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 12),
                          
                          const Text('Remarks:', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 14)),
                          const SizedBox(height: 4),
                          Container(
                            width: double.infinity,
                            padding: const EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: Colors.grey[50],
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: Colors.grey[300]!),
                            ),
                            child: Text(
                              remarks,
                              style: const TextStyle(
                                fontSize: 12,
                                fontFamily: 'monospace',
                                color: Colors.black87,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                }).toList(),
              ),
            ),
          ),
          
          const SizedBox(height: 20),
        ],
      ),
    );
  }

  String _formatApiResponse(Map<String, dynamic> item) {
    
    final message = item['message']?.toString() ?? '';
    final error = item['error']?.toString() ?? '';
    final remarks = item['remarks']?.toString() ?? '';
    
    
    String text = '';
    if (message.isNotEmpty) text = message;
    else if (error.isNotEmpty) text = error;
    else if (remarks.isNotEmpty) text = remarks;
    else return 'No message available';
    
    
    text = text.trim();
    if (text.isNotEmpty) {
      
      text = text[0].toUpperCase() + text.substring(1);
      
      
      text = text.replaceAll(RegExp(r'[,\s]*$'), '');
      
      
      if (!text.endsWith('.') && !text.endsWith('!') && !text.endsWith('?')) {
        text += '.';
      }
    }
    
    return text;
  }
} 

class _PickupSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;
  final bool isLoading;

  const _PickupSelectDialog({Key? key, required this.items, required this.initialValue, required this.title, this.isLoading = false}) : super(key: key);

  @override
  State<_PickupSelectDialog> createState() => _PickupSelectDialogState();
}

class _PickupSelectDialogState extends State<_PickupSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        if (widget.isLoading) ...[
                          const SizedBox(height: 16),
                          const Center(child: CircularProgressIndicator()),
                        ],
                        if (!widget.isLoading) ...[
                          const SizedBox(height: 12),
                          SizedBox(
                            height: 300,
                            child: ListView.separated(
                              itemCount: filteredItems.length,
                              separatorBuilder: (_, __) => Container(
                                height: 1,
                                color: Colors.black.withOpacity(0.08),
                                margin: const EdgeInsets.symmetric(horizontal: 8),
                              ),
                              itemBuilder: (context, i) {
                                final item = filteredItems[i];
                                final isSelected = selected == item;
                                return ListTile(
                                  title: Text(item),
                                  trailing: isSelected
                                      ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                      : null,
                                  onTap: () {
                                    setState(() {
                                      selected = item;
                                    });
                                    Navigator.of(context).pop(item);
                                  },
                                  selected: isSelected,
                                  selectedTileColor: const Color(0xFFE6F0FF),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                );
                              },
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import 'package:dio/dio.dart';
import 'package:google_fonts/google_fonts.dart';
import '../services/auth_service.dart';
import '../utils/custom_snackbar.dart';
import '../network/order_service.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'create_order.dart';
import '../widgets/courier_logo_widget.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;
import '../config/api_config.dart';

class CreateLoadsheetScreen extends StatefulWidget {
  const CreateLoadsheetScreen({Key? key}) : super(key: key);

  @override
  State<CreateLoadsheetScreen> createState() => _CreateLoadsheetScreenState();
}

class _CreateLoadsheetScreenState extends State<CreateLoadsheetScreen> {
  final TextEditingController _searchController = TextEditingController();
  final TextEditingController _cnController = TextEditingController();
  bool _isLoading = false;
  bool selectAll = false;
  final Set<String> selectedOrders = {};
  final List<Map<String, dynamic>> foundOrders = [];
  final AuthService _authService = Get.find<AuthService>();

  Future<void> _searchOrderByCN() async {
    final acno = _authService.getCurrentAcno();
    final cnText = _cnController.text.trim();
    if (acno == null || acno.isEmpty) {
      customSnackBar('Error', 'Account number not found. Please log in again.');
      return;
    }
    if (cnText.isEmpty) {
      customSnackBar('Error', 'Please enter a consignment/order ID.');
      return;
    }
    setState(() { _isLoading = true; });
    try {
      final now = DateTime.now();
      final startDate = DateTime(now.year, now.month, 1);
      final endDate = now;
      final orderResp = await OrderService.fetchOrders(
        startLimit: 1,
        endLimit: 100,
        acno: acno,
        startDate: startDate.toIso8601String().split('T')[0],
        endDate: endDate.toIso8601String().split('T')[0],
        extraParams: {"consigment_no": cnText},
      );
      final List<dynamic> orders = orderResp['data'] ?? [];
      final foundOrder = orders.firstWhere(
        (o) => (o['consigment_no']?.toString().trim().toLowerCase() ?? '') == cnText.trim().toLowerCase(),
        orElse: () => null,
      );
      if (foundOrder == null) {
        customSnackBar('Error', 'Invalid CN No');
        setState(() { _isLoading = false; });
        return;
      }
      
      if (foundOrders.any((o) => o['id'].toString() == foundOrder['id'].toString())) {
        customSnackBar('Info', 'Order already added.');
        setState(() { _isLoading = false; });
        return;
      }
      setState(() {
        foundOrders.add(foundOrder);
        _isLoading = false;
      });
    } catch (e) {
      // Handle DioError specifically to extract API error messages
      if (e is DioException) {
        String errorMessage = 'Network error occurred';
        
        if (e.response != null) {
          // API returned an error response
          final responseData = e.response?.data;
          if (responseData is Map) {
            errorMessage = responseData['message'] ?? 
                          responseData['error'] ?? 
                          responseData['detail'] ?? 
                          'Failed to search order';
          } else if (responseData is String) {
            errorMessage = responseData;
          } else {
            errorMessage = 'HTTP ${e.response?.statusCode}: ${e.response?.statusMessage ?? 'Request failed'}';
          }
        } else if (e.type == DioExceptionType.connectionTimeout) {
          errorMessage = 'Connection timeout. Please check your internet connection.';
        } else if (e.type == DioExceptionType.receiveTimeout) {
          errorMessage = 'Request timeout. Please try again.';
        } else if (e.type == DioExceptionType.connectionError) {
          errorMessage = 'Connection error. Please check your internet connection.';
        } else {
          errorMessage = 'Network error: ${e.message}';
        }
        
        customSnackBar('Error', errorMessage);
        
        if (e.response != null) {
          
        }
      } else {
        // Handle other types of errors
        customSnackBar('Error', 'Failed to search order: ${e.toString()}');
        
      }
      setState(() { _isLoading = false; });
    }
  }

  Future<void> _createLoadsheet() async {
    if (selectedOrders.isEmpty) return;
    final acno = _authService.getCurrentAcno()?.toString() ?? '';
    final selectedOrdersList = foundOrders.where((o) => selectedOrders.contains(o['id'].toString())).toList();
    if (acno.isEmpty || selectedOrdersList.isEmpty) {
      customSnackBar('Error', 'Order or account info missing.');
      return;
    }
    setState(() { _isLoading = true; });
    try {
      final orderIds = selectedOrdersList.map((o) => int.tryParse(o['id'].toString())).whereType<int>().toList();
      final status = selectedOrdersList.first['status']?.toString() ?? "active";
      final customerCourierId = int.tryParse(selectedOrdersList.first['customer_courier_id']?.toString() ?? '') ?? 0;
      final courierId = int.tryParse(selectedOrdersList.first['courier_id']?.toString() ?? '') ?? 0;
      
      
      final consignmentNos = selectedOrdersList
          .map((o) => o['consigment_no']?.toString() ?? '')
          .where((cn) => cn.isNotEmpty)
          .toList();
      
      
     
      
      final requestBody = {
        "acno": acno,
        "odids": orderIds,
        "status": status,
        "customer_courier_id": customerCourierId,
        "courier_id": courierId,
        "consignment_nos": consignmentNos,
      };
      
      
      
      final token = await _authService.getApiKey();
      final headers = {
        'Content-Type': 'application/json',
        if (token != null && token.isNotEmpty) 'Authorization': 'Bearer $token',
      };
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetCreateEndpoint),
        data: requestBody,
        options: Options(headers: headers),
      );
      
    
      
      if (response.statusCode == 200) {
        final responseData = response.data;
        if (responseData['status'] == 1) {
          customSnackBar('Success', responseData['message'] ?? 'Loadsheet created successfully!');
          Navigator.of(context).pop(true); 
        } else {
          // Show actual API error message
          final errorMessage = responseData['message'] ?? responseData['error'] ?? 'Failed to create loadsheet';
          customSnackBar('Error', errorMessage);
         
        }
      } else {
        // Show HTTP error status and message
        final errorMessage = 'HTTP ${response.statusCode}: ${response.statusMessage ?? 'Request failed'}';
        customSnackBar('Error', errorMessage);
        
      }
    } catch (e) {
      // Handle DioError specifically to extract API error messages
      if (e is DioException) {
        String errorMessage = 'Network error occurred';
        
        if (e.response != null) {
          // API returned an error response
          final responseData = e.response?.data;
          if (responseData is Map) {
            errorMessage = responseData['message'] ?? 
                          responseData['error'] ?? 
                          responseData['detail'] ?? 
                          'API request failed';
          } else if (responseData is String) {
            errorMessage = responseData;
          } else {
            errorMessage = 'HTTP ${e.response?.statusCode}: ${e.response?.statusMessage ?? 'Request failed'}';
          }
        } else if (e.type == DioExceptionType.connectionTimeout) {
          errorMessage = 'Connection timeout. Please check your internet connection.';
        } else if (e.type == DioExceptionType.receiveTimeout) {
          errorMessage = 'Request timeout. Please try again.';
        } else if (e.type == DioExceptionType.connectionError) {
          errorMessage = 'Connection error. Please check your internet connection.';
        } else {
          errorMessage = 'Network error: ${e.message}';
        }
        
        customSnackBar('Error', errorMessage);
       
        if (e.response != null) {
          
        }
      } else {
        // Handle other types of errors
        customSnackBar('Error', 'Failed to create loadsheet: ${e.toString()}');
        
      }
    } finally {
      setState(() { _isLoading = false; });
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _cnController.dispose();
    super.dispose();
  }

  Widget _ordersList() {
    if (foundOrders.isEmpty) return const SizedBox.shrink();
    return Column(
      children: foundOrders.map((order) {
        final idStr = order['id'].toString();
        final checked = selectedOrders.contains(idStr);
        return Container(
          margin: const EdgeInsets.only(top: 4, bottom: 4),
          decoration: BoxDecoration(
            color: const Color(0xFFF5F5F7),
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Transform.translate(
                    offset: Offset(-8, 0), 
                    child: Checkbox(
                      value: checked,
                      onChanged: (val) {
                        setState(() {
                          if (val == true) {
                            selectedOrders.add(idStr);
                          } else {
                            selectedOrders.remove(idStr);
                          }
                          
                          selectAll = selectedOrders.length == foundOrders.length;
                        });
                      },
                      activeColor: const Color(0xFF007AFF),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      visualDensity: VisualDensity.compact,
                    ),
                  ),
                  const SizedBox(width: 0),
                  Expanded(
                    child: Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: Text(
                        'S.No: ${(foundOrders.indexOf(order) + 1).toString().padLeft(2, '0')}',
                        style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                      ),
                    ),
                  ),
                  Column(
                    children: [
                      SizedBox(height: 6),
                      Container(
                        constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                        decoration: BoxDecoration(
                          color: () {
                            final status = order['status']?.toString().toLowerCase();
                            if (status == 'cancelled') return Colors.red.withOpacity(0.1);
                            if (status == 'booked') return Color(0xFF8e24aa).withOpacity(0.1); 
                            if (status == 'new') return Color(0xFF1DA1F2).withOpacity(0.1); 
                            if (status == 'pickup ready') return Color(0xFF43A047).withOpacity(0.1); 
                            return Colors.grey.withOpacity(0.1);
                          }(),
                          borderRadius: BorderRadius.circular(16),
                        ),
                        alignment: Alignment.center,
                        child: Text(
                          order['status']?.toString().capitalize ?? '',
                          style: GoogleFonts.inter(
                            color: () {
                              final status = order['status']?.toString().toLowerCase();
                              if (status== 'cancelled' || status == 'deleted') return Colors.red;
                              if (status == 'booked') return Color(0xFF8e24aa); 
                              if (status == 'new') return Color(0xFF1DA1F2); 
                              if (status == 'pickup ready') return Color(0xFF43A047); 
                              return Colors.grey;
                            }(),
                            fontWeight: FontWeight.w500, 
                            fontSize: 15
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    ],
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: 100,
                          child: Text('Order ID', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                        ),
                        const SizedBox(width: 36),
                        Expanded(
                          child: Text(order['id']?.toString() ?? '', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: 100,
                          child: Text('CN', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                        ),
                        const SizedBox(width: 36),
                        Expanded(
                          child: Text((order['consigment_no'] ?? '').isEmpty ? '-' : (order['consigment_no'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: 100,
                          child: Text('Customer', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                        ),
                        const SizedBox(width: 36),
                        Expanded(
                          child: Text((order['consignee_name'] ?? '').isEmpty ? '-' : (order['consignee_name'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: order['courier_name'] != null &&
                                 order['courier_name'].toString().length > 10
                               ? 113
                               : 98,
                          child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                        ),
                        const SizedBox(width: 26), 
                        order['courier_name'] != null && order['courier_name'].toString().isNotEmpty
                          ? (() {
                              final courierName = order['courier_name'].toString();
                              final pngUrl = '${ApiConfig.assetPngBaseUrl}${Uri.encodeComponent(courierName.trim())}.png';
                            
                              return CourierLogoWidget(
                                pngUrl: courierName,
                                courierId: order['courier_id']?.toString(),
                                accountTitle: order['account_title']?.toString(),
                                width: 78,
                                height: 36,
                                fit: BoxFit.contain,
                              );
                            })()
                          : const SizedBox(height: 24),
                      ],
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 4),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.center,
                      children: [
                        SizedBox(
                          width: 100,
                          child: Text('Amount', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                        ),
                        const SizedBox(width: 36),
                        Expanded(
                          child: Text((order['order_amount'] ?? '').isEmpty ? '-' : (order['order_amount'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      }).toList(),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        title: const Text(
          'Create Loadsheet',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Column(
        children: [
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.only(
                left: 16,
                right: 16,
                bottom: 80, // Add bottom padding to prevent FAB overlap
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 8),
                  
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 4),
                    child: TextField(
                      controller: _searchController,
                      decoration: InputDecoration(
                        hintText: 'Search',
                        suffixIcon: Icon(Icons.search_rounded),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                        filled: true,
                        fillColor: const Color(0xFFF5F5F7),
                        contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  
                  Text('Enter CN', style: TextStyle(fontWeight: FontWeight.w600, fontSize: 15)),
                  const SizedBox(height: 6),
                  Container(
                    decoration: BoxDecoration(
                      color: const Color(0xFFF3F3F3),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: TextField(
                      controller: _cnController,
                      decoration: InputDecoration(
                        hintText: 'Enter CN',
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(vertical: 12, horizontal: 12),
                        hintStyle: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 16,
                        ),
                      ),
                      keyboardType: TextInputType.text, 
                    ),
                  ),
                  const SizedBox(height: 8),
                  Center(
                    child: ElevatedButton(
                      onPressed: _isLoading ? null : _searchOrderByCN,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF007AFF),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      child: _isLoading
                          ? const SizedBox(
                              width: 18,
                              height: 18,
                              child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF007AFF)),
                            )
                          : const Text('Search', style: TextStyle(fontSize: 14, color: Colors.white)),
                    ),
                  ),
                  
                  if (foundOrders.isNotEmpty) ...[
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8),
                      child: Row(
                        children: [
                          Checkbox(
                            value: selectAll,
                            onChanged: (val) {
                              setState(() {
                                selectAll = val ?? false;
                                if (val == true) {
                                  selectedOrders.clear();
                                  for (int i = 0; i < foundOrders.length; i++) {
                                    selectedOrders.add(foundOrders[i]['id'].toString());
                                  }
                                } else {
                                  selectedOrders.clear();
                                }
                              });
                            },
                            activeColor: const Color(0xFF007AFF),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            visualDensity: VisualDensity.compact,
                          ),
                          const Text('Select All', style: TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w400, fontSize: 15)),
                          const Spacer(),
                          if (selectedOrders.isNotEmpty) ...[
                            GestureDetector(
                              onTap: () {
                                _showDeleteConfirmation(context, () {
                                  _deleteSelectedOrders();
                                });
                              },
                              child: Container(
                                constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                decoration: BoxDecoration(
                                  color: Colors.red.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(16),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  'Delete',
                                  style: GoogleFonts.inter(
                                    color: Colors.red,
                                    fontWeight: FontWeight.w500,
                                    fontSize: 15
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                  ],
                  
                  _ordersList(),
                  
                  if (selectedOrders.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 24, bottom: 24),
                      child: SizedBox(
                        width: double.infinity,
                        height: 48,
                        child: ElevatedButton(
                          onPressed: _isLoading ? null : _createLoadsheet,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF007AFF),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          child: _isLoading
                              ? const SizedBox(
                                  width: 24,
                                  height: 24,
                                  child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF007AFF)),
                                )
                              : const Text('Create Loadsheet', style: TextStyle(fontSize: 16, color: Colors.white)),
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ),
        ],
      ),
      bottomNavigationBar: AppBottomBar(
        selectedIndex: 2,
        onHomeTap: () {
          Get.offAllNamed('/dashboard');
        },
        onOrderListTap: () {
          Get.to(() => OrderListScreen(from: 'create_loadsheet'));
        },
        onReportsTap: () {
          Get.to(() => report.ReportsScreen(from: 'create_loadsheet'));
        },
        onMenuTap: () {
          Get.offAllNamed('/menu');
        },
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
    );
  }

  void _showDeleteConfirmation(BuildContext context, VoidCallback onConfirm) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFE6F0FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(32),
                  child: SvgPicture.asset(
                    'assets/Delete.svg',
                    width: 48,
                    height: 48,
                    color: const Color(0xFF007AFF),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
                ),
                const SizedBox(height: 8),
                const Text(
                  'You want to delete selected orders',
                  style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
                ),
                const SizedBox(height: 28),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF2F2F7),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.black)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          Navigator.of(context).pop();
                          onConfirm();
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void _deleteSelectedOrders() {
    setState(() {
      
      foundOrders.removeWhere((order) => selectedOrders.contains(order['id'].toString()));
      
      selectedOrders.clear();
      selectAll = false;
    });
    customSnackBar('Success', 'Selected orders removed successfully!');
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../services/auth_service.dart';
import '../services/rules_service.dart';
import '../services/courier_service.dart';
import '../services/statement_service.dart';
import '../utils/custom_snackbar.dart';
import 'create_order.dart';
import 'rules_screen.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:dio/dio.dart';
import 'package:multi_select_flutter/multi_select_flutter.dart';
import '../config/api_config.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';

class CreateRuleScreen extends StatefulWidget {
  const CreateRuleScreen({Key? key}) : super(key: key);

  @override
  State<CreateRuleScreen> createState() => _CreateRuleScreenState();
}

class _CreateRuleScreenState extends State<CreateRuleScreen> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController ruleTitleController = TextEditingController();
  final AuthService _authService = Get.find<AuthService>();
  late final RulesService _rulesService;
  
  
  List<String> selectedStatusIds = [];
  List<Map<String, dynamic>> statusesWithIds = []; 
  String? weightType;
  final TextEditingController weightValueController = TextEditingController();
  String? paymentMethodId;
  String? customerCitylistId;
  String? orderType;
  final TextEditingController orderValueController = TextEditingController();
  final TextEditingController platformValueController = TextEditingController();
  String? platformType;
  String? selectedAddressKeyword;
  String? isContain;
  String? courierId;
  String? customerCourierId;
  String? pickupId;
  String? threePLType; 
  final TextEditingController serviceCodeController = TextEditingController();

  
  List<String> statuses = [];
  bool isLoadingStatuses = false;
  String? statusError;
  final List<String> weightTypes = ['>=', '<=', '=='];
  final List<String> paymentMethods = ['COD', 'CC', 'Jazz Cash','Easy Paisa']; 
  List<String> cities = []; 
  bool isLoadingCities = false;
  String? citiesError;
  final List<String> orderTypes = ['>=', '<=', '=='];
  List<String> platformTypes = []; 
  bool isLoadingPlatforms = false;
  String? platformsError;
  final List<String> containOptions = ['Contain', 'Not Contain']; 
  List<String> courierAccounts = [];
  bool isLoadingCouriers = false;
  String? courierError;
  final List<String> customerCouriers = ['55', '56', '57']; 
  
  
  List<String> pickupOptions = [];
  bool isLoadingPickups = false;
  List<Map<String, dynamic>> serviceCodes = [];
  bool isLoadingServiceCodes = false;
  List<Map<String, dynamic>> pickupLocationsWithIds = [];
  
  
  List<Map<String, dynamic>> courierAccountsWithIds = [];
  
  
  final CourierService _courierService = CourierService();

  
  List<Map<String, dynamic>> keywords = [];
  bool isLoadingKeywords = false;
  bool isLoading = false;

  // Enhanced validation system
  final Map<String, String?> _fieldErrors = <String, String?>{};
  bool _showValidationErrors = false;

  // Validation messages
  String? _getFieldError(String fieldName) {
    if (!_showValidationErrors) {
      
      return null;
    }
    final error = _fieldErrors[fieldName];
   
    return error;
  }

  bool _hasFieldError(String fieldName) {
    final result = _showValidationErrors && _fieldErrors[fieldName] != null;
    
    return result;
  }

  void _clearFieldError(String fieldName) {
    if (_fieldErrors.containsKey(fieldName)) {
      setState(() {
        _fieldErrors.remove(fieldName);
      });
    }
  }

  bool _validateFields() {
    final Map<String, String?> errors = <String, String?>{};

    // Rule title validation
    if (ruleTitleController.text.trim().isEmpty) {
      errors['rule_title'] = 'Rule title is required';
    }

    // Status validation
    if (selectedStatusIds.isEmpty) {
      errors['statuses'] = 'Please select at least one status';
    }

    // Conditions validation
    if (selectedConditions.isEmpty) {
      errors['conditions'] = 'Please select at least one condition';
    }

    // 3PL validation
    if (threePLType == null || threePLType!.isEmpty) {
      errors['three_pl'] = 'Please select 3PL option';
    }

    // Courier validation
    if (courierId == null || courierId!.isEmpty) {
      errors['courier'] = 'Please select a courier';
    }

    // Pickup validation
    if (pickupId == null || pickupId!.isEmpty) {
      errors['pickup'] = 'Please select a pickup location';
    }

    // Service code validation
    if (serviceCodeController.text.trim().isEmpty) {
      errors['service_code'] = 'Please select a service code';
    }

    // Conditional validations based on selected conditions
    if (selectedConditions.contains('Weight')) {
      if (weightType == null || weightType!.isEmpty) {
        errors['weight_type'] = 'Please select weight type';
      }
      if (weightValueController.text.trim().isEmpty) {
        errors['weight_value'] = 'Please enter weight value';
      } else if (double.tryParse(weightValueController.text.trim()) == null) {
        errors['weight_value'] = 'Please enter a valid number';
      }
    }

    if (selectedConditions.contains('Payment Method')) {
      if (paymentMethodId == null || paymentMethodId!.isEmpty) {
        errors['payment_method'] = 'Please select payment method';
    }
    }

    if (selectedConditions.contains('City List')) {
      if (customerCitylistId == null || customerCitylistId!.isEmpty) {
        errors['city_list'] = 'Please select a city';
    }
    }

    if (selectedConditions.contains('Order Value')) {
      if (orderType == null || orderType!.isEmpty) {
        errors['order_type'] = 'Please select order value type';
      }
      if (orderValueController.text.trim().isEmpty) {
        errors['order_value'] = 'Please enter order value';
      } else if (double.tryParse(orderValueController.text.trim()) == null) {
        errors['order_value'] = 'Please enter a valid number';
      }
    }

    if (selectedConditions.contains('Platform')) {
      if (platformType == null || platformType!.isEmpty) {
        errors['platform_type'] = 'Please select a platform';
    }
    }

    if (selectedConditions.contains('Address Keywords')) {
      if (isContain == null || isContain!.isEmpty) {
        errors['is_contain'] = 'Please select contain option';
      }
      if (selectedAddressKeyword == null || selectedAddressKeyword!.isEmpty) {
        errors['address_keyword'] = 'Please select an address keyword';
      }
    }

    setState(() {
      _fieldErrors.clear();
      _fieldErrors.addAll(errors);
      _showValidationErrors = true;
    });

    return errors.isEmpty;
  }

  void _clearAllErrors() {
   
    setState(() {
      _fieldErrors.clear();
      _showValidationErrors = false;
    });
    
  }

  
  final List<String> conditionOptions = [
    'Weight',
    'Payment Method',
    'City List',
    'Order Value',
    'Platform',
    'Address Keywords',
  ];
  List<String> selectedConditions = []; 

  @override
  void initState() {
    super.initState();
    _rulesService = RulesService(_authService);
    _loadUserDataAndFetchKeywords();
    _fetchStatuses();
    _fetchCouriers();
    _fetchCities();
    _fetchPlatforms();
    
    _fetchPickupLocations();
    _fetchServiceCodes();
  }

  Future<void> _loadUserDataAndFetchKeywords() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await _fetchKeywords();
  }

  Future<void> _fetchKeywords() async {
    setState(() {
      isLoadingKeywords = true;
    });
    
    try {
      final keywordsData = await _rulesService.getKeywords();
      setState(() {
        keywords = keywordsData.where((k) => (k['status']?.toString() ?? '') == '1').toList();
        isLoadingKeywords = false;
      });
    } catch (e) {
      setState(() {
        isLoadingKeywords = false;
      });
      customSnackBar('Error', 'Failed to load keywords: ${e.toString()}');
    }
  }

  Future<void> _fetchStatuses() async {
   
    setState(() {
      isLoadingStatuses = true;
      statusError = null;
    });
    try {
      final apiUrl = ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint);

      
      final response = await Dio().post(
        apiUrl,
        data: {"status_type": ["Customer Service"]},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );

      
      
      
      final List<dynamic> data = response.data;
      

      setState(() {
        statuses = data.map((e) => e['name']?.toString() ?? '').toList();
        statusesWithIds = data.map((e) => {
          'id': e['id']?.toString() ?? '',
          'name': e['name']?.toString() ?? '',
        }).toList();
        isLoadingStatuses = false;
      });

     
    } catch (e) {
      print(' Error fetching statuses: $e');
      setState(() {
        statusError = 'Failed to load statuses: $e';
        isLoadingStatuses = false;
      });
    }
  }

  Future<void> _fetchCities() async {
    setState(() {
      isLoadingCities = true;
      citiesError = null;
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          citiesError = 'User not logged in';
          isLoadingCities = false;
        });
        return;
      }

      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.rulesCityListEndpoint),
        data: {"acno": acno},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<String> cityNames = [];
        
        if (data is List) {
          for (var city in data) {
            if (city is Map && city['name'] != null) {
              cityNames.add(city['name'].toString());
            }
          }
        } else if (data is Map && data['payload'] is List) {
          final cityList = data['payload'];
          for (var city in cityList) {
            if (city is Map && city['name'] != null) {
              cityNames.add(city['name'].toString());
            }
          }
        }
        
        setState(() {
          cities = cityNames;
          isLoadingCities = false;
        });
      } else {
        setState(() {
          cities = [];
          isLoadingCities = false;
        });
      }
    } catch (e) {
      setState(() {
        citiesError = 'Failed to load cities';
        isLoadingCities = false;
      });
    }
  }

  Future<void> _fetchPlatforms() async {
    setState(() {
      isLoadingPlatforms = true;
      platformsError = null;
    });
    
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          platformsError = 'User not logged in';
          isLoadingPlatforms = false;
        });
        return;
      }
      
      final service = StatementService();
      final shops = await service.fetchShopNames(acno);
      
      final loadedPlatforms = shops.map((e) =>
        (e['website_name']?.toString().isNotEmpty == true)
          ? e['website_name'].toString()
          : (e['platform_name']?.toString() ?? '')
      ).where((e) => e.isNotEmpty).toList();
      
      setState(() {
        platformTypes = loadedPlatforms;
        isLoadingPlatforms = false;
      });
    } catch (e) {
      setState(() {
        platformsError = 'Failed to load platforms';
        isLoadingPlatforms = false;
      });
    }
  }

  Future<void> _fetchCouriers() async {
    setState(() {
      isLoadingCouriers = true;
      courierError = null;
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          courierError = 'User not logged in';
          isLoadingCouriers = false;
        });
        return;
      }
      
      
      final couriers = await _courierService.getCouriers(acno);
      
     
      
      List<String> courierNames = [];
      List<Map<String, dynamic>> couriersWithIds = [];
      
      for (var courier in couriers) {
        
        final accountTitle = courier['account_title']?.toString() ?? '';
        final courierName = courier['courier_name']?.toString() ?? courier['name']?.toString() ?? '';
        
        String displayName;
        if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
          displayName = '$accountTitle ($courierName)';
        } else if (accountTitle.isNotEmpty) {
          displayName = accountTitle;
        } else {
          displayName = courierName;
        }
        
        if (displayName.isNotEmpty) {
          courierNames.add(displayName);
          couriersWithIds.add({
            'id': courier['id']?.toString() ?? '',
            'courier_id': courier['courier_id']?.toString() ?? '',
            'courier_name': courier['courier_name']?.toString() ?? '',
            'account_title': accountTitle,
            'display_name': displayName,
          });
        }
      }
      
      setState(() {
        courierAccounts = courierNames;
        courierAccountsWithIds = couriersWithIds;
        isLoadingCouriers = false;
      });
    } catch (e) {
      setState(() {
        courierError = 'Failed to load couriers';
        isLoadingCouriers = false;
      });
    }
  }

  Future<void> _fetchPickupLocations({String? courierId, String? customerCourierId}) async {
    setState(() { 
      isLoadingPickups = true; 
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          pickupOptions = [];
          pickupLocationsWithIds = [];
          isLoadingPickups = false;
        });
        return;
      }
      
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.pickupShowEndpoint),
        data: {
          "acno": acno,
          "courier_id": int.tryParse(courierId ?? '1') ?? 1,
          "customer_courier_id": int.tryParse(customerCourierId ?? '55') ?? 55,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<String> options = [];
        List<Map<String, dynamic>> locationsWithIds = [];
        
        if (data is Map && data['pickuplocation'] is List) {
          final locations = data['pickuplocation'];
          for (var location in locations) {
            if (location is Map && location['pickuplocation_name'] != null) {
              options.add(location['pickuplocation_name'].toString());
              locationsWithIds.add({
                'id': location['id']?.toString() ?? '',
                'name': location['pickuplocation_name']?.toString() ?? '',
              });
            }
          }
        } else if (data is Map && data['payload'] is List) {
          final locations = data['payload'];
          for (var location in locations) {
            if (location is Map && location['pickuplocation_name'] != null) {
              options.add(location['pickuplocation_name'].toString());
              locationsWithIds.add({
                'id': location['id']?.toString() ?? '',
                'name': location['pickuplocation_name']?.toString() ?? '',
              });
            }
          }
        }
        
        setState(() {
          pickupOptions = options;
          pickupLocationsWithIds = locationsWithIds;
          if (!pickupOptions.contains(pickupId)) {
            pickupId = null;
          }
          isLoadingPickups = false;
        });
      } else {
        setState(() {
          pickupOptions = [];
          pickupLocationsWithIds = [];
          pickupId = null;
          isLoadingPickups = false;
        });
      }
    } catch (e) {
      setState(() {
        pickupOptions = [];
        pickupLocationsWithIds = [];
        pickupId = null;
        isLoadingPickups = false;
      });
    }
  }

  String _getServiceDisplayName(String serviceCode) {
    final service = serviceCodes.firstWhere(
      (e) => e['service_code'] == serviceCode,
      orElse: () => {'service_code': serviceCode, 'service_name': serviceCode},
    );
    return service['service_name'] ?? serviceCode;
  }

  Future<void> _fetchServiceCodes({String? courierId, String? customerCourierId}) async {
    setState(() { 
      isLoadingServiceCodes = true; 
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          serviceCodes = [];
          isLoadingServiceCodes = false;
        });
        return;
      }
      
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderGetServiceCodeEndpoint),
        data: {
          "acno": acno,
          "courier_id": int.tryParse(courierId ?? '1') ?? 1,
          "customer_courier_id": int.tryParse(customerCourierId ?? '55') ?? 55,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<Map<String, dynamic>> codes = [];
        
        if (data is Map && data['service_code'] is List) {
          final rawList = data['service_code'];
          if (rawList.isNotEmpty && rawList.first is Map && rawList.first.containsKey('service_code')) {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e['service_code']?.toString() ?? '',
              'service_name': e['service_name']?.toString() ?? e['service_code']?.toString() ?? '',
            }));
          } else {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e.toString(),
              'service_name': e.toString(),
            }));
          }
        } else if (data is Map && data['payload'] is List) {
          final rawList = data['payload'];
          if (rawList.isNotEmpty && rawList.first is Map && rawList.first.containsKey('service_code')) {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e['service_code']?.toString() ?? '',
              'service_name': e['service_name']?.toString() ?? e['service_code']?.toString() ?? '',
            }));
          } else {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e.toString(),
              'service_name': e.toString(),
            }));
          }
        }
        
        setState(() {
          serviceCodes = codes;
          if (serviceCodeController.text.isNotEmpty && !serviceCodes.any((e) => e['service_code'] == serviceCodeController.text)) {
            serviceCodeController.clear();
          }
          isLoadingServiceCodes = false;
        });
      } else {
        setState(() {
          serviceCodes = [];
          serviceCodeController.clear();
          isLoadingServiceCodes = false;
        });
      }
    } catch (e) {
      setState(() {
        serviceCodes = [];
        serviceCodeController.clear();
        isLoadingServiceCodes = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: true,
      extendBody: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        foregroundColor: Colors.white,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Get.back(),
        ),
        title: const Text(
          'Create Rules',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              const SizedBox(height: 16),
              
              Container(
                width: double.infinity,
                margin: const EdgeInsets.only(bottom: 20),
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                decoration: BoxDecoration(
                  color: const Color(0xFF181A3D),
                  borderRadius: BorderRadius.circular(12),
                  image: const DecorationImage(
                    image: AssetImage('assets/rule_banner.png'),
                    fit: BoxFit.cover,
                    alignment: Alignment.centerRight,
                    opacity: 0.2,
                  ),
                ),
                child: const Column(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Text('Attention!', textAlign: TextAlign.center, style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16)),
                    SizedBox(height: 4),
                    Text(
                      'Rules will automatically apply in intervals of 10 minutes after the rule is added.',
                      textAlign: TextAlign.center,
                      style: TextStyle(color: Colors.white, fontSize: 13),
                    ),
                  ],
                ),
              ),
                             
               Container(
                 margin: const EdgeInsets.only(bottom: 8),
                 padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 3),
                 decoration: BoxDecoration(
                   color: const Color(0xFFF5F5F7),
                   borderRadius: BorderRadius.circular(14),
                   border: Border.all(
                     color: _hasFieldError('rule_title') ? Colors.red : Colors.transparent, 
                     width: _hasFieldError('rule_title') ? 1.5 : 0
                   ),
                   boxShadow: [
                     BoxShadow(
                       color: Colors.grey.withOpacity(0.08),
                       blurRadius: 8,
                       offset: const Offset(0, 2),
                     ),
                   ],
                 ),
                 child: TextFormField(
                   controller: ruleTitleController,
                   decoration: InputDecoration(
                     hintText: 'Rule Title',
                     border: InputBorder.none,
                     contentPadding: const EdgeInsets.symmetric(vertical: 14),
                     hintStyle: GoogleFonts.poppins(fontSize: 15, color: Colors.grey),
                     errorText: null, // Remove errorText to prevent size changes
                   ),
                   style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
                   onChanged: (value) {
                     if (_hasFieldError('rule_title')) {
                       _clearFieldError('rule_title');
                     }
                   },
                 ),
               ),
               if (_hasFieldError('rule_title'))
                 Container(
                   margin: const EdgeInsets.only(bottom: 8, left: 16),
                   child: Text(
                     _getFieldError('rule_title')!,
                     style: GoogleFonts.poppins(
                       fontSize: 12,
                       color: Colors.red,
                     ),
                 ),
               ),
              const SizedBox(height: 2),
          
              
              Container(
                margin: const EdgeInsets.only(bottom: 8),
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                decoration: BoxDecoration(
                  color: const Color(0xFFF5F5F7),
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(
                    color: _hasFieldError('statuses') ? Colors.red : Colors.transparent, 
                    width: _hasFieldError('statuses') ? 1.5 : 0
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.grey.withOpacity(0.08),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: GestureDetector(
                  onTap: () async {
                    final result = await showModalBottomSheet<List<String>>(
                context: context,
                      isScrollControlled: true,
                      backgroundColor: Colors.transparent,
                      builder: (ctx) => _CustomMultiSelectDialog(
                items: statuses.map((e) => MultiSelectItem<String>(e, e)).toList(),
                        initialValues: selectedStatusIds,
                onConfirm: (values) {
                          Navigator.of(ctx).pop(values);
                        },
                        title: 'Select Status',
                      ),
                    );
                    if (result != null) {
                  setState(() {
                        selectedStatusIds = result;
                        if (_hasFieldError('statuses')) {
                          _clearFieldError('statuses');
                        }
                      });
                    }
                  },
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          selectedStatusIds.isEmpty 
                              ? 'Select Status' 
                              : selectedStatusIds.join(', '),
                          style: GoogleFonts.poppins(
                            fontSize: 15, 
                            color: selectedStatusIds.isEmpty ? Colors.grey : Colors.black
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 2,
                        ),
                      ),
                      const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                    ],
                  ),
                ),
              ),
              if (_hasFieldError('statuses'))
                Container(
                  margin: const EdgeInsets.only(bottom: 8, left: 16),
                  child: Text(
                    _getFieldError('statuses')!,
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.red,
                    ),
                  ),
                ),
              const SizedBox(height: 2),
              
              
              Container(
                margin: const EdgeInsets.only(bottom: 8),
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                decoration: BoxDecoration(
                  color: const Color(0xFFF5F5F7),
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(
                    color: _hasFieldError('conditions') ? Colors.red : Colors.transparent, 
                    width: _hasFieldError('conditions') ? 1.5 : 0
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.grey.withOpacity(0.08),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: GestureDetector(
                  onTap: () async {
                    final result = await showModalBottomSheet<List<String>>(
                context: context,
                      isScrollControlled: true,
                      backgroundColor: Colors.transparent,
                      builder: (ctx) => _CustomMultiSelectDialog(
                items: conditionOptions.map((e) => MultiSelectItem<String>(e, e)).toList(),
                        initialValues: selectedConditions,
                onConfirm: (values) {
                          Navigator.of(ctx).pop(values);
                        },
                        title: 'Select Conditions',
                      ),
                    );
                    if (result != null) {
                  setState(() {
                        selectedConditions = result;
                        // Clear related field errors when conditions change
                        _clearFieldError('weight_type');
                        _clearFieldError('weight_value');
                        _clearFieldError('payment_method');
                        _clearFieldError('city_list');
                        _clearFieldError('order_type');
                        _clearFieldError('order_value');
                        _clearFieldError('platform_type');
                        _clearFieldError('is_contain');
                        _clearFieldError('address_keyword');
                      });
                    }
                  },
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          selectedConditions.isEmpty 
                              ? 'Select Conditions' 
                              : selectedConditions.join(', '),
                          style: GoogleFonts.poppins(
                            fontSize: 15, 
                            color: selectedConditions.isEmpty ? Colors.grey : Colors.black
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 2,
                        ),
                      ),
                      const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                    ],
                  ),
                ),
              ),
              if (_hasFieldError('conditions'))
                Container(
                  margin: const EdgeInsets.only(bottom: 8, left: 16),
                  child: Text(
                    _getFieldError('conditions')!,
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.red,
                    ),
                  ),
              ),
              const SizedBox(height: 2),
              
              
              if (selectedConditions.contains('Weight')) ...[
                Row(
                  children: [
                    Expanded(
                      flex: 2,
                      child: Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('weight_type') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('weight_type') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: GestureDetector(
                          onTap: () async {
                            final result = await showModalBottomSheet<String>(
                        context: context,
                              isScrollControlled: true,
                              backgroundColor: Colors.transparent,
                              builder: (ctx) => _CustomSingleSelectDialog(
                        items: [
                          '=',
                          '<',
                          '>',
                          '<=',
                          '>=',
                        ],
                                initialValue: weightType,
                        onConfirm: (value) {
                                  Navigator.of(ctx).pop(value);
                                },
                                title: 'Weight Type',
                              ),
                            );
                            if (result != null) {
                          setState(() {
                                weightType = result;
                                if (_hasFieldError('weight_type')) {
                                  _clearFieldError('weight_type');
                                }
                              });
                            }
                          },
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  weightType ?? 'Weight Type',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15, 
                                    color: weightType == null ? Colors.grey : Colors.black
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      flex: 2,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 3),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('weight_value') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('weight_value') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: TextFormField(
                          controller: weightValueController,
                          decoration: InputDecoration(
                            hintText: 'Weight Value',
                            border: InputBorder.none,
                            contentPadding: const EdgeInsets.symmetric(vertical: 14),
                            hintStyle: GoogleFonts.poppins(fontSize: 15, color: Colors.grey),
                          ),
                          keyboardType: TextInputType.number,
                          style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
                          onChanged: (value) {
                            if (_hasFieldError('weight_value')) {
                              _clearFieldError('weight_value');
                            }
                          },
                        ),
                      ),
                    ),
                  ],
                ),
                if (_hasFieldError('weight_type') || _hasFieldError('weight_value'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (_hasFieldError('weight_type'))
                          Text(
                            _getFieldError('weight_type')!,
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              color: Colors.red,
                            ),
                          ),
                        if (_hasFieldError('weight_value'))
                          Text(
                            _getFieldError('weight_value')!,
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              color: Colors.red,
                            ),
                          ),
                      ],
                    ),
                ),
                const SizedBox(height: 8),
              ],
              
              if (selectedConditions.contains('Payment Method')) ...[
                Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(14),
                    border: Border.all(
                      color: _hasFieldError('payment_method') ? Colors.red : Colors.transparent, 
                      width: _hasFieldError('payment_method') ? 1.5 : 0
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.grey.withOpacity(0.08),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: GestureDetector(
                    onTap: () async {
                      final result = await showModalBottomSheet<String>(
                  context: context,
                        isScrollControlled: true,
                        backgroundColor: Colors.transparent,
                        builder: (ctx) => _CustomSingleSelectDialog(
                  items: paymentMethods,
                          initialValue: paymentMethodId,
                  onConfirm: (value) {
                            Navigator.of(ctx).pop(value);
                          },
                          title: 'Select Payment Method',
                        ),
                      );
                      if (result != null) {
                    setState(() {
                          paymentMethodId = result;
                          if (_hasFieldError('payment_method')) {
                            _clearFieldError('payment_method');
                          }
                        });
                      }
                    },
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            paymentMethodId ?? 'Select Payment Method',
                            style: GoogleFonts.poppins(
                              fontSize: 15, 
                              color: paymentMethodId == null ? Colors.grey : Colors.black
                            ),
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        ),
                        const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                      ],
                    ),
                  ),
                ),
                if (_hasFieldError('payment_method'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Text(
                      _getFieldError('payment_method')!,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.red,
                      ),
                    ),
                ),
                const SizedBox(height: 8),
              ],
              
              if (selectedConditions.contains('City List')) ...[
                isLoadingCities
                  ? Container(
                      margin: const EdgeInsets.only(bottom: 8),
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                      decoration: BoxDecoration(
                        color: const Color(0xFFF5F5F7),
                        borderRadius: BorderRadius.circular(14),
                        border: Border.all(color: Colors.transparent, width: 0),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.grey.withOpacity(0.08),
                            blurRadius: 8,
                            offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                      child: const Row(
                        children: [
                          SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          ),
                          SizedBox(width: 12),
                          Text('Loading cities...', style: TextStyle(color: Colors.grey)),
                        ],
                      ),
                    )
                  : cities.isEmpty
                    ? Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(color: Colors.transparent, width: 0),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: const Text('No cities available', style: TextStyle(color: Colors.grey)),
                      )
                    : Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('city_list') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('city_list') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: GestureDetector(
                          onTap: () async {
                            final result = await showModalBottomSheet<String>(
                        context: context,
                              isScrollControlled: true,
                              backgroundColor: Colors.transparent,
                              builder: (ctx) => _CustomSingleSelectDialog(
                        items: cities,
                                initialValue: customerCitylistId,
                        onConfirm: (value) {
                                  Navigator.of(ctx).pop(value);
                                },
                                title: 'Select City',
                              ),
                            );
                            if (result != null) {
                          setState(() {
                                customerCitylistId = result;
                                if (_hasFieldError('city_list')) {
                                  _clearFieldError('city_list');
                                }
                              });
                            }
                          },
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  customerCitylistId ?? 'Select City',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15, 
                                    color: customerCitylistId == null ? Colors.grey : Colors.black
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                if (_hasFieldError('city_list'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Text(
                      _getFieldError('city_list')!,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.red,
                      ),
                    ),
                      ),
                const SizedBox(height: 8),
              ],
              
              if (selectedConditions.contains('Order Value')) ...[
                Row(
                  children: [
                    Expanded(
                      flex: 2,
                      child: Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('order_type') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('order_type') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: GestureDetector(
                          onTap: () async {
                            final result = await showModalBottomSheet<String>(
                        context: context,
                              isScrollControlled: true,
                              backgroundColor: Colors.transparent,
                              builder: (ctx) => _CustomSingleSelectDialog(
                        items: [
                          '=',
                          '<',
                          '>',
                          '<=',
                          '>=',
                        ],
                                initialValue: orderType,
                        onConfirm: (value) {
                                  Navigator.of(ctx).pop(value);
                                },
                                title: 'Order Value',
                              ),
                            );
                            if (result != null) {
                          setState(() {
                                orderType = result;
                                if (_hasFieldError('order_type')) {
                                  _clearFieldError('order_type');
                                }
                              });
                            }
                          },
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  orderType ?? 'Order Value',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15, 
                                    color: orderType == null ? Colors.grey : Colors.black
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      flex: 2,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 3),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('order_value') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('order_value') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: TextFormField(
                          controller: orderValueController,
                          decoration: InputDecoration(
                            hintText: 'Order Amount',
                            border: InputBorder.none,
                            contentPadding: const EdgeInsets.symmetric(vertical: 14),
                            hintStyle: GoogleFonts.poppins(fontSize: 15, color: Colors.grey),
                          ),
                          keyboardType: TextInputType.number,
                          style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
                          onChanged: (value) {
                            if (_hasFieldError('order_value')) {
                              _clearFieldError('order_value');
                            }
                          },
                        ),
                      ),
                    ),
                  ],
                ),
                if (_hasFieldError('order_type') || _hasFieldError('order_value'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (_hasFieldError('order_type'))
                          Text(
                            _getFieldError('order_type')!,
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              color: Colors.red,
                            ),
                          ),
                        if (_hasFieldError('order_value'))
                          Text(
                            _getFieldError('order_value')!,
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              color: Colors.red,
                            ),
                          ),
                      ],
                    ),
                ),
                const SizedBox(height: 8),
              ],
              
              if (selectedConditions.contains('Platform')) ...[
                isLoadingPlatforms
                  ? Container(
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                      decoration: BoxDecoration(
                        color: const Color(0xFFF5F5F7),
                        borderRadius: BorderRadius.circular(14),
                        border: Border.all(color: Colors.transparent, width: 0),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.grey.withOpacity(0.08),
                            blurRadius: 8,
                            offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                      child: const Row(
                        children: [
                          SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          ),
                          SizedBox(width: 12),
                          Text('Loading platforms...', style: TextStyle(color: Colors.grey)),
                        ],
                      ),
                    )
                  : platformTypes.isEmpty
                    ? Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(color: Colors.transparent, width: 0),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: const Text('No platforms available', style: TextStyle(color: Colors.grey)),
                      )
                    : Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('platform_type') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('platform_type') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: GestureDetector(
                          onTap: () async {
                            final result = await showModalBottomSheet<String>(
                        context: context,
                              isScrollControlled: true,
                              backgroundColor: Colors.transparent,
                              builder: (ctx) => _CustomSingleSelectDialog(
                        items: platformTypes,
                                initialValue: platformType,
                        onConfirm: (value) {
                                  Navigator.of(ctx).pop(value);
                                },
                                title: 'Select Platform',
                              ),
                            );
                            if (result != null) {
                          setState(() {
                                platformType = result;
                                if (_hasFieldError('platform_type')) {
                                  _clearFieldError('platform_type');
                                }
                              });
                            }
                          },
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  platformType ?? 'Select Platform',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15, 
                                    color: platformType == null ? Colors.grey : Colors.black
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                if (_hasFieldError('platform_type'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Text(
                      _getFieldError('platform_type')!,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.red,
                      ),
                    ),
                      ),
                const SizedBox(height: 8),
              ],
              
              if (selectedConditions.contains('Address Keywords')) ...[
                Row(
                  children: [
                    Expanded(
                      flex: 2,
                      child: isLoadingKeywords
                        ? Container(
                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                            decoration: BoxDecoration(
                              color: const Color(0xFFF5F5F7),
                              borderRadius: BorderRadius.circular(14),
                              border: Border.all(color: Colors.transparent, width: 0),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.grey.withOpacity(0.08),
                                  blurRadius: 8,
                                  offset: const Offset(0, 2),
                                ),
                              ],
                            ),
                            child: const Row(
                              children: [
                                SizedBox(
                                  width: 16,
                                  height: 16,
                                  child: CircularProgressIndicator(strokeWidth: 2),
                                ),
                                SizedBox(width: 12),
                                Text('Loading keywords...', style: TextStyle(color: Colors.grey)),
                              ],
                            ),
                          )
                        : keywords.isEmpty
                          ? Container(
                              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                              decoration: BoxDecoration(
                                color: const Color(0xFFF5F5F7),
                                borderRadius: BorderRadius.circular(14),
                                border: Border.all(color: Colors.transparent, width: 0),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.grey.withOpacity(0.08),
                                    blurRadius: 8,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: const Text('No keywords available', style: TextStyle(color: Colors.grey)),
                            )
                          : Container(
                              margin: const EdgeInsets.only(bottom: 8),
                              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                              decoration: BoxDecoration(
                                color: const Color(0xFFF5F5F7),
                                borderRadius: BorderRadius.circular(14),
                                border: Border.all(
                                  color: _hasFieldError('is_contain') ? Colors.red : Colors.transparent, 
                                  width: _hasFieldError('is_contain') ? 1.5 : 0
                                ),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.grey.withOpacity(0.08),
                                    blurRadius: 8,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: GestureDetector(
                                onTap: () async {
                                  final result = await showModalBottomSheet<String>(
                              context: context,
                                    isScrollControlled: true,
                                    backgroundColor: Colors.transparent,
                                    builder: (ctx) => _CustomSingleSelectDialog(
                              items: containOptions,
                                      initialValue: isContain,
                              onConfirm: (value) {
                                        Navigator.of(ctx).pop(value);
                                      },
                                      title: 'Select Contain Option',
                                    ),
                                  );
                                  if (result != null) {
                                setState(() {
                                      isContain = result;
                                      if (_hasFieldError('is_contain')) {
                                        _clearFieldError('is_contain');
                                      }
                                    });
                                  }
                                },
                                child: Row(
                                  children: [
                                    Expanded(
                                      child: Text(
                                        isContain ?? 'Select Contain Option',
                                        style: GoogleFonts.poppins(
                                          fontSize: 15, 
                                          color: isContain == null ? Colors.grey : Colors.black
                                        ),
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                                      ),
                                    ),
                                    const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                                  ],
                                ),
                              ),
                            ),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      flex: 3,
                      child: Container(
                        margin: const EdgeInsets.only(bottom: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                        decoration: BoxDecoration(
                          color: const Color(0xFFF5F5F7),
                          borderRadius: BorderRadius.circular(14),
                          border: Border.all(
                            color: _hasFieldError('address_keyword') ? Colors.red : Colors.transparent, 
                            width: _hasFieldError('address_keyword') ? 1.5 : 0
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.grey.withOpacity(0.08),
                              blurRadius: 8,
                              offset: const Offset(0, 2),
                            ),
                          ],
                        ),
                        child: GestureDetector(
                          onTap: () async {
                            final result = await showModalBottomSheet<String>(
                        context: context,
                              isScrollControlled: true,
                              backgroundColor: Colors.transparent,
                              builder: (ctx) => _CustomSingleSelectDialog(
                        items: keywords.map((k) => k['title']?.toString() ?? '').where((s) => s.isNotEmpty).toList(),
                                initialValue: selectedAddressKeyword != null 
                          ? keywords.firstWhere(
                              (k) => k['id'].toString() == selectedAddressKeyword,
                              orElse: () => {'title': ''},
                            )['title']?.toString()
                          : null,
                        onConfirm: (value) {
                                  Navigator.of(ctx).pop(value);
                                },
                                title: 'Select Keyword',
                              ),
                            );
                            if (result != null) {
                            final keyword = keywords.firstWhere(
                                (k) => k['title']?.toString() == result,
                              orElse: () => {'id': ''},
                            );
                            setState(() {
                              selectedAddressKeyword = keyword['id']?.toString();
                                if (_hasFieldError('address_keyword')) {
                                  _clearFieldError('address_keyword');
                                }
                            });
                          }
                        },
                          child: Row(
                            children: [
                              Expanded(
                                child: Text(
                                  selectedAddressKeyword != null 
                                    ? keywords.firstWhere(
                                        (k) => k['id'].toString() == selectedAddressKeyword,
                                        orElse: () => {'title': ''},
                                      )['title']?.toString() ?? 'Select Keyword'
                                    : 'Select Keyword',
                                  style: GoogleFonts.poppins(
                                    fontSize: 15, 
                                    color: selectedAddressKeyword == null ? Colors.grey : Colors.black
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                  maxLines: 1,
                                ),
                              ),
                              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                if (_hasFieldError('is_contain') || _hasFieldError('address_keyword'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (_hasFieldError('is_contain'))
                          Text(
                            _getFieldError('is_contain')!,
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              color: Colors.red,
                            ),
                          ),
                        if (_hasFieldError('address_keyword'))
                          Text(
                            _getFieldError('address_keyword')!,
                            style: GoogleFonts.poppins(
                              fontSize: 12,
                              color: Colors.red,
                            ),
                          ),
                      ],
                    ),
                ),
                const SizedBox(height: 8),
              ],
              
              
              Container(
                margin: const EdgeInsets.only(bottom: 8),
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                decoration: BoxDecoration(
                  color: const Color(0xFFF5F5F7),
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(
                    color: _hasFieldError('three_pl') ? Colors.red : Colors.transparent, 
                    width: _hasFieldError('three_pl') ? 1.5 : 0
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.grey.withOpacity(0.08),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: GestureDetector(
                  onTap: () async {
                    final result = await showModalBottomSheet<String>(
                context: context,
                      isScrollControlled: true,
                      backgroundColor: Colors.transparent,
                      builder: (ctx) => _CustomSingleSelectDialog(
                items: ['3PL'],
                        initialValue: threePLType,
                onConfirm: (value) {
                          Navigator.of(ctx).pop(value);
                        },
                        title: '3PL',
                      ),
                    );
                    if (result != null) {
                  setState(() {
                        threePLType = result;
                        if (_hasFieldError('three_pl')) {
                          _clearFieldError('three_pl');
                        }
                      });
                    }
                  },
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          threePLType ?? '3PL',
                          style: GoogleFonts.poppins(
                            fontSize: 15, 
                            color: threePLType == null ? Colors.grey : Colors.black
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                      ),
                      const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                    ],
                  ),
                ),
              ),
              if (_hasFieldError('three_pl'))
                Container(
                  margin: const EdgeInsets.only(bottom: 8, left: 16),
                  child: Text(
                    _getFieldError('three_pl')!,
                    style: GoogleFonts.poppins(
                      fontSize: 12,
                      color: Colors.red,
                    ),
                  ),
              ),
              const SizedBox(height: 8),
              
                             
               Container(
                 margin: const EdgeInsets.only(bottom: 8),
                 padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                 decoration: BoxDecoration(
                   color: const Color(0xFFF5F5F7),
                   borderRadius: BorderRadius.circular(14),
                   border: Border.all(
                     color: _hasFieldError('courier') ? Colors.red : Colors.transparent, 
                     width: _hasFieldError('courier') ? 1.5 : 0
                   ),
                   boxShadow: [
                     BoxShadow(
                       color: Colors.grey.withOpacity(0.08),
                       blurRadius: 8,
                       offset: const Offset(0, 2),
                     ),
                   ],
                 ),
                 child: GestureDetector(
                   onTap: () async {
                     final result = await showModalBottomSheet<String>(
                 context: context,
                       isScrollControlled: true,
                       backgroundColor: Colors.transparent,
                       builder: (ctx) => _CustomSingleSelectDialog(
                 items: courierAccounts,
                         initialValue: courierId,
                 onConfirm: (value) {
                           Navigator.of(ctx).pop(value);
                         },
                         title: 'Select Courier',
                       ),
                     );
                     if (result != null) {
                   setState(() {
                         courierId = result;
                         if (_hasFieldError('courier')) {
                           _clearFieldError('courier');
                         }
                     
                     pickupId = null;
                     serviceCodeController.clear();
                   });
                   
                       // Fetch pickup locations and service codes for selected courier
                       if (result != null) {
                     final selectedCourier = courierAccountsWithIds.firstWhere(
                           (c) => c['display_name']?.toString() == result,
                       orElse: () => <String, Object>{},
                     );
                     
                     final courierId = selectedCourier['courier_id']?.toString();
                     final customerCourierId = selectedCourier['id']?.toString();
                     
                     setState(() {
                       this.customerCourierId = customerCourierId;
                     });
                     
                     if (courierId != null && customerCourierId != null) {
                       _fetchPickupLocations(courierId: courierId, customerCourierId: customerCourierId);
                       _fetchServiceCodes(courierId: courierId, customerCourierId: customerCourierId);
                     }
                   } else {
                     setState(() {
                       customerCourierId = null;
                       pickupOptions = [];
                       pickupLocationsWithIds = [];
                       pickupId = null;
                       serviceCodes = [];
                     });
                       }
                     }
                   },
                   child: Row(
                     children: [
                       Expanded(
                         child: Text(
                           courierId ?? 'Select Courier',
                           style: GoogleFonts.poppins(
                             fontSize: 15, 
                             color: courierId == null ? Colors.grey : Colors.black
                           ),
                           overflow: TextOverflow.ellipsis,
                           maxLines: 1,
                         ),
                       ),
                       const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                     ],
                   ),
                 ),
               ),
               if (_hasFieldError('courier'))
                 Container(
                   margin: const EdgeInsets.only(bottom: 8, left: 16),
                   child: Text(
                     _getFieldError('courier')!,
                     style: GoogleFonts.poppins(
                       fontSize: 12,
                       color: Colors.red,
                     ),
                   ),
                 ),
                               
                Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(14),
                    border: Border.all(
                      color: _hasFieldError('pickup') ? Colors.red : Colors.transparent, 
                      width: _hasFieldError('pickup') ? 1.5 : 0
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.grey.withOpacity(0.08),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: GestureDetector(
                  onTap: (courierId == null || pickupOptions.isEmpty) 
                      ? () {
                          if (courierId == null) {
                            customSnackBar('Info', 'Please select a courier first to see pickup options');
                          } else if (pickupOptions.isEmpty) {
                            customSnackBar('Info', 'No pickup locations available for the selected courier');
                          }
                        }
                      : () async {
                          final result = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (ctx) => _PickupSelectDialog(
                              items: pickupOptions,
                              initialValue: pickupId,
                              title: 'Pickup',
                              isLoading: isLoadingPickups,
                            ),
                          );
                    if (result != null) {
                              setState(() {
                                pickupId = result;
                                if (_hasFieldError('pickup')) {
                                  _clearFieldError('pickup');
                                }
                              });
                      final pickupLocation = pickupLocationsWithIds.firstWhere(
                        (p) => (p['name']?.toString()?.trim() ?? '') == result.trim(),
                        orElse: () => <String, Object>{},
                      );
                            }
                          },
                   child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            pickupId ?? (courierId == null ? 'Pickup' : 'Pickup'),
                            style: GoogleFonts.poppins(
                              fontSize: 15, 
                              color: pickupId == null ? Colors.grey : Colors.black
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        if (isLoadingPickups)
                          Padding(
                            padding: const EdgeInsets.only(left: 8),
                            child: SizedBox(
                              width: 18,
                              height: 18,
                              child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF007AFF)),
                            ),
                          ),
                        Icon(
                          Icons.keyboard_arrow_down_rounded, 
                          color: (courierId == null) ? Colors.grey : Color(0xFF222222)
                        ),
                      ],
                    ),
                  ),
                ),
                if (_hasFieldError('pickup'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Text(
                      _getFieldError('pickup')!,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.red,
                    ),
                 ),
               ),
                               
                Container(
                  margin: const EdgeInsets.only(bottom: 8),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(14),
                    border: Border.all(
                      color: _hasFieldError('service_code') ? Colors.red : Colors.transparent, 
                      width: _hasFieldError('service_code') ? 1.5 : 0
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.grey.withOpacity(0.08),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: GestureDetector(
                  onTap: (courierId == null || serviceCodes.isEmpty || isLoadingServiceCodes)
                      ? null
                      : () async {
                          final options = serviceCodes.map((e) => e['service_name']?.toString() ?? e['service_code']?.toString() ?? '').toList().cast<String>();
                          final result = await showModalBottomSheet<String>(
                            context: context,
                            isScrollControlled: true,
                            backgroundColor: Colors.transparent,
                            builder: (ctx) => _SingleSelectDialog(
                              items: options,
                              initialValue: serviceCodeController.text.isNotEmpty ? serviceCodeController.text : null,
                              title: 'Service Code',
                            ),
                          );
                          if (result != null) {
                            setState(() {
                              // Find the selected service and store its code
                              final selectedService = serviceCodes.firstWhere(
                                (e) => (e['service_name']?.toString() ?? e['service_code']?.toString() ?? '') == result,
                                orElse: () => {'service_code': result, 'service_name': result},
                              );
                              serviceCodeController.text = selectedService['service_code'] ?? result;
                                if (_hasFieldError('service_code')) {
                                  _clearFieldError('service_code');
                                }
                            });
                          }
                        },
                                       child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            (courierId == null) 
                                ? 'Service Code' 
                                : (serviceCodeController.text.isNotEmpty ? _getServiceDisplayName(serviceCodeController.text) : 'Service Code'),
                            style: GoogleFonts.poppins(
                              fontSize: 15, 
                              color: (courierId == null) 
                                  ? Colors.grey 
                                  : (serviceCodeController.text.isEmpty ? Colors.grey : Colors.black)
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        if (isLoadingServiceCodes)
                          Padding(
                            padding: const EdgeInsets.only(left: 8),
                            child: SizedBox(
                              width: 18,
                              height: 18,
                              child: CircularProgressIndicator(strokeWidth: 2, color: Color(0xFF007AFF)),
                            ),
                          ),
                        Icon(
                          Icons.keyboard_arrow_down_rounded, 
                          color: (courierId == null) ? Colors.grey : Color(0xFF222222)
                        ),
                      ],
                    ),
                  ),
                ),
                if (_hasFieldError('service_code'))
                  Container(
                    margin: const EdgeInsets.only(bottom: 8, left: 16),
                    child: Text(
                      _getFieldError('service_code')!,
                      style: GoogleFonts.poppins(
                        fontSize: 12,
                        color: Colors.red,
                    ),
                 ),
               ),
              const SizedBox(height: 8),
              

             
             const SizedBox(height: 24),
              
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF007AFF),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  onPressed: isLoading
                      ? null
                      : () async {
                          
                          
                          // Clear any previous errors first
                          _clearAllErrors();
                          
                          
                          // Validate on submit
                          final formOk = _formKey.currentState?.validate() ?? false;
                         
                          
                          final fieldsOk = _validateFields();
                          
                          
                          if (!formOk || !fieldsOk) {
                           
                            
                            // Force show validation errors
                            setState(() {
                              _showValidationErrors = true;
                            });
                            
                            
                            
                            // Show specific error message
                            if (!formOk) {
                            customSnackBar('Error', 'Please fill all required fields');
                            } else {
                              customSnackBar('Error', 'Please complete all required selections');
                            }
                            return;
                          }
                          
                          
                          await _createRule();
                        },
                  child: isLoading
                    ? const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      )
                    : const Text('Create Rule', style: TextStyle(fontSize: 18, color: Colors.white)),
                ),
              ),
              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: MediaQuery.of(context).viewInsets.bottom == 0
          ? FloatingActionButton(
              onPressed: () {
                Get.to(() => CreateOrderScreen());
              },
              backgroundColor: const Color(0xFF0A253B),
              elevation: 4,
              shape: const CircleBorder(),
              child: SvgPicture.asset(
                'assets/Create Order.svg',
                width: 28,
                height: 28,
                color: Colors.white,
              ),
            )
          : null,
      bottomNavigationBar: const AppBottomBar(selectedIndex: 2),
    );
  }

  Widget _customMultiSelectField({
    required BuildContext context,
    required String title,
    required List<MultiSelectItem<String>> items,
    required List<String> selectedItems,
    required void Function(List<String>) onConfirm,
    bool hasError = false,
    String? errorMessage,
  }) {
    return GestureDetector(
      onTap: () async {
        final result = await showModalBottomSheet<List<String>>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (ctx) => _CustomMultiSelectDialog(
            items: items,
            initialValues: selectedItems,
            onConfirm: (values) {
              Navigator.of(ctx).pop(values);
            },
            title: title,
          ),
        );
        if (result != null) {
          onConfirm(result);
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.transparent, width: 0),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                selectedItems.isEmpty 
                    ? title 
                    : selectedItems.join(', '),
                style: GoogleFonts.poppins(fontSize: 15, color: selectedItems.isEmpty ? Colors.grey : Colors.black),
                overflow: TextOverflow.ellipsis,
                maxLines: 2,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }

  Widget _customSingleSelectField({
    required BuildContext context,
    required String title,
    required List<String> items,
    required String? selectedItem,
    required void Function(String?) onConfirm,
    bool hasError = false,
    String? errorMessage,
  }) {
    return GestureDetector(
      onTap: () async {
        final result = await showModalBottomSheet<String>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (ctx) => _CustomSingleSelectDialog(
            items: items,
            initialValue: selectedItem,
            onConfirm: (value) {
              Navigator.of(ctx).pop(value);
            },
            title: title,
            hasError: hasError,
            errorMessage: errorMessage,
          ),
        );
        if (result != null) {
          onConfirm(result);
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.transparent, width: 0),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                selectedItem ?? title,
                style: GoogleFonts.poppins(fontSize: 15, color: selectedItem == null ? Colors.grey : Colors.black),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }

  Future<void> _createRule() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        isLoading = true;
      });
      
      try {
        print(' Selected Status Names: $selectedStatusIds');
       
        
        
        List<String> statusIds = selectedStatusIds.isNotEmpty 
          ? statusesWithIds
              .where((status) => selectedStatusIds.contains(status['name']))
              .map((status) => status['id'].toString())
              .toList()
          : [];
        
        // Prepare the data for API call
        final ruleData = {
          'title': ruleTitleController.text,
          'statusIds': statusIds,
          'weightType': selectedConditions.contains('Weight') ? weightType : null,
          'weightValue': selectedConditions.contains('Weight') ? weightValueController.text : null,
          'paymentMethodId': selectedConditions.contains('Payment Method') ? paymentMethodId : null,
          'customerCitylistId': selectedConditions.contains('City List') ? customerCitylistId : null,
          'orderType': selectedConditions.contains('Order Value') ? orderType : null,
          'orderValue': selectedConditions.contains('Order Value') ? orderValueController.text : null,
          'platformType': selectedConditions.contains('Platform') ? platformType : null,
          'platformValue': '7',
          'addressKeywords': selectedConditions.contains('Address Keywords') ? (selectedAddressKeyword ?? '') : null,
          'isContain': selectedConditions.contains('Address Keywords') ? (isContain == 'Contain' ? '1' : isContain == 'Not Contain' ? '0' : null) : null,
          'courierId': courierId,
          'customerCourierId': customerCourierId,
          'pickupId': pickupId,
          'serviceCode': serviceCodeController.text.isNotEmpty ? serviceCodeController.text : 'BG',
        };
        
       
        
        final success = await _rulesService.createRule(
          title: ruleData['title'] as String,
          statusIds: ruleData['statusIds'] as List<String>, 
          weightType: ruleData['weightType'] as String?,
          weightValue: ruleData['weightValue'] as String?,
          paymentMethodId: ruleData['paymentMethodId'] as String?,
          customerCitylistId: ruleData['customerCitylistId'] as String?,
          orderType: ruleData['orderType'] as String?,
          orderValue: ruleData['orderValue'] as String?,
          platformType: ruleData['platformType'] as String?,
          platformValue: ruleData['platformValue'] as String,
          addressKeywords: ruleData['addressKeywords'] as String?,
          isContain: ruleData['isContain'] as String?,
          courierId: ruleData['courierId'] as String?,
          customerCourierId: ruleData['customerCourierId'] as String?,
          pickupId: ruleData['pickupId'] as String?,
          serviceCode: ruleData['serviceCode'] as String,
        );
        
        if (success) {
          customSnackBar('Success', 'Rule created successfully!');
          
          Navigator.of(context).pop(true);
        } else {
          customSnackBar('Error', _rulesService.errorMessage.value);
        }
      } catch (e) {
        customSnackBar('Error', 'Failed to create rule: ${e.toString()}');
      } finally {
        setState(() {
          isLoading = false;
        });
      }
    }
  }
 } 


class _PickupSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;
  final bool isLoading;

  const _PickupSelectDialog({
    Key? key, 
    required this.items, 
    required this.initialValue, 
    required this.title, 
    this.isLoading = false
  }) : super(key: key);

  @override
  State<_PickupSelectDialog> createState() => _PickupSelectDialogState();
}

class _PickupSelectDialogState extends State<_PickupSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        if (widget.isLoading) ...[
                          const SizedBox(height: 16),
                          const Center(child: CircularProgressIndicator()),
                        ],
                        if (!widget.isLoading) ...[
                          const SizedBox(height: 12),
                          SizedBox(
                            height: 300,
                            child: ListView.separated(
                              itemCount: filteredItems.length,
                              separatorBuilder: (_, __) => Container(
                                height: 1,
                                color: Colors.black.withOpacity(0.08),
                                margin: const EdgeInsets.symmetric(horizontal: 8),
                              ),
                              itemBuilder: (context, i) {
                                final item = filteredItems[i];
                                final isSelected = selected == item;
                                return ListTile(
                                  title: Text(item),
                                  trailing: isSelected
                                      ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                      : null,
                                  onTap: () {
                                    setState(() {
                                      selected = item;
                                    });
                                    Navigator.of(context).pop(item);
                                  },
                                  selected: isSelected,
                                  selectedTileColor: const Color(0xFFE6F0FF),
                                  shape: RoundedRectangleBorder(
                                    borderRadius: BorderRadius.circular(8),
                                  ),
                                );
                              },
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


class _SingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _SingleSelectDialog({
    Key? key, 
    required this.items, 
    required this.initialValue, 
    required this.title
  }) : super(key: key);

  @override
  State<_SingleSelectDialog> createState() => _SingleSelectDialogState();
}

class _SingleSelectDialogState extends State<_SingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: ListView.separated(
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isSelected = selected == item;
                              return ListTile(
                                title: Text(item),
                                trailing: isSelected
                                    ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                    : null,
                                onTap: () {
                                  setState(() {
                                    selected = item;
                                  });
                                  Navigator.of(context).pop(item);
                                },
                                selected: isSelected,
                                selectedTileColor: const Color(0xFFE6F0FF),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


class _CustomSingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final void Function(String?) onConfirm;
  final String title;
  final bool hasError;
  final String? errorMessage;

  const _CustomSingleSelectDialog({
    required this.items,
    required this.initialValue,
    required this.onConfirm,
    required this.title,
    this.hasError = false,
    this.errorMessage,
    Key? key,
  }) : super(key: key);

  @override
  _CustomSingleSelectDialogState createState() => _CustomSingleSelectDialogState();
}

class _CustomSingleSelectDialogState extends State<_CustomSingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

    @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items
        .where((item) => item.toLowerCase().contains(_search.toLowerCase()))
        .toList();

    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: filteredItems.isEmpty
                              ? const Center(child: Text('No items found.', style: TextStyle(color: Colors.grey)))
                              : ListView.separated(
                                  itemCount: filteredItems.length,
                                  separatorBuilder: (_, __) => Container(
                                    height: 1,
                                    color: Colors.black.withOpacity(0.08),
                                    margin: const EdgeInsets.symmetric(horizontal: 8),
                                  ),
                                  itemBuilder: (context, i) {
                                    final item = filteredItems[i];
                                    final isSelected = selected == item;
                                    return ListTile(
                                      title: Text(
                                        item,
                                        style: TextStyle(
                                          color: isSelected ? Colors.black : Colors.black,
                                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                        ),
                                      ),
                                      selected: isSelected,
                                      selectedTileColor: const Color(0xFFE6F0FF),
                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                      onTap: () {
                                        Navigator.of(context).pop(item);
                                      },
                                      trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                    );
                                  },
                                ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}


class MultiSelectItem<T> {
  final T value;
  final String label;
  MultiSelectItem(this.value, this.label);
}

class _CustomMultiSelectDialog extends StatefulWidget {
  final List<MultiSelectItem<String>> items;
  final List<String> initialValues;
  final void Function(List<String>) onConfirm;
  final String title;

  const _CustomMultiSelectDialog({
    required this.items,
    required this.initialValues,
    required this.onConfirm,
    required this.title,
    Key? key,
  }) : super(key: key);

  @override
  _CustomMultiSelectDialogState createState() => _CustomMultiSelectDialogState();
}

class _CustomMultiSelectDialogState extends State<_CustomMultiSelectDialog> {
  late List<String> _selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    _selected = List<String>.from(widget.initialValues);
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items
        .where((item) => item.label.toLowerCase().contains(_search.toLowerCase()))
        .toList();

    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: ListView.separated(
                            shrinkWrap: true,
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isChecked = _selected.contains(item.value);
                              return ListTile(
                                title: Text(item.label),
                                trailing: Checkbox(
                                  value: isChecked,
                                  activeColor: const Color(0xFF007AFF),
                                  onChanged: (checked) {
                                    setState(() {
                                      if (checked == true) {
                                        _selected.add(item.value);
                                      } else {
                                        _selected.remove(item.value);
                                      }
                                    });
                                  },
                                ),
                                onTap: () {
                                  setState(() {
                                    if (isChecked) {
                                      _selected.remove(item.value);
                                    } else {
                                      _selected.add(item.value);
                                    }
                                  });
                                },
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton(
                            style: ElevatedButton.styleFrom(
                              backgroundColor: _selected.isEmpty ? Colors.grey : const Color(0xFF007AFF),
                              elevation: 0,
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8),
                              ),
                              padding: const EdgeInsets.symmetric(vertical: 14),
                            ),
                            onPressed: _selected.isEmpty ? null : () {
                              Navigator.of(context).pop(_selected);
                            },
                            child: const Text('OK', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'create_order.dart';

class DashboardNotificationScreen extends StatelessWidget {
  DashboardNotificationScreen({Key? key}) : super(key: key);

  final List<Map<String, dynamic>> notificationsByDate = const [
    {
      'date': '1-Mar-2025',
      'items': [
        {
          'message': 'Cutt-off time for pickups in Ramadan is 4.00 pm.',
          'time': '06:30 PM',
        },
      ],
    },
    {
      'date': '26-Feb-2025',
      'items': [
        {
          'message': 'Great news! Orio is now delivering in more than 600+ cities ',
          'link': 'Download List',
          'time': '10:00 AM',
        },
      ],
    },
    {
      'date': '22-Feb-2025',
      'items': [
        {
          'message': 'Overnight delivery services in Sawad and One day + delivery services in Badin now available, start Booking Now.',
          'time': '02:30 PM',
        },
      ],
    },
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: const Text(
          'Notifications',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        child: ListView.builder(
          itemCount: notificationsByDate.length,
          itemBuilder: (context, i) {
            final group = notificationsByDate[i];
            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.only(top: 8, bottom: 4),
                  child: Text(
                    group['date'],
                    style: const TextStyle(
                      fontWeight: FontWeight.w700,
                      fontSize: 15,
                      fontFamily: 'SF Pro Display',
                      color: Colors.black,
                    ),
                  ),
                ),
                ...List.generate((group['items'] as List).length, (j) {
                  final item = group['items'][j];
                  return Container(
                    margin: const EdgeInsets.only(bottom: 12),
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF5F5F7),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        RichText(
                          text: TextSpan(
                            style: const TextStyle(
                              fontFamily: 'SF Pro Display',
                              fontWeight: FontWeight.w400,
                              fontSize: 15,
                              color: Colors.black,
                            ),
                            children: [
                              TextSpan(text: item['message']),
                              if (item['link'] != null)
                                TextSpan(
                                  text: item['link'],
                                  style: const TextStyle(
                                    color: Color(0xFF007AFF),
                                    fontWeight: FontWeight.w500,
                                    decoration: TextDecoration.underline,
                                  ),
                                ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          item['time'],
                          style: const TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w400,
                            fontSize: 13,
                            color: Color(0xFF6B7280),
                          ),
                        ),
                      ],
                    ),
                  );
                }),
              ],
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => const CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
              bottomNavigationBar: const AppBottomBar(selectedIndex: 0),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../services/auth_service.dart';
import '../services/rules_service.dart';
import '../services/courier_service.dart';
import '../utils/custom_snackbar.dart';
import '../screens/rules_screen.dart'; 
import '../network/api_service.dart';
import '../config/api_config.dart';
import 'create_order.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:dio/dio.dart';

class EditRuleScreen extends StatefulWidget {
  final Map<String, dynamic> ruleData;
  
  const EditRuleScreen({Key? key, required this.ruleData}) : super(key: key);

  @override
  State<EditRuleScreen> createState() => _EditRuleScreenState();
}

class _EditRuleScreenState extends State<EditRuleScreen> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController ruleTitleController = TextEditingController();
  final TextEditingController serviceCodeController = TextEditingController();
  final AuthService _authService = Get.find<AuthService>();
  late final RulesService _rulesService;
  final ApiService _apiService = ApiService();
  
  
  String? selectedCourierId;
  String? selectedPickupId;
  String? selectedStatus;
  String? selectedServiceCode;
  
  // Helper function to get service display name
  String _getServiceDisplayName(String? serviceCode) {
    if (serviceCode == null) return '';
    final service = serviceCodes.firstWhere(
      (item) => item['service_code'] == serviceCode,
      orElse: () => {'service_code': serviceCode, 'service_name': serviceCode},
    );
    return service['service_name']?.toString() ?? service['service_code']?.toString() ?? serviceCode;
  }
  
  
  List<Map<String, dynamic>> couriers = [];
  List<String> courierAccounts = []; 
  List<Map<String, dynamic>> courierAccountsWithIds = []; 
  List<Map<String, dynamic>> pickups = [];
  List<Map<String, dynamic>> serviceCodes = []; // Changed to store both code and name
  final List<String> statusOptions = ['0', '1'];

  bool isLoading = false;
  bool isLoadingData = true;
  bool isLoadingPickup = false;
  bool isLoadingServiceCodes = false;

  @override
  void initState() {
    super.initState();
    _rulesService = RulesService(_authService);
    _apiService.init();
    _loadDropdownData();
  }

  Future<void> _loadDropdownData() async {
    try {
      setState(() {
        isLoadingData = true;
      });

      
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        customSnackBar('Error', 'Account number not found');
        return;
      }

      
      await _loadCouriers(acno);
      
      
      _populateFormData();
      
    } catch (e) {
      customSnackBar('Error', 'Failed to load dropdown data: ${e.toString()}');
    } finally {
      setState(() {
        isLoadingData = false;
      });
    }
  }

  Future<void> _loadCouriers(String acno) async {
    try {
      
      final courierService = CourierService();
      couriers = await courierService.getCouriers(acno);
      
      
      
      List<String> courierNames = [];
      List<Map<String, dynamic>> couriersWithIds = [];
      
      for (var courier in couriers) {
        
        final accountTitle = courier['account_title']?.toString() ?? '';
        final courierName = courier['courier_name']?.toString() ?? courier['name']?.toString() ?? '';
        
        String displayName;
        if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
          displayName = '$accountTitle ($courierName)';
        } else if (accountTitle.isNotEmpty) {
          displayName = accountTitle;
        } else {
          displayName = courierName;
        }
        
        if (displayName.isNotEmpty) {
          courierNames.add(displayName);
          couriersWithIds.add({
            'id': courier['id']?.toString() ?? '',
            'courier_id': courier['courier_id']?.toString() ?? '',
            'courier_name': courier['courier_name']?.toString() ?? '',
            'account_title': accountTitle,
            'display_name': displayName,
          });
        }
      }
      
      courierAccounts = courierNames;
      courierAccountsWithIds = couriersWithIds;
      
      
      
      
      if (courierAccounts.isEmpty) {
        courierAccounts = ['Default Courier'];
        courierAccountsWithIds = [
          {'id': '1', 'courier_name': 'Default Courier', 'display_name': 'Default Courier'},
        ];
      }
    } catch (e) {
      print('Error loading couriers using CourierService.getCouriers: $e');
      courierAccounts = ['Default Courier'];
      courierAccountsWithIds = [
        {'id': '1', 'courier_name': 'Default Courier', 'display_name': 'Default Courier'},
      ];
    }
  }

  Future<void> _fetchPickupLocations({int? courierId, String? customerCourierIdOverride, String? expectedPickupId, String? expectedPickupName}) async {
    setState(() { isLoadingPickup = true; });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          pickups = [];
          isLoadingPickup = false;
        });
        return;
      }
      
      
      String? customerCourierId = customerCourierIdOverride;
      if (customerCourierId == null && courierId != null) {
        Map<String, dynamic> courierData = {};
        try {
          courierData = courierAccountsWithIds.firstWhere(
            (c) => int.tryParse(c['courier_id']?.toString() ?? '') == courierId ||
                   int.tryParse(c['id']?.toString() ?? '') == courierId,
          );
        } catch (e) {
          
        }
        customerCourierId = courierData['id']?.toString();
      }
      

      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.pickupShowEndpoint),
        data: {
          "acno": acno,
          // Server expects courier_id to be platform courier id, ensure it is an int
          "courier_id": courierId ?? 1,
          // Server expects account/customer courier id here, ensure it is an int too
          "customer_courier_id": int.tryParse(customerCourierId ?? widget.ruleData['customer_courier_id']?.toString() ?? '55') ?? 55,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<Map<String, dynamic>> pickupLocationsList = [];
        
        if (data is Map && data['payload'] is List) {
          pickupLocationsList = (data['payload'] as List).map((e) => {
            'id': e['id']?.toString() ?? '',
            'pickuplocation_name': e['pickuplocation_name']?.toString() ?? '',
          }).toList();
        } else if (data is Map && data['pickuplocation'] is List) {
          pickupLocationsList = (data['pickuplocation'] as List).map((e) => {
            'id': e['id']?.toString() ?? '',
            'pickuplocation_name': e['pickuplocation_name']?.toString() ?? '',
          }).toList();
        }
        
        setState(() {
          pickups = pickupLocationsList;
          if (pickups.isEmpty) {
            pickups = [{'id': '1', 'pickuplocation_name': 'Default Pickup'}];
          }
          
          bool matched = false;
          // If server returned exactly one pickup, prefer that id directly
          if (!matched && pickups.length == 1) {
            final only = pickups.first;
            if ((expectedPickupId != null && only['id']?.toString() == expectedPickupId) ||
                (expectedPickupName != null && (only['pickuplocation_name']?.toString() ?? '') == expectedPickupName)) {
              selectedPickupId = only['id']?.toString();
              matched = true;
              
            }
          }
          if (expectedPickupId != null) {
            

            if (pickups.any((e) => e['id']?.toString() == expectedPickupId)) {
              selectedPickupId = expectedPickupId;
              matched = true;
              
            }
          }
          if (!matched && expectedPickupName != null && expectedPickupName.isNotEmpty) {
           
            final byName = pickups.firstWhere(
              (e) => (e['pickuplocation_name']?.toString() ?? '').trim().toLowerCase() == expectedPickupName.trim().toLowerCase(),
              orElse: () => {},
            );
            if (byName.isNotEmpty) {
              selectedPickupId = byName['id']?.toString();
              matched = true;
              
            }
          }
          if (!matched) {
            
            if (pickups.isNotEmpty) {
              selectedPickupId = pickups.first['id']?.toString();

            }
          }
          
          isLoadingPickup = false;
        });
      } else {
        setState(() {
          pickups = [{'id': '1', 'pickuplocation_name': 'Default Pickup'}];
          isLoadingPickup = false;
        });
      }
    } catch (e) {
      print('Error fetching pickup locations: $e');
      setState(() {
        pickups = [{'id': '1', 'pickuplocation_name': 'Default Pickup'}];
        isLoadingPickup = false;
      });
    }
  }

  Future<void> _fetchServiceCodes({int? courierId, String? expectedServiceCode}) async {
    setState(() { isLoadingServiceCodes = true; });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          serviceCodes = [];
          selectedServiceCode = null;
          isLoadingServiceCodes = false;
        });
        return;
      }
      
      if (courierId == null) {
        setState(() {
          serviceCodes = [];
          selectedServiceCode = null;
          isLoadingServiceCodes = false;
        });
        return;
      }
      
      
      String? customerCourierId;
      Map<String, dynamic> courierData = {};
      try {
        courierData = courierAccountsWithIds.firstWhere(
          (c) => int.tryParse(c['courier_id']?.toString() ?? '') == courierId ||
                 int.tryParse(c['id']?.toString() ?? '') == courierId,
        );
      } catch (e) {
        
      }
      customerCourierId = courierData['id']?.toString();
      

      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderGetServiceCodeEndpoint),
        data: {
          "acno": acno,
          "courier_id": courierId,
          "customer_courier_id": int.tryParse(customerCourierId ?? '55') ?? 55,
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<Map<String, dynamic>> codes = [];
        
        if (data is Map && data['service_code'] is List) {
          final rawList = data['service_code'];
          if (rawList.isNotEmpty && rawList.first is Map && rawList.first.containsKey('service_code')) {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e['service_code']?.toString() ?? '',
              'service_name': e['service_name']?.toString() ?? '',
            }));
          } else {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e.toString(),
              'service_name': '',
            }));
          }
        } else if (data is Map && data['payload'] is List) {
          final rawList = data['payload'];
          if (rawList.isNotEmpty && rawList.first is Map && rawList.first.containsKey('service_code')) {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e['service_code']?.toString() ?? '',
              'service_name': e['service_name']?.toString() ?? '',
            }));
          } else {
            codes = List<Map<String, dynamic>>.from(rawList.map((e) => {
              'service_code': e.toString(),
              'service_name': '',
            }));
          }
        }
        
        setState(() {
          serviceCodes = codes;
          
          
          if (expectedServiceCode != null && serviceCodes.any((item) => item['service_code'] == expectedServiceCode)) {
            selectedServiceCode = expectedServiceCode;
            
          } else if (expectedServiceCode != null) {
            
            selectedServiceCode = expectedServiceCode;
           
          } else if (!serviceCodes.any((item) => item['service_code'] == selectedServiceCode)) {
            selectedServiceCode = null;
            
          }
          
          isLoadingServiceCodes = false;
        });
      } else {
        setState(() {
          serviceCodes = [];
          selectedServiceCode = null;
          isLoadingServiceCodes = false;
        });
      }
    } catch (e) {
      print('Error fetching service codes: $e');
      setState(() {
        serviceCodes = [];
        selectedServiceCode = null;
        isLoadingServiceCodes = false;
      });
    }
  }

  void _populateFormData() {
    
    ruleTitleController.text = widget.ruleData['rule_title'] ?? widget.ruleData['rule_name'] ?? '';
    
    
    final courierId = widget.ruleData['courier_id']?.toString();
    final customerCourierId = widget.ruleData['customer_courier_id']?.toString();
    final pickupId = widget.ruleData['pickup_id']?.toString();
    final status = widget.ruleData['status']?.toString();
    final serviceCode = widget.ruleData['service_code']?.toString();
    
   
    
    
    
    if (customerCourierId != null) {
     
      
      
      Map<String, dynamic> courierData = {};
      try {
        courierData = courierAccountsWithIds.firstWhere(
          (courier) {
            
            final accountIdFromData = courier['id']?.toString() ?? '';
            bool matchByAccountId = accountIdFromData == customerCourierId;
            
 
            
            return matchByAccountId;
          },
        );
      } catch (e) {
        
        print('DEBUG: No courier match found, using empty map');
      }
      
      if (courierData.isNotEmpty) {
        selectedCourierId = courierData['display_name']?.toString();
        
        
        
        
        final courierIdForApi = courierData['courier_id']?.toString() ?? courierId ?? '1';
        final courierIdInt = int.tryParse(courierIdForApi) ?? 1;
       
        _fetchPickupLocations(
          courierId: courierIdInt,
          customerCourierIdOverride: courierData['id']?.toString() ?? customerCourierId,
          expectedPickupId: pickupId,
          expectedPickupName: widget.ruleData['pickuplocation_name']?.toString(),
        );
        _fetchServiceCodes(courierId: courierIdInt, expectedServiceCode: serviceCode);
      } else {
       
        
        
        
        final ruleData = widget.ruleData;
        final courierName = ruleData['courier_name']?.toString() ?? 'Account ID: $customerCourierId';
        selectedCourierId = courierName;
       
        
        
        if (serviceCode != null && serviceCode.isNotEmpty) {
          selectedServiceCode = serviceCode;

        }

        // Ensure pickup locations are still fetched so we can resolve pickuplocation_name from pickup_id
        final fallbackCourierIdForApi = courierId ?? '1';
        final fallbackCourierIdInt = int.tryParse(fallbackCourierIdForApi) ?? 1;
        final customerCourierIdForApi = customerCourierId ?? widget.ruleData['customer_courier_id']?.toString();
        final expectedPickupName = widget.ruleData['pickuplocation_name']?.toString();
        _fetchPickupLocations(
          courierId: fallbackCourierIdInt,
          customerCourierIdOverride: customerCourierIdForApi,
          expectedPickupId: pickupId,
          expectedPickupName: expectedPickupName,
        );
      }
      
      
      setState(() {});
    }
    
    if (status != null && statusOptions.contains(status)) {
      selectedStatus = status;
      
    }
    
    
    
    if (selectedServiceCode == null && serviceCode != null && serviceCode.isNotEmpty) {
      selectedServiceCode = serviceCode;
     
    }
    
    
    
    if (selectedPickupId == null && pickupId != null && pickupId.isNotEmpty) {
      selectedPickupId = pickupId;
      
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: true,
      extendBody: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        title: const Text(
          'Edit Rule',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: isLoadingData 
        ? const Center(
            child: CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF007AFF)),
            ),
          )
        : Padding(
            padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 12),
            child: Form(
              key: _formKey,
              child: ListView(
                children: [
                  
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF5F5F7),
                      borderRadius: BorderRadius.circular(14),
                    ),
                    child: Row(
                      children: [
                        const Text(
                          'Rule ID: ',
                          style: TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w500,
                            fontSize: 15,
                            color: Colors.black,
                          ),
                        ),
                        Text(
                          widget.ruleData['id']?.toString() ?? 'N/A',
                          style: const TextStyle(
                            fontFamily: 'SF Pro Display',
                            fontWeight: FontWeight.w400,
                            fontSize: 15,
                            color: Colors.black,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                  
                  
                  TextFormField(
                    controller: ruleTitleController,
                    decoration: _inputDecoration('Rule Title'),
                    validator: (val) => val == null || val.isEmpty ? 'Enter rule title' : null,
                  ),
                  const SizedBox(height: 16),
                  
                  
                  _customSingleSelectField(
                    context: context,
                    title: 'Courier ID',
                    items: courierAccounts,
                    selectedItem: selectedCourierId,
                    onConfirm: (val) {
                      setState(() {
                        selectedCourierId = val;
                        selectedPickupId = null;
                        selectedServiceCode = null;
                      });
                      
                      
                      if (val != null) {
                        Map<String, dynamic> selectedCourier = {};
                        try {
                          selectedCourier = courierAccountsWithIds.firstWhere(
                            (c) => c['display_name']?.toString() == val,
                          );
                        } catch (e) {
                          
                        }
                        
                        if (selectedCourier.isNotEmpty) {
                          final courierIdInt = int.tryParse(selectedCourier['courier_id']?.toString() ?? selectedCourier['id']?.toString() ?? '1') ?? 1;
                          final customerCourierIdStr = selectedCourier['id']?.toString();
                          _fetchPickupLocations(courierId: courierIdInt, customerCourierIdOverride: customerCourierIdStr);
                          _fetchServiceCodes(courierId: courierIdInt);
                        }
                      }
                    },
                  ),
                  const SizedBox(height: 16),
                  
                  
                  
                  Builder(
                    builder: (context) {

                      return _customSingleSelectField(
                    context: context,
                    title: 'Pickup',
                    items: pickups.map((e) => e['pickuplocation_name']?.toString() ?? '').toList(),
                    selectedItem: pickups.isNotEmpty && selectedPickupId != null 
                        ? (() {
                            try {
                              final pickup = pickups.firstWhere(
                                (e) => e['id']?.toString() == selectedPickupId,
                              );
                              final pickupName = pickup['pickuplocation_name']?.toString();

                              return pickupName;
                            } catch (e) {
                              print('DEBUG: Pickup dropdown - no pickup found for selectedPickupId: $selectedPickupId');
                              return null;
                            }
                          })()
                        : null,
                    onConfirm: (val) {
                      if (val != null) {
                        Map<String, dynamic> pickup = {};
                        try {
                          pickup = pickups.firstWhere(
                            (e) => e['pickuplocation_name']?.toString() == val,
                          );
                        } catch (e) {
                          
                        }
                        setState(() => selectedPickupId = pickup['id']?.toString());
                      }
                    },
                    isLoading: isLoadingPickup,
                  );
                    },
                  ),
                  const SizedBox(height: 16),
                  
                  
                  _customSingleSelectField(
                    context: context,
                    title: 'Select Service',
                    items: serviceCodes.isNotEmpty 
                        ? serviceCodes.map((item) => item['service_name']?.toString() ?? item['service_code']?.toString() ?? '').toList().cast<String>()
                        : <String>[],
                    selectedItem: selectedServiceCode != null ? _getServiceDisplayName(selectedServiceCode) : null,
                    onConfirm: (val) {
                      if (val != null) {
                        final selectedService = serviceCodes.firstWhere(
                          (item) => item['service_name'] == val || item['service_code'] == val,
                          orElse: () => {'service_code': val, 'service_name': val},
                        );
                        setState(() => selectedServiceCode = selectedService['service_code']);
                      }
                    },
                    isLoading: isLoadingServiceCodes,
                  ),
                  const SizedBox(height: 16),
                  
                  
                  _customSingleSelectField(
                    context: context,
                    title: 'Status',
                    items: ['Inactive', 'Active'],
                    selectedItem: selectedStatus != null 
                        ? (selectedStatus == '0' ? 'Inactive' : 'Active')
                        : null,
                    onConfirm: (val) {
                      setState(() {
                        selectedStatus = val == 'Active' ? '1' : '0';
                      });
                    },
                  ),
                  const SizedBox(height: 24),
                  
                  
                  SizedBox(
                    width: double.infinity,
                    height: 48,
                    child: ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF007AFF),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      onPressed: isLoading ? null : _updateRule,
                      child: isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                            ),
                          )
                        : const Text('Update Rule', style: TextStyle(fontSize: 18, color: Colors.white)),
                    ),
                  ),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
      bottomNavigationBar: const AppBottomBar(selectedIndex: 2),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
                'assets/Create Order.svg',
                width: 28,
                height: 28,
                color: Colors.white,
              ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
    );
  }

  Widget _customSingleSelectField({
    required BuildContext context,
    required String title,
    required List<String> items,
    required String? selectedItem,
    required void Function(String?) onConfirm,
    bool isLoading = false,
  }) {
    return GestureDetector(
      onTap: isLoading ? null : () async {
        final result = await showModalBottomSheet<String>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (ctx) => _CustomSingleSelectDialog(
            items: items,
            initialValue: selectedItem,
            onConfirm: (value) {
              Navigator.of(ctx).pop(value);
            },
            title: title,
          ),
        );
        if (result != null) {
          onConfirm(result);
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.transparent, width: 0),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                isLoading ? 'Loading...' : (selectedItem ?? title),
                style: GoogleFonts.poppins(
                  fontSize: 15, 
                  color: selectedItem == null ? Colors.grey : Colors.black
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }

  InputDecoration _inputDecoration(String label) {
    return InputDecoration(
      labelText: label,
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: BorderSide.none,
      ),
      filled: true,
      fillColor: const Color(0xFFF5F5F7),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: const BorderSide(color: Color(0xFF007AFF), width: 2),
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(14),
        borderSide: BorderSide.none,
      ),
    );
  }

  Future<void> _updateRule() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        isLoading = true;
      });
      
      try {
        final ruleId = int.tryParse(widget.ruleData['id']?.toString() ?? '') ?? 0;
        if (ruleId == 0) {
          customSnackBar('Error', 'Invalid rule ID');
          return;
        }

        
        String actualCourierId = '1'; 
        if (selectedCourierId != null) {
          Map<String, dynamic> selectedCourier = {};
          try {
            selectedCourier = courierAccountsWithIds.firstWhere(
              (c) => c['display_name']?.toString() == selectedCourierId,
            );
          } catch (e) {
            
          }
          
          if (selectedCourier.isNotEmpty) {
            
            actualCourierId = selectedCourier['courier_id']?.toString() ?? selectedCourier['id']?.toString() ?? '1';
          } else {
            
            if (selectedCourierId!.startsWith('Courier ID: ')) {
              actualCourierId = selectedCourierId!.substring('Courier ID: '.length);
            } else {
              
              actualCourierId = widget.ruleData['courier_id']?.toString() ?? '1';
            }
          }
        }

        
        String customerCourierId = '55'; 
        if (selectedCourierId != null) {
          Map<String, dynamic> selectedCourier = {};
          try {
            selectedCourier = courierAccountsWithIds.firstWhere(
              (c) => c['display_name']?.toString() == selectedCourierId,
            );
          } catch (e) {
            
          }
          
          if (selectedCourier.isNotEmpty) {
            
            customerCourierId = selectedCourier['id']?.toString() ?? '55';
          } else {
            
            customerCourierId = widget.ruleData['customer_courier_id']?.toString() ?? '55';
          }
        }

        final success = await _rulesService.updateRule(
          ruleId: ruleId,
          ruleTitle: ruleTitleController.text.trim(),
          courierId: int.tryParse(actualCourierId) ?? 1,
          customerCourierId: int.tryParse(customerCourierId) ?? 55,
          pickupId: int.tryParse(selectedPickupId ?? '1') ?? 1,
          serviceCode: selectedServiceCode ?? '',
          status: int.tryParse(selectedStatus ?? '1') ?? 1,
        );
        
        if (success) {
          customSnackBar('Success', 'Rule updated successfully!');
          Navigator.of(context).pop(true);
        } else {
          customSnackBar('Error', _rulesService.errorMessage.value);
        }
      } catch (e) {
        customSnackBar('Error', 'Failed to update rule: ${e.toString()}');
      } finally {
        setState(() {
          isLoading = false;
        });
      }
    }
  }
}


class _CustomSingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final void Function(String?) onConfirm;
  final String title;

  const _CustomSingleSelectDialog({
    required this.items,
    required this.initialValue,
    required this.onConfirm,
    required this.title,
    Key? key,
  }) : super(key: key);

  @override
  _CustomSingleSelectDialogState createState() => _CustomSingleSelectDialogState();
}

class _CustomSingleSelectDialogState extends State<_CustomSingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items
        .where((item) => item.toLowerCase().contains(_search.toLowerCase()))
        .toList();

    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: SingleChildScrollView(
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                    const SizedBox(height: 12),
                    TextField(
                      decoration: InputDecoration(
                        hintText: 'Search',
                        prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                      ),
                      onChanged: (val) => setState(() => _search = val),
                    ),
                    const SizedBox(height: 12),
                    SizedBox(
                      height: 300,
                      child: filteredItems.isEmpty
                          ? const Center(child: Text('No items found.', style: TextStyle(color: Colors.grey)))
                          : ListView.separated(
                              itemCount: filteredItems.length,
                              separatorBuilder: (_, __) => Container(
                                height: 1,
                                color: Colors.black.withOpacity(0.08),
                                margin: const EdgeInsets.symmetric(horizontal: 8),
                              ),
                              itemBuilder: (context, i) {
                                final item = filteredItems[i];
                                final isSelected = selected == item;
                                return ListTile(
                                  title: Text(
                                    item,
                                    style: TextStyle(
                                      color: isSelected ? Colors.black : Colors.black,
                                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                    ),
                                  ),
                                  selected: isSelected,
                                  selectedTileColor: const Color(0xFFE6F0FF),
                                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                  onTap: () {
                                    Navigator.of(context).pop(item);
                                  },
                                  trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                );
                              },
                            ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../services/statement_service.dart';
import '../utils/custom_snackbar.dart';
import '../services/auth_service.dart';
import '../services/courier_service.dart';
import '../services/cities_service.dart';
import 'package:dio/dio.dart';
import 'package:multi_select_flutter/multi_select_flutter.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import '../config/api_config.dart';

const Color kBlue = Colors.black;

class CustomMultiSelectDialog<T> extends StatefulWidget {
  final List<MultiSelectItem<T>> items;
  final List<T> initialValue;
  final void Function(List<T>) onConfirm;
  final String title;

  const CustomMultiSelectDialog({
    required this.items,
    required this.initialValue,
    required this.onConfirm,
    required this.title,
    Key? key,
  }) : super(key: key);

  @override
  _CustomMultiSelectDialogState<T> createState() => _CustomMultiSelectDialogState<T>();
}

class _CustomMultiSelectDialogState<T> extends State<CustomMultiSelectDialog<T>> {
  late List<T> _selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    _selected = List<T>.from(widget.initialValue);
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items
        .where((item) => item.label.toLowerCase().contains(_search.toLowerCase()))
        .toList();

    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: kBlue)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: Icon(Icons.search_rounded, color: kBlue),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: ListView.separated(
                            shrinkWrap: true,
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: kBlue.withOpacity(0.2),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isChecked = _selected.contains(item.value);
                              return ListTile(
                                title: Text(item.label),
                                trailing: Checkbox(
                                  value: isChecked,
                                  activeColor: Color(0xFF007AFF),
                                  onChanged: (checked) {
                                    setState(() {
                                      if (checked == true) {
                                        _selected.add(item.value);
                                      } else {
                                        _selected.remove(item.value);
                                      }
                                    });
                                  },
                                ),
                                onTap: () {
                                  setState(() {
                                    if (isChecked) {
                                      _selected.remove(item.value);
                                    } else {
                                      _selected.add(item.value);
                                    }
                                  });
                                },
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        SizedBox(
                          width: 100,
                          child: ElevatedButton(
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Color(0xFF007AFF),
                              elevation: 0,
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                              padding: const EdgeInsets.symmetric(vertical: 14),
                            ),
                          onPressed: () {
                            Navigator.of(context).pop(_selected);
                          },
                            child: const Text('OK', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class FilterScreen extends StatefulWidget {
  final Map<String, dynamic>? initialFilters;
  const FilterScreen({Key? key, this.initialFilters}) : super(key: key);

  @override
  State<FilterScreen> createState() => _FilterScreenState();
}

class _FilterScreenState extends State<FilterScreen> {
  String? selectedOrder;
  List<String> selectedPlatforms = [];
  List<Map<String, dynamic>> couriers = [];
  List<Map<String, dynamic>> selectedCouriers = [];
  List<Map<String, dynamic>> cities = [];
  List<Map<String, dynamic>> selectedCities = [];
  List<Map<String, dynamic>> statuses = [];
  List<Map<String, dynamic>> selectedStatuses = [];
  String? _courierError;
  String? _statusError;
  String? _platformError;
  String? _cityError;
  final AuthService _authService = Get.find<AuthService>();
  List<String> platforms = [];

  
  static List<String>? _cachedPlatforms;
  static List<Map<String, dynamic>>? _cachedCouriers;
  static List<Map<String, dynamic>>? _cachedCities;
  static List<Map<String, dynamic>>? _cachedStatuses;

  void resetFilters() {
    setState(() {
      selectedOrder = null;
      selectedPlatforms = [];
      selectedCouriers = [];
      selectedCities = [];
      selectedStatuses = [];
    });
  }

  @override
  void initState() {
    super.initState();
    
    if (widget.initialFilters != null) {
      selectedOrder = widget.initialFilters!['order'] as String?;
      selectedPlatforms = List<String>.from(widget.initialFilters!['platform'] ?? []);
      if (widget.initialFilters != null && widget.initialFilters!['courier'] != null) {
        if (widget.initialFilters!['courier'] is List<Map<String, dynamic>>) {
          selectedCouriers = List<Map<String, dynamic>>.from(widget.initialFilters!['courier']);
        } else if (widget.initialFilters!['courier'] is List<String>) {
          
          final names = List<String>.from(widget.initialFilters!['courier']);
          selectedCouriers = couriers.where((c) => names.contains(c['name'])).toList();
        } else if (widget.initialFilters!['courier'] is Map<String, dynamic>) {
          
          selectedCouriers = [Map<String, dynamic>.from(widget.initialFilters!['courier'])];
        } else {
          selectedCouriers = [];
        }
      } else {
        selectedCouriers = [];
      }
      if (widget.initialFilters != null && widget.initialFilters!['city'] != null) {
        if (widget.initialFilters!['city'] is List<Map<String, dynamic>>) {
          selectedCities = List<Map<String, dynamic>>.from(widget.initialFilters!['city']);
        } else if (widget.initialFilters!['city'] is List<String>) {
          
          final names = List<String>.from(widget.initialFilters!['city']);
          selectedCities = cities.where((c) => names.contains(c['name'])).toList();
        } else {
          selectedCities = [];
        }
      } else {
        selectedCities = [];
      }
      if (widget.initialFilters != null && widget.initialFilters!['status'] != null) {
        if (widget.initialFilters!['status'] is List<Map<String, dynamic>>) {
          selectedStatuses = List<Map<String, dynamic>>.from(widget.initialFilters!['status']);
        } else if (widget.initialFilters!['status'] is List<String>) {
          
          final names = List<String>.from(widget.initialFilters!['status']);
          selectedStatuses = statuses.where((s) => names.contains(s['name'])).toList();
        } else if (widget.initialFilters!['status'] is Map<String, dynamic>) {
          
          selectedStatuses = [Map<String, dynamic>.from(widget.initialFilters!['status'])];
        } else {
          selectedStatuses = [];
        }
      } else {
        selectedStatuses = [];
      }
    }
    _loadUserDataAndFetchData();
  }

  Future<void> _loadUserDataAndFetchData() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchDropdownData();
  }

  Future<void> fetchDropdownData() async {
    
    if (_cachedPlatforms != null && _cachedCouriers != null && _cachedCities != null && _cachedStatuses != null) {
      setState(() {
        platforms = List<String>.from(_cachedPlatforms!);
        couriers = List<Map<String, dynamic>>.from(_cachedCouriers!);
        cities = List<Map<String, dynamic>>.from(_cachedCities!);
        statuses = List<Map<String, dynamic>>.from(_cachedStatuses!);
      });
      return;
    }

    
    await Future.wait([
      _fetchPlatforms(),
      _fetchCities(),
      _fetchStatuses(),
      _fetchCouriers(),
    ]);
  }

  Future<void> _fetchPlatforms() async {
    if (_cachedPlatforms != null) {
      setState(() {
        platforms = List<String>.from(_cachedPlatforms!);
      });
      return;
    }
    setState(() {
      _platformError = null;
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          _platformError = 'User not logged in';
        });
        return;
      }
      final service = StatementService();
      final shops = await service.fetchShopNames(acno);
      final loadedPlatforms = shops.map((e) =>
        (e['website_name']?.toString().isNotEmpty == true)
          ? e['website_name'].toString()
          : (e['platform_name']?.toString() ?? '')
      ).where((e) => e.isNotEmpty).toList();
      setState(() {
        platforms = loadedPlatforms;
        _cachedPlatforms = List<String>.from(loadedPlatforms);
      });
    } catch (e) {
      setState(() {
        _platformError = 'Failed to load platforms';
      });
    }
  }

  Future<void> _fetchCities() async {
    if (_cachedCities != null) {
      setState(() {
        cities = List<Map<String, dynamic>>.from(_cachedCities!);
      });
      return;
    }
    setState(() {
      _cityError = null;
    });
    try {
      
      final cachedCities = CitiesService.getCachedCities();
      if (cachedCities != null) {
        setState(() {
          cities = List<Map<String, dynamic>>.from(cachedCities);
          _cachedCities = List<Map<String, dynamic>>.from(cachedCities);
        });
        return;
      }
      
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
        data: {"country_id": 1},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<dynamic> cityList;
        if (data is List) {
          cityList = data;
        } else if (data is Map && data['payload'] is List) {
          cityList = data['payload'];
        } else {
          cityList = [];
        }
        final loadedCities = cityList.map((e) => {'id': e['id'].toString(), 'name': (e['name'] ?? e['city_name'] ?? '').toString()}).where((e) => (e['name']?.isNotEmpty ?? false)).toList();
        setState(() {
          cities = loadedCities;
          _cachedCities = List<Map<String, dynamic>>.from(loadedCities);
        });
      } else {
        setState(() {
          _cityError = 'Failed to load cities';
        });
      }
    } catch (e) {
      setState(() {
        _cityError = 'Failed to load cities: $e';
      });
    }
  }

  Future<void> _fetchStatuses() async {
    if (_cachedStatuses != null) {
      setState(() {
        statuses = List<Map<String, dynamic>>.from(_cachedStatuses!);
      });
      return;
    }
    setState(() {
      _statusError = null;
    });
    try {
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
        data: {"status_type": ["Customer Service","System","Rider"]},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      final List<dynamic> data = response.data;
      final loadedStatuses = data.map((e) => {'id': e['id'].toString(), 'name': e['name'].toString()}).toList();
      setState(() {
        statuses = loadedStatuses;
        _cachedStatuses = List<Map<String, dynamic>>.from(loadedStatuses);
      });
    } catch (e) {
      setState(() {
        _statusError = 'Failed to load statuses';
      });
    }
  }

  Future<void> _fetchCouriers() async {
    if (_cachedCouriers != null) {
      setState(() {
        couriers = List<Map<String, dynamic>>.from(_cachedCouriers!);
      });
      return;
    }
    setState(() {
      _courierError = null;
    });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          _courierError = 'User not logged in';
        });
        return;
      }
      
      
      
      // Try to get cached couriers first
      final cachedCouriers = CourierService.getCachedCouriers(acno);
      if (cachedCouriers != null && cachedCouriers.isNotEmpty) {
        
        final loadedCouriers = cachedCouriers.map((e) => {
          'id': e['id'].toString(), 
          'name': (e['account_title']?.toString().isNotEmpty == true && e['courier_name']?.toString().isNotEmpty == true) 
            ? '${e['account_title']} (${e['courier_name']})' 
            : (e['account_title']?.toString() ?? e['courier_name']?.toString() ?? '')
        }).where((e) => (e['name']?.isNotEmpty ?? false)).toList();
        
        setState(() {
          couriers = loadedCouriers;
          _cachedCouriers = List<Map<String, dynamic>>.from(loadedCouriers);
        });
       
        return;
      }
      
    
      
      // Fetch from API directly
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.courierAccountsEndpoint),
        data: {"acno": acno},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
   
      
      List<dynamic> data = [];
      if (response.data is List) {
        data = response.data;
       
      } else if (response.data is Map) {
        if (response.data['data'] is List) {
          data = response.data['data'];
          
        } else if (response.data['payload'] is List) {
          data = response.data['payload'];
          
        } else {
          
          data = [];
        }
      }
      
      if (data.isEmpty) {
        
        setState(() {
          _courierError = 'No courier data available';
          couriers = [];
        });
        return;
      }
      
      
      
      final loadedCouriers = data.map((e) {
        final id = e['id']?.toString() ?? '';
        final accountTitle = e['account_title']?.toString() ?? '';
        final courierName = e['courier_name']?.toString() ?? '';
        
        String displayName;
        if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
          displayName = '$accountTitle ($courierName)';
        } else if (accountTitle.isNotEmpty) {
          displayName = accountTitle;
        } else if (courierName.isNotEmpty) {
          displayName = courierName;
        } else {
          displayName = 'Unknown Courier';
        }
        
        return {
          'id': id,
          'name': displayName,
        };
              }).where((e) => (e['id']?.isNotEmpty ?? false) && e['name'] != 'Unknown Courier').toList();
        
     
      
      setState(() {
        couriers = loadedCouriers;
        _cachedCouriers = List<Map<String, dynamic>>.from(loadedCouriers);
        _courierError = null;
      });
      
    
      
    } catch (e) {
      print(' [FILTER DEBUG] Error fetching couriers: $e');
      setState(() {
        _courierError = 'Failed to load couriers: ${e.toString()}';
        couriers = [];
      });
    }
  }

  
  void clearDropdownCache() {
    _cachedPlatforms = null;
    _cachedCouriers = null;
    _cachedCities = null;
    _cachedStatuses = null;
  }

  Future<void> refreshCouriers() async {
    
    _cachedCouriers = null;
    await _fetchCouriers();
  }

  Future<void> refreshAllData() async {
   
    clearDropdownCache();
    await fetchDropdownData();
  }

  
  static void clearAllFilterCaches() {
    _cachedPlatforms = null;
    _cachedCouriers = null;
    _cachedCities = null;
    _cachedStatuses = null;
  }

  
  static Future<void> preloadFilterData() async {
    
    if (_cachedPlatforms != null && _cachedCouriers != null && _cachedCities != null && _cachedStatuses != null) {
      return; 
    }

    try {
      final authService = Get.find<AuthService>();
      final acno = authService.getCurrentAcno();
      if (acno == null) return;

      
      await Future.wait([
        _preloadPlatforms(authService, acno),
        _preloadCities(),
        _preloadStatuses(),
        _preloadCouriers(authService, acno),
      ]);
    } catch (e) {
      
      print('Filter data preload failed: $e');
    }
  }

  
  static Future<void> _preloadPlatforms(AuthService authService, String acno) async {
    if (_cachedPlatforms != null) return;
    
    try {
      final service = StatementService();
      final shops = await service.fetchShopNames(acno);
      final loadedPlatforms = shops.map((e) =>
        (e['website_name']?.toString().isNotEmpty == true)
          ? e['website_name'].toString()
          : (e['platform_name']?.toString() ?? '')
      ).where((e) => e.isNotEmpty).toList();
      
      _cachedPlatforms = List<String>.from(loadedPlatforms);
    } catch (e) {
      print('Failed to preload platforms: $e');
    }
  }

  
  static Future<void> _preloadCities() async {
    if (_cachedCities != null) return;
    
    try {
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
        data: {"country_id": 1},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<dynamic> cityList;
        if (data is List) {
          cityList = data;
        } else if (data is Map && data['payload'] is List) {
          cityList = data['payload'];
        } else {
          cityList = [];
        }
        final loadedCities = cityList.map((e) => {'id': e['id'].toString(), 'name': (e['name'] ?? e['city_name'] ?? '').toString()}).where((e) => (e['name']?.isNotEmpty ?? false)).toList();
        
        _cachedCities = List<Map<String, dynamic>>.from(loadedCities);
      }
    } catch (e) {
      print('Failed to preload cities: $e');
    }
  }

  
  static Future<void> _preloadStatuses() async {
    if (_cachedStatuses != null) return;
    
    try {
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
        data: {"status_type": ["Customer Service","System","Rider"]},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      final List<dynamic> data = response.data;
      final loadedStatuses = data.map((e) => {'id': e['id'].toString(), 'name': e['name'].toString()}).toList();
      
      _cachedStatuses = List<Map<String, dynamic>>.from(loadedStatuses);
    } catch (e) {
      print('Failed to preload statuses: $e');
    }
  }

  
  static Future<void> _preloadCouriers(AuthService authService, String acno) async {
    if (_cachedCouriers != null) return;
    
    try {
      print(' [FILTER PRELOAD] Preloading couriers for acno: $acno');
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.courierAccountsEndpoint),
        data: {"acno": acno},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        
        
        List<dynamic> data = [];
        if (response.data is List) {
          data = response.data;
         
        } else if (response.data is Map) {
          if (response.data['data'] is List) {
            data = response.data['data'];
            
          } else if (response.data['payload'] is List) {
            data = response.data['payload'];
           
          } else {
            
            data = [];
          }
        }
        
        if (data.isNotEmpty) {
          final loadedCouriers = data.map((e) {
            final id = e['id']?.toString() ?? '';
            final accountTitle = e['account_title']?.toString() ?? '';
            final courierName = e['courier_name']?.toString() ?? '';
            
            String displayName;
            if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
              displayName = '$accountTitle ($courierName)';
            } else if (accountTitle.isNotEmpty) {
              displayName = accountTitle;
            } else if (courierName.isNotEmpty) {
              displayName = courierName;
            } else {
              displayName = 'Unknown Courier';
            }
            
            return {
              'id': id,
              'name': displayName,
            };
          }).where((e) => (e['id']?.isNotEmpty ?? false) && e['name'] != 'Unknown Courier').toList();
          
          _cachedCouriers = List<Map<String, dynamic>>.from(loadedCouriers);

        } else {
         
        }
      }
    } catch (e) {
      print(' [FILTER PRELOAD] Failed to preload couriers: $e');
    }
  }

  Widget _customMultiSelectField({
    required BuildContext context,
    required String title,
    required List<String> items,
    required List<String> selectedItems,
    required void Function(List<String>) onConfirm,
  }) {
    return GestureDetector(
      onTap: () async {
        _SelectOrdersDropdownState.closeAnyOpenDropdown();
        final result = await showModalBottomSheet<List<String>>(
          context: context,
          isScrollControlled: true,
          backgroundColor: Colors.transparent,
          builder: (ctx) => CustomMultiSelectDialog<String>(
            items: items.map((e) => MultiSelectItem(e, e)).toList(),
            initialValue: selectedItems,
            onConfirm: (values) {
              Navigator.of(ctx).pop(values);
            },
            title: title,
          ),
        );
                        if (result != null) {
                          onConfirm(result);
                        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: Colors.transparent, width: 1),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                selectedItems.isEmpty ? title : selectedItems.join(', '),
                style: GoogleFonts.poppins(fontSize: 15, color: selectedItems.isEmpty ? Colors.black : Colors.black),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }

  void customSnackBar(String title, String message) {
    final snackBar = SnackBar(
      content: Text(message),
      backgroundColor: Colors.red,
      behavior: SnackBarBehavior.floating,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
      ),
      margin: const EdgeInsets.all(16),
      duration: const Duration(seconds: 3),
    );
    final rootContext = Navigator.of(context, rootNavigator: true).context;
    ScaffoldMessenger.of(rootContext).showSnackBar(snackBar);
  }

  @override
  Widget build(BuildContext context) {
    final String? selectedCourierLabel = selectedCouriers.isEmpty ? null : selectedCouriers.first['name'];
    final List<String> courierLabels = couriers.map((e) => e['name'] as String).toList();
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 24),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: const Text(
          'Filter',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: GestureDetector(
              behavior: HitTestBehavior.translucent,
              onTap: () {
                _SelectOrdersDropdownState.closeAnyOpenDropdown();
              },
              child: AnimationLimiter(
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                  child: Column(
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 500),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 50.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        
                        Builder(
                          builder: (context) {
                            return GestureDetector(
                              onTap: () async {
                                _SelectOrdersDropdownState.closeAnyOpenDropdown();
                                final options = ['Booked', 'Unbooked'];
                                final result = await showModalBottomSheet<String>(
                                  context: context,
                                  isScrollControlled: true,
                                  backgroundColor: Colors.transparent,
                                  builder: (ctx) => _SingleSelectDialog(
                                    items: options,
                                    initialValue: selectedOrder,
                                    title: 'Select Orders',
                                  ),
                                );
                                if (result != null) {
                                  setState(() => selectedOrder = result);
                                }
                              },
                              child: Container(
                                margin: const EdgeInsets.only(bottom: 16),
                                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF5F5F7),
                                  borderRadius: BorderRadius.circular(14),
                                  border: Border.all(color: Colors.transparent, width: 1),
                                  boxShadow: [
                                    BoxShadow(
                                      color: Colors.grey.withOpacity(0.08),
                                      blurRadius: 8,
                                      offset: Offset(0, 2),
                                    ),
                                  ],
                                ),
                                child: Row(
                                  children: [
                                    Expanded(
                                      child: Text(
                                        selectedOrder ?? 'Select Orders',
                                        style: TextStyle(fontSize: 15, color: selectedOrder == null ? Colors.black : Colors.black),
                                        overflow: TextOverflow.ellipsis,
                                        maxLines: 1,
                                      ),
                                    ),
                                    Icon(Icons.keyboard_arrow_down_rounded, color: selectedOrder == null ? Colors.black : Color(0xFF222222)),
                                  ],
                                ),
                              ),
                            );
                          },
                        ),
                        _statusError != null
                            ? Padding(
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                child: Text(_statusError!, style: const TextStyle(color: Colors.red)),
                              )
                            : _customMultiSelectField(
                                context: context,
                                title: 'Select Status',
                                items: statuses.map((e) => e['name'] as String).toList(),
                                selectedItems: selectedStatuses.map((e) => e['name'] as String).toList(),
                                onConfirm: (values) {
                                  setState(() {
                                    selectedStatuses = statuses.where((e) => values.contains(e['name'])).toList();
                                  });
                                },
                              ),
                        _platformError != null
                            ? Padding(
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                child: Text(_platformError!, style: const TextStyle(color: Colors.red)),
                              )
                            : _customMultiSelectField(
                                context: context,
                                title: 'Select Platforms',
                                items: platforms,
                                selectedItems: selectedPlatforms,
                                onConfirm: (values) {
                                  setState(() {
                                    selectedPlatforms = List<String>.from(values);
                                  });
                                },
                              ),
                        _courierError != null
                            ? Padding(
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                child: Container(
                                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                                  decoration: BoxDecoration(
                                    color: Colors.red.withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(color: Colors.red.withOpacity(0.3)),
                                  ),
                                  child: Row(
                                    children: [
                                      Icon(Icons.error_outline, color: Colors.red[700], size: 16),
                                      const SizedBox(width: 8),
                                      Expanded(
                                        child: Text(
                                          _courierError!,
                                          style: TextStyle(color: Colors.red[700], fontSize: 12),
                                        ),
                                      ),
                                      GestureDetector(
                                        onTap: refreshCouriers,
                                        child: Icon(Icons.refresh, color: Colors.red[700], size: 16),
                                      ),
                                    ],
                                  ),
                                ),
                              )
                            : _customMultiSelectField(
                                      context: context,
                                title: 'Select Couriers',
                                items: couriers.map((e) => e['name'] as String).toList(),
                                selectedItems: selectedCouriers.map((e) => e['name'] as String).toList(),
                                onConfirm: (values) {
                                      setState(() {
                                    selectedCouriers = couriers.where((e) => values.contains(e['name'])).toList();
                                  });
                              },
                            ),
                        _cityError != null
                            ? Padding(
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                child: Text(_cityError!, style: const TextStyle(color: Colors.red)),
                              )
                            : _customMultiSelectField(
                                context: context,
                                title: 'Select Cities',
                                items: cities.map((e) => e['name'] as String).toList(),
                                selectedItems: selectedCities.map((e) => e['name'] as String).toList(),
                                onConfirm: (values) {
                                  setState(() {
                                    selectedCities = cities.where((e) => values.contains(e['name'])).toList();
                                  });
                                },
                              ),
                        const SizedBox(height: 8),
                        SizedBox(
                          width: double.infinity,
                          height: 48,
                          child: ElevatedButton(
                            onPressed: () {
                              
                              if (selectedOrder == null &&
                                  selectedPlatforms.isEmpty &&
                                  selectedCouriers.isEmpty &&
                                  selectedCities.isEmpty &&
                                  selectedStatuses.isEmpty) {
                                final rootContext = Navigator.of(context, rootNavigator: true).context;
                                customSnackBar('Error', 'Please select at least one filter');
                                return;
                              }
                              
                              final filters = {
                                'order': selectedOrder,
                                'status': selectedStatuses.toList(), 
                                'status_ids': selectedStatuses.map((e) => e['id']).toList(),
                                'platform': selectedPlatforms,
                                'courier': selectedCouriers.toList(), 
                                'courier_ids': selectedCouriers.map((e) => e['id']).toList(),
                                'city': selectedCities.toList(), 
                                'city_ids': selectedCities.map((e) => e['id']).toList(),
                              };
                              Navigator.of(context).pop(filters);
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Color(0xFF007AFF),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(10),
                              ),
                              elevation: 0,
                            ),
                            child: const Text(
                              'Apply Filters',
                              style: TextStyle(
                                fontFamily: 'SF Pro Display',
                                fontWeight: FontWeight.w600,
                                fontSize: 16,
                                color: Colors.white,
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(height: 16),
                        GestureDetector(
                          onTap: () {
                            resetFilters();
                            // Stay on the filter screen; do not navigate back and do not show snackbar
                          },
                          child: const Text(
                            'Reset Filter',
                            style: TextStyle(
                              fontFamily: 'SF Pro Display',
                              fontWeight: FontWeight.w500,
                              fontSize: 16,
                              color: Colors.red,
                              decoration: TextDecoration.none,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
    );
  }
}

class _FilterDropdown extends StatelessWidget {
  final String hint;
  final String? value;
  final List<String> items;
  final void Function(String?)? onChanged;
  const _FilterDropdown({required this.hint, required this.value, required this.items, this.onChanged});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.08),
            blurRadius: 8,
            offset: Offset(0, 2),
          ),
        ],
      ),
      child: DropdownButtonFormField<String>(
        value: value,
        items: items.map((e) => DropdownMenuItem(
          value: e,
          child: SizedBox(
            width: 120, 
            child: Text(
              e,
              style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        )).toList(),
        onChanged: items.isNotEmpty ? onChanged : null,
        decoration: InputDecoration(
          hintText: items.isNotEmpty ? hint : 'No items available',
          hintStyle: GoogleFonts.poppins(fontSize: 15, color: Color(0xFF6B6B6B)),
          filled: true,
          fillColor: Colors.white,
          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(14),
            borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(14),
            borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(14),
            borderSide: BorderSide(color: Colors.blue[300]!, width: 1.5),
          ),
        ),
        icon: const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
        style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
      ),
    );
  }
} 

class _SelectOrdersDropdown extends StatefulWidget {
  final String? selectedOrder;
  final List<String> orders;
  final ValueChanged<String?> onChanged;
  const _SelectOrdersDropdown({required this.selectedOrder, required this.orders, required this.onChanged});

  @override
  State<_SelectOrdersDropdown> createState() => _SelectOrdersDropdownState();
}

class _SelectOrdersDropdownState extends State<_SelectOrdersDropdown> {
  static OverlayEntry? _overlayEntry;

  static void closeAnyOpenDropdown() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }

  final GlobalKey _fieldKey = GlobalKey();

  void _showDropdown() {
    closeAnyOpenDropdown();
    final RenderBox renderBox = _fieldKey.currentContext!.findRenderObject() as RenderBox;
    final Offset offset = renderBox.localToGlobal(Offset.zero);
    final Size size = renderBox.size;
    _overlayEntry = OverlayEntry(
      builder: (context) => Positioned(
        left: offset.dx,
        top: offset.dy + size.height, 
        width: size.width,
        child: Material(
          color: Colors.transparent,
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: widget.orders.map((order) => ListTile(
                title: Text(order),
                onTap: () {
                  widget.onChanged(order);
                  _removeDropdown();
                },
                selected: widget.selectedOrder == order,
                selectedTileColor: kBlue.withOpacity(0.1),
              )).toList(),
            ),
          ),
        ),
      ),
    );
    Overlay.of(context).insert(_overlayEntry!);
  }

  void _removeDropdown() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }

  @override
  void dispose() {
    _removeDropdown();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      key: _fieldKey,
      onTap: () {
        if (_overlayEntry == null) {
          _showDropdown();
        } else {
          _removeDropdown();
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.08),
              blurRadius: 8,
              offset: Offset(0, 2),
            ),
          ],
        ),
        child: InputDecorator(
          decoration: InputDecoration(
            hintText: 'Select Orders',
            hintStyle: GoogleFonts.poppins(fontSize: 15, color: Color(0xFF6B6B6B)),
            filled: true,
            fillColor: Colors.white,
            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: Colors.grey[300]!, width: 1),
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(14),
              borderSide: BorderSide(color: Colors.blue[300]!, width: 1.5),
            ),
          ),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  widget.selectedOrder ?? 'Select Orders',
                  style: GoogleFonts.poppins(fontSize: 15, color: widget.selectedOrder == null ? Color(0xFF6B6B6B) : Colors.black),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
            ],
          ),
        ),
      ),
    );
  }
} 

class _SingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _SingleSelectDialog({Key? key, required this.items, required this.initialValue, required this.title}) : super(key: key);

  @override
  State<_SingleSelectDialog> createState() => _SingleSelectDialogState();
}

class _SingleSelectDialogState extends State<_SingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: ListView.separated(
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isSelected = selected == item;
                              return ListTile(
                                title: Text(item),
                                trailing: isSelected
                                    ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                    : null,
                                onTap: () {
                                  setState(() {
                                    selected = item;
                                  });
                                  Navigator.of(context).pop(item);
                                },
                                selected: isSelected,
                                selectedTileColor: const Color(0xFFE6F0FF),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_inappwebview/flutter_inappwebview.dart';
import '../services/auth_service.dart';
import '../utils/custom_snackbar.dart';
import 'reset_password_screen.dart';
import 'sign_in_screen.dart';
import 'splash_screen.dart';

class ForgotPasswordScreen extends StatefulWidget {
  const ForgotPasswordScreen({Key? key}) : super(key: key);

  @override
  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
}

class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
  final TextEditingController _emailController = TextEditingController();
  final AuthService _authService = Get.find<AuthService>();
  bool _isLoading = false;
  final RxBool emailError = false.obs;
  final RxString emailErrorMessage = ''.obs;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  Future<void> _resetPassword() async {
    
    emailError.value = false;
    emailErrorMessage.value = '';
    
    
    if (_emailController.text.trim().isEmpty) {
      emailError.value = true;
      emailErrorMessage.value = 'Email is required';
      return;
    }
    
    
    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    if (!emailRegex.hasMatch(_emailController.text.trim())) {
      emailError.value = true;
      emailErrorMessage.value = 'Please enter a valid email address';
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
     
      final response = await _authService.forgotPassword(_emailController.text.trim());
      
      
      if (response['success'] == true) {
        final resetUrl = response['reset_url'] ?? '';
        
        
        if (resetUrl.isNotEmpty) {
          
          // Open the reset URL in a web view
          Get.to(() => ResetPasswordWebView(resetUrl: resetUrl));
        } else {
          
          customSnackBar('Success', 'Password reset link has been sent to your email');
        }
      } else {
        
        customSnackBar('Error', response['message'] ?? 'Failed to send reset email. Please try again.');
      }
    } catch (e) {
      
      customSnackBar('Error', 'Invalid email address');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
    ));

    final width = MediaQuery.of(context).size.width;
    final blockW = width / 100;
    final blockH = MediaQuery.of(context).size.height / 100;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Stack(
          children: [
            Align(
              alignment: Alignment.topLeft,
              child: IconButton(
                icon: const Icon(Icons.arrow_back, color: Colors.black, size: 28),
                onPressed: () {
                  Get.to(() => SignInScreen());
                },
              ),
            ),
            Center(
              child: SingleChildScrollView(
                physics: const BouncingScrollPhysics(),
                child: Builder(
                  builder: (context) {
                    return Padding(
                      padding: EdgeInsets.symmetric(horizontal: blockW * 6),
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          Container(
                            width: 110,
                            height: 110,
                            decoration: const BoxDecoration(
                              color: Color(0xFFE6F0FF),
                              shape: BoxShape.circle,
                            ),
                            child: Center(
                              child: Icon(
                                Icons.lock_outline,
                                color: Color(0xFF007AFF),
                                size: 56,
                              ),
                            ),
                          ),
                          const SizedBox(height: 32),
                          Text(
                            'Forgot Password',
                            style: GoogleFonts.inter(
                              fontWeight: FontWeight.w700,
                              fontSize: 28,
                              color: const Color(0xFF183046),
                            ),
                            textAlign: TextAlign.center,
                          ),
                          const SizedBox(height: 20),
                          Obx(() => Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Container(
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF3F3F3),
                                  borderRadius: BorderRadius.circular(blockW * 2),
                                  border: emailError.value
                                      ? Border.all(color: Colors.red, width: 1.5)
                                      : null,
                                ),
                                child: TextField(
                                  controller: _emailController,
                                  autofillHints: null, 
                                  style: GoogleFonts.inter(
                                    fontWeight: FontWeight.w400,
                                    fontSize: blockW * 3.5,
                                    color: Colors.black,
                                  ),
                                  decoration: InputDecoration(
                                    hintText: 'Email',
                                    hintStyle: GoogleFonts.inter(
                                      fontWeight: FontWeight.w400,
                                      fontSize: blockW * 3.5,
                                      color: const Color(0xFFBDBDBD),
                                    ),
                                    border: InputBorder.none,
                                    contentPadding: EdgeInsets.symmetric(horizontal: blockW * 4, vertical: blockH * 1.5),
                                  ),
                                  keyboardType: TextInputType.emailAddress,
                                ),
                              ),
                              if (emailError.value)
                                Padding(
                                  padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                                  child: Obx(() => Text(
                                    emailErrorMessage.value.isEmpty ? 'Email is required' : emailErrorMessage.value,
                                    style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                                  )),
                                ),
                            ],
                          )),
                          const SizedBox(height: 16),
                          SizedBox(
                            width: double.infinity,
                            height: 48,
                            child: ElevatedButton(
                              onPressed: _isLoading ? null : _resetPassword,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: const Color(0xFF007AFF),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                                elevation: 0,
                              ),
                              child: _isLoading
                                  ? const SizedBox(
                                      width: 20,
                                      height: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                      ),
                                    )
                                  : Text(
                                      'Reset Password',
                                      style: GoogleFonts.inter(
                                        fontWeight: FontWeight.w600,
                                        fontSize: 17,
                                        color: Colors.white,
                                      ),
                                    ),
                            ),
                          ),
                          const SizedBox(height: 16),
                          GestureDetector(
                            onTap: () {
                              Get.offAll(() => SignInScreen());
                            },
                            child: Text(
                              "Can't reset your password?",
                              style: GoogleFonts.inter(
                                fontWeight: FontWeight.w400,
                                fontSize: 15,
                                color: const Color(0xFF007AFF),
                                decoration: TextDecoration.none,
                              ),
                              textAlign: TextAlign.center,
                            ),
                          ),
                        ],
                      ),
                    );
                  },
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
} 

class ResetPasswordWebView extends StatefulWidget {
  final String resetUrl;

  const ResetPasswordWebView({required this.resetUrl});

  @override
  State<ResetPasswordWebView> createState() => _ResetPasswordWebViewState();
}

class _ResetPasswordWebViewState extends State<ResetPasswordWebView> {
  InAppWebViewController? webViewController;
  bool isLoading = true;
  String? errorMessage;
  bool _navigatedAway = false;

  bool _shouldNavigateToSplash(String url) {
    final u = url.toLowerCase();
    return u.contains('success') ||
        u.contains('completed') ||
        u.contains('done') ||
        u.contains('login') ||
        u.contains('signin');
  }

  void _navigateToSplashNow(InAppWebViewController controller) {
    if (_navigatedAway) return;
    _navigatedAway = true;
    controller.stopLoading();
    Get.offAll(() => SplashScreen());
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Reset Password'),
        backgroundColor: const Color(0xFF007AFF),
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () {
              Get.offAll(() => SignInScreen());
            },
          ),
        ],
      ),
      body: Stack(
        children: [
          InAppWebView(
            initialUrlRequest: URLRequest(url: WebUri(widget.resetUrl)),
            onWebViewCreated: (InAppWebViewController controller) {
              webViewController = controller;
            },
            shouldOverrideUrlLoading: (controller, action) async {
              final nextUrl = action.request.url?.toString() ?? '';
              if (_shouldNavigateToSplash(nextUrl)) {
                _navigateToSplashNow(controller);
                return NavigationActionPolicy.CANCEL;
              }
              return NavigationActionPolicy.ALLOW;
            },
            onLoadStart: (controller, url) {
              setState(() {
                isLoading = true;
                errorMessage = null;
              });
              final currentUrl = url?.toString() ?? '';
              if (_shouldNavigateToSplash(currentUrl)) {
                _navigateToSplashNow(controller);
              }
            },
            onLoadStop: (controller, url) {
              setState(() {
                isLoading = false;
              });
              final currentUrl = url?.toString() ?? '';
              if (_shouldNavigateToSplash(currentUrl)) {
                _navigateToSplashNow(controller);
              }
            },
            onLoadError: (controller, url, code, message) {
              setState(() {
                isLoading = false;
                errorMessage = 'Failed to load page: $message';
              });
            },
            onLoadHttpError: (controller, url, statusCode, description) {
              setState(() {
                isLoading = false;
                errorMessage = 'HTTP Error $statusCode: $description';
              });
            },
            onUpdateVisitedHistory: (controller, url, isReload) {
              // Monitor URL changes to detect completion
              final currentUrl = url?.toString() ?? '';
              if (_shouldNavigateToSplash(currentUrl)) {
                _navigateToSplashNow(controller);
              }
            },
          ),
          if (isLoading)
            const Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF007AFF)),
              ),
            ),
          if (errorMessage != null)
            Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    color: Colors.red,
                    size: 64,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    errorMessage!,
                    style: const TextStyle(
                      color: Colors.red,
                      fontSize: 16,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        errorMessage = null;
                      });
                      webViewController?.reload();
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      foregroundColor: Colors.white,
                    ),
                    child: const Text('Retry'),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../models/help_video_model.dart';
import '../services/help_video_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'package:youtube_player_flutter/youtube_player_flutter.dart';
import 'package:flutter/services.dart';
import 'create_order.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;
import 'package:flutter_svg/flutter_svg.dart';
import 'package:google_fonts/google_fonts.dart';
import '../widgets/transition.dart';

class HelpVideosScreen extends StatefulWidget {
  const HelpVideosScreen({Key? key}) : super(key: key);

  @override
  State<HelpVideosScreen> createState() => _HelpVideosScreenState();
}

class _HelpVideosScreenState extends State<HelpVideosScreen> {
  final HelpVideoService _helpVideoService = HelpVideoService();
  
  List<HelpVideoModel> _videos = [];
  bool _isLoading = false;
  String? _error;
  String _selectedType = 'All';
  final List<String> _videoTypes = [
    'All',
    'dashboard',
    'orders',
    'pickups',
    'shipments',
  ];

  int? _playingIndex; 
  YoutubePlayerController? _youtubeController;
  YoutubePlayerValue? _lastPlayerValue;

  
  static Map<String, dynamic>? _lastParams;
  static List<HelpVideoModel>? _cachedVideos;

  
  static void clearAllHelpVideosCaches() {
    _lastParams = null;
    _cachedVideos = null;
  }

  @override
  void initState() {
    super.initState();
    _restoreOrFetchVideos();
  }

  @override
  void dispose() {
    _youtubeController?.dispose();
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
    ]);
    super.dispose();
  }

  
  void _restoreOrFetchVideos() async {
    final params = {
      'type': _selectedType == 'All' ? null : _selectedType,
    };
    
    // Check if we have cached data for the current filter
    if (_lastParams != null && _cachedVideos != null) {
      final lastType = _lastParams!['type'];
      final currentType = params['type'];
      
      // Only use cache if the filter type matches exactly
      if (lastType == currentType) {
        // Apply client-side filtering to cached videos
        List<HelpVideoModel> filteredVideos = _cachedVideos!;
        if (_selectedType != 'All') {
          filteredVideos = _cachedVideos!.where((video) => 
            video.type.toLowerCase() == _selectedType.toLowerCase()
          ).toList();
        }
        
        setState(() {
          _videos = filteredVideos;
          _isLoading = false;
        });
        return;
      }
    }
    
    await _loadVideos();
  }

  Future<void> _loadVideos() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
     
      
      final videos = await _helpVideoService.getHelpVideos(
        type: _selectedType == 'All' ? null : _selectedType,
      );
      
    
      
      _lastParams = {
        'type': _selectedType == 'All' ? null : _selectedType,
      };
      _cachedVideos = List<HelpVideoModel>.from(videos);
      
      // Apply client-side filtering as fallback
      List<HelpVideoModel> filteredVideos = videos;
      if (_selectedType != 'All') {
        filteredVideos = videos.where((video) => 
          video.type.toLowerCase() == _selectedType.toLowerCase()
        ).toList();
        
      }
      
      setState(() {
        _videos = filteredVideos;
        _isLoading = false;
      });
    } catch (e) {
      print('Error loading videos: $e');
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  
  Future<void> _manualRefresh() async {
    await _loadVideos();
  }

  String _getYoutubeThumbnail(String url) {
    final uri = Uri.tryParse(url);
    if (uri == null) return '';
    final videoId = uri.pathSegments.isNotEmpty ? uri.pathSegments.last.split('?').first : '';
    if (videoId.isEmpty) return '';
    return 'https://img.youtube.com/vi/$videoId/0.jpg';
  }

  String _getDisplayName(String type) {
    switch (type.toLowerCase()) {
      case 'dashboard':
        return 'Dashboard';
      case 'orders':
        return 'Orders';
      case 'pickups':
        return 'Pickup';
      case 'shipments':
        return 'Shipment';
      default:
        return type;
    }
  }

  void _showVideoPlayer(BuildContext context, String youtubeUrl) {
    final videoId = YoutubePlayer.convertUrlToId(youtubeUrl);
    if (videoId == null) {
      Get.snackbar('Error', 'Invalid YouTube URL');
      return;
    }
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => YoutubePlayerFullScreenPage(videoId: videoId),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          title: const Text(
            'Help Videos',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          backgroundColor: Colors.white,
          
          foregroundColor: Colors.black,
          surfaceTintColor: Colors.white,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
        ),
        body: GestureDetector(
          behavior: HitTestBehavior.translucent,
          onTap: () {
            FocusScope.of(context).unfocus();
          },
          child: Column(
            children: [
              
              Container(
                padding: const EdgeInsets.all(16),
                child: Column(
                  children: [
                    
                    Row(
                      children: [
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(bottom: 8),
                                child: Text(
                                  'Type',
                                  style: GoogleFonts.poppins(
                                    fontWeight: FontWeight.w500,
                                    fontSize: 13,
                                    color: Colors.grey[700],
                                  ),
                                ),
                              ),
                              GestureDetector(
                                onTap: () async {
                                  final selected = await showModalBottomSheet<String>(
                                    context: context,
                                    isScrollControlled: true,
                                    backgroundColor: Colors.transparent,
                                    builder: (context) => _VideoTypeDialog(
                                      videoTypes: _videoTypes,
                                      selectedType: _selectedType,
                                    ),
                                  );
                                  if (selected != null) {
                                    
                                    setState(() {
                                      _selectedType = selected;
                                    });
                                    // Clear cache when filter changes to ensure fresh data
                                    clearAllHelpVideosCaches();
                                    _restoreOrFetchVideos(); 
                                  }
                                },
                                child: Container(
                                  margin: const EdgeInsets.only(bottom: 8),
                                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                  decoration: BoxDecoration(
                                    color: const Color(0xFFF5F5F7), 
                                    borderRadius: BorderRadius.circular(12), 
                                    border: Border.all(color: Colors.grey[300]!, width: 1),
                                    
                                  ),
                                  child: Row(
                                    children: [
                                      Expanded(
                                                                child: Text(
                          _getDisplayName(_selectedType),
                          style: GoogleFonts.poppins(fontSize: 15, color: Colors.black),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                                      ),
                                      const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                                    ],
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              
              Expanded(
                child: _buildVideosList(),
              ),
            ],
          ),
        ),
        floatingActionButton: MediaQuery.of(context).viewInsets.bottom == 0
            ? FloatingActionButton(
          onPressed: () {
            Get.to(() => CreateOrderScreen());
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
                child: SvgPicture.asset('assets/Create Order.svg', width: 28, height: 28, color: Colors.white),
              )
            : null,
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        bottomNavigationBar: AppBottomBar(
          selectedIndex: 3,
          onOrderListTap: () => Get.to(() => OrderListScreen(from: 'help_videos')),
          onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'help_videos')),
        ),
      ),
    );
  }

  Widget _buildVideosList() {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)));
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text(
              'Error loading videos',
              style: TextStyle(fontSize: 18, color: Colors.grey[600]),
            ),
            const SizedBox(height: 8),
            Text(
              _error!,
              style: TextStyle(fontSize: 14, color: Colors.grey[500]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _manualRefresh, 
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }

    if (_videos.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.video_library_rounded, size: 64, color: Colors.grey[400]),
            const SizedBox(height: 16),
            Text(
              'No help videos found',
              style: TextStyle(fontSize: 18, color: Colors.grey[600]),
            ),
            if (_videos.isNotEmpty) ...[
              const SizedBox(height: 8),
              Text(
                'Try adjusting your search or filters',
                style: TextStyle(fontSize: 14, color: Colors.grey[500]),
              ),
            ],
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _manualRefresh,
      child: AnimatedListView(
        padding: const EdgeInsets.only(left: 16, right: 16, bottom: 80), 
        itemCount: _videos.length,
        itemBuilder: (context, index) {
        final video = _videos[index];
        final isPlaying = _playingIndex == index;
        return Container(
          margin: const EdgeInsets.only(bottom: 16),
          child: InkWell(
            onTap: () {
              setState(() {
                if (_playingIndex == index) {
                  _playingIndex = null;
                  _youtubeController?.pause();
                  _youtubeController?.dispose();
                  _youtubeController = null;
                  SystemChrome.setPreferredOrientations([
                    DeviceOrientation.portraitUp,
                  ]);
                } else {
                  _playingIndex = index;
                  _youtubeController?.pause();
                  _youtubeController?.dispose();
                  final videoId = YoutubePlayer.convertUrlToId(video.postLink);
                  if (videoId != null) {
                    _youtubeController = YoutubePlayerController(
                      initialVideoId: videoId,
                      flags: const YoutubePlayerFlags(
                        autoPlay: true,
                        mute: false,
                        forceHD: false,
                        disableDragSeek: false,
                        enableCaption: false,
                        isLive: false,
                        hideControls: false,
                        hideThumbnail: false,
                        controlsVisibleAtStart: true,
                        useHybridComposition: true,
                        
                      ),
                    );
                    SystemChrome.setPreferredOrientations([
                      DeviceOrientation.portraitUp,
                    ]);
                  } else {
                    _youtubeController = null;
                  }
                }
              });
            },
            borderRadius: BorderRadius.circular(16),
            child: Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ClipRRect(
                    borderRadius: BorderRadius.circular(12),
                    child: Stack(
                      children: [
                        AspectRatio(
                          aspectRatio: 16 / 9,
                          child: isPlaying && _youtubeController != null
                              ? Stack(
                                  children: [
                                    YoutubePlayer(
                                      controller: _youtubeController!,
                                      showVideoProgressIndicator: true,
                                      progressIndicatorColor: Colors.blueAccent,
                                      onReady: () {
                                        _youtubeController!.addListener(() {
                                          setState(() {
                                            _lastPlayerValue = _youtubeController!.value;
                                          });
                                        });
                                      },
                                      onEnded: (meta) {
                                        setState(() {
                                          _playingIndex = null;
                                          _youtubeController?.dispose();
                                          _youtubeController = null;
                                        });
                                      },
                                    ),
                                    Positioned(
                                      top: 8,
                                      right: 8,
                                      child: GestureDetector(
                                        onTap: () {
                                          final videoId = _youtubeController!.initialVideoId;
                                          _youtubeController?.pause();
                                          Navigator.of(context).push(
                                            MaterialPageRoute(
                                              builder: (_) => YoutubePlayerFullScreenPage(videoId: videoId),
                                            ),
                                          );
                                        },
                                        child: Container(
                                          decoration: BoxDecoration(
                                            color: Colors.black.withOpacity(0.5),
                                            borderRadius: BorderRadius.circular(20),
                                          ),
                                          padding: const EdgeInsets.all(6),
                                          child: const Icon(Icons.fullscreen, color: Colors.white, size: 24),
                                        ),
                                      ),
                                    ),
                                  ],
                                )
                              : Image.network(
                                  _getYoutubeThumbnail(video.postLink),
                                  fit: BoxFit.cover,
                                  width: double.infinity,
                                  errorBuilder: (c, e, s) => Container(
                                    color: Colors.grey[200],
                                    child: const Icon(Icons.video_library_rounded, size: 48),
                                  ),
                                ),
                        ),
                        
                      ],
                    ),
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: _getTypeColor(video.type),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Text(
                          video.type,
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    video.title,
                    style: const TextStyle(fontWeight: FontWeight.w600, fontSize: 16),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Posted: ${video.postDate}',
                    style: const TextStyle(fontSize: 13, color: Color(0xFF8E8E93)),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    ),
    );
  }

  Color _getTypeColor(String type) {
    switch (type.toLowerCase()) {
      case 'tutorial':
        return Colors.blue;
      case 'guide':
        return Colors.green;
      case 'faq':
        return Colors.orange;
      case 'setup':
        return Colors.purple;
      default:
        return Colors.grey;
    }
  }
}

class _VideoTypeDialog extends StatefulWidget {
  final List<String> videoTypes;
  final String selectedType;
  const _VideoTypeDialog({Key? key, required this.videoTypes, required this.selectedType}) : super(key: key);

  @override
  State<_VideoTypeDialog> createState() => _VideoTypeDialogState();
}

class _VideoTypeDialogState extends State<_VideoTypeDialog> {
  String? selected;

  @override
  void initState() {
    super.initState();
    selected = widget.selectedType;
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: SingleChildScrollView(
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Text('Select Video Type', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                    const SizedBox(height: 12),
                    SizedBox(
                      height: 300,
                      child: widget.videoTypes.isEmpty
                           ? const Center(child: Text('No video types found.', style: TextStyle(color: Colors.grey)))
                           : AnimatedListViewSeparated(
                               itemCount: widget.videoTypes.length,
                               separatorBuilder: (_, __) => Container(
                                 height: 1,
                                 color: Colors.black.withOpacity(0.08),
                                 margin: const EdgeInsets.symmetric(horizontal: 8),
                               ),
                               itemBuilder: (context, i) {
                                final videoType = widget.videoTypes[i];
                                final isSelected = videoType == selected;
                                return ListTile(
                                  title: Text(
                                    videoType,
                                    style: TextStyle(
                                      color: isSelected ? Colors.black : Colors.black,
                                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                    ),
                                  ),
                                  selected: isSelected,
                                  selectedTileColor: const Color(0xFFE6F0FF),
                                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                  onTap: () {
                                    Navigator.of(context).pop(videoType);
                                  },
                                  trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                );
                              },
                            ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class YoutubePlayerFullScreenPage extends StatelessWidget {
  final String videoId;
  const YoutubePlayerFullScreenPage({Key? key, required this.videoId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        elevation: 0,
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: Center(
        child: YoutubePlayer(
          controller: YoutubePlayerController(
            initialVideoId: videoId,
            flags: const YoutubePlayerFlags(
              autoPlay: true,
              mute: false,
              
            ),
          ),
          showVideoProgressIndicator: true,
          progressIndicatorColor: Colors.blueAccent,
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'report.dart' as report;
import 'dashboard_screen.dart' as dash;
import 'menu.dart' as menu;
import 'order_list_screen.dart' as order_list;
import 'report.dart' as report;
import '../utils/Layout/app_bottom_bar.dart';
import '../services/load_sheet_service.dart';
import '../services/auth_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import '../models/load_sheet_model.dart';
import '../models/load_sheet_detail_model.dart';
import '../utils/custom_snackbar.dart';
import '../widgets/custom_date_selector.dart';
import '../widgets/courier_logo_widget.dart';
import 'create_order.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../services/courier_service.dart';
import 'package:collection/collection.dart'; 
import '../models/courier_account.dart';
import 'package:dio/dio.dart'; 
import '../config/api_config.dart';
import 'create_loadsheet_screen.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'loadsheet_details_screen.dart';
import '../widgets/transition.dart';

class SingleSelectList extends StatefulWidget {
  final List<CourierAccount> items;
  final CourierAccount? selectedItem;
  final ValueChanged<CourierAccount> onSelected;
  const SingleSelectList({required this.items, required this.selectedItem, required this.onSelected});

  @override
  State<SingleSelectList> createState() => SingleSelectListState();
}

class SingleSelectListState extends State<SingleSelectList> {
  String _search = '';

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.courierName.toLowerCase().contains(_search.toLowerCase())).toList();
    return Column(
      children: [
        TextField(
          decoration: InputDecoration(
            hintText: 'Search',
            prefixIcon: Icon(Icons.search_rounded, color: Colors.black),
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
          ),
          onChanged: (val) => setState(() => _search = val),
        ),
        const SizedBox(height: 12),
        SizedBox(
          height: 200,
          child: AnimatedListViewSeparated(
            itemCount: filteredItems.length,
            separatorBuilder: (_, __) => Container(
              height: 1,
              color: Colors.black.withOpacity(0.08),
              margin: const EdgeInsets.symmetric(horizontal: 8),
            ),
            itemBuilder: (context, i) {
              final item = filteredItems[i];
              final isSelected = widget.selectedItem?.id == item.id;
              return ListTile(
                title: Text(item.courierName),
                trailing: isSelected
                    ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                    : null,
                onTap: () => widget.onSelected(item),
                selected: isSelected,
                selectedTileColor: const Color(0xFFE6F0FF),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

class MultiSelectDialog extends StatefulWidget {
  final String title;
  final List<String> items;
  final List<String> initialSelected;
  const MultiSelectDialog({required this.title, required this.items, required this.initialSelected});

  @override
  State<MultiSelectDialog> createState() => MultiSelectDialogState();
}

class MultiSelectDialogState extends State<MultiSelectDialog> {
  late List<String> _selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    _selected = List<String>.from(widget.initialSelected);
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Dialog(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      insetPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 24),
      child: AnimationLimiter(
        child: LayoutBuilder(
          builder: (context, constraints) {
            final maxHeight = MediaQuery.of(context).size.height * 0.5;
            return ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: maxHeight,
                minWidth: 300,
                maxWidth: 400,
              ),
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 200,
                          child: AnimatedListViewSeparated(
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isChecked = _selected.contains(item);
                              return ListTile(
                                title: Text(item),
                                trailing: isChecked
                                    ? const Icon(Icons.check_circle_rounded, color: Color(0xFF007AFF))
                                    : const Icon(Icons.radio_button_unchecked_rounded, color: Colors.grey),
                                onTap: () {
                                  setState(() {
                                    if (isChecked) {
                                      _selected.remove(item);
                                    } else {
                                      _selected.add(item);
                                    }
                                  });
                                },
                              );
                            },
                          ),
                        ),
                        const SizedBox(height: 16),
                        ElevatedButton(
                          style: ElevatedButton.styleFrom(backgroundColor:Color(0xFF007AFF)),
                          onPressed: () {
                            Navigator.of(context).pop(List<String>.from(_selected));
                          },
                          child: const Text('OK', style: TextStyle(color: Colors.white)),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

class LoadSheetScreen extends StatefulWidget {
  const LoadSheetScreen({Key? key}) : super(key: key);

  @override
  State<LoadSheetScreen> createState() => _LoadSheetScreenState();
}

class _LoadSheetScreenState extends State<LoadSheetScreen> {
  final LoadSheetService _loadSheetService = LoadSheetService();
  final AuthService _authService = Get.find<AuthService>();
  
  List<LoadSheetModel> _loadSheets = [];
  bool _isRefreshing = false; 
  bool isLoading = false; 
  String? _currentAcno;
  
  String? _searchQuery;
  List<LoadSheetModel> _filteredLoadSheets = [];
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  List<String> _selectedCouriers = [];
  String? _selectedCourierId;
  String? _selectedCustomerCourierId;
  List<String> _courierOptions = [];
  bool _isLoadingCouriers = false;
  
  
  DateTime _startDate = DateTime.now().subtract(const Duration(days: 3));
  DateTime _endDate = DateTime.now();

  
  static Map<String, dynamic>? _lastParams;
  static List<LoadSheetModel>? _cachedLoadSheets;





  @override
  void initState() {
    super.initState();
    
    _filteredLoadSheets = [];
    _loadLoadSheets();
    _searchController.addListener(_onSearchChanged);
    _searchFocusNode.addListener(() {
      if (!_searchFocusNode.hasFocus) {
        
        setState(() {});
      }
    });
    _fetchCouriers();
  }



  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text;
      _applySearch();
    });
  }

  Future<void> _loadCurrentUserAcno() async {
    final user = _authService.currentUser.value;
    if (user != null) {
      setState(() {
        _currentAcno = user.acno;
      });
      await _loadLoadSheets(force: true);
    }
  }

  void _clearCache() {
  
    _lastParams = null;
    _cachedLoadSheets = null;
    // Also clear filtered results to ensure fresh data
    _filteredLoadSheets = [];
  }

  void _clearAllCaches() {
    
    _lastParams = null;
    _cachedLoadSheets = null;
    _filteredLoadSheets = [];
    _loadSheets = [];
    // Force rebuild
    setState(() {});
  }

  Future<void> forceRefresh() async {
    
    _clearAllCaches(); // Use more aggressive cache clearing
    await _loadLoadSheets(force: true);
    _applySearch(); // Ensure search filters are reapplied after refresh
  }

  Future<void> _refreshAfterOperation() async {
    
    _clearAllCaches();
    await _loadLoadSheets(force: true);
    _applySearch();
  }

  Future<void> _loadLoadSheets({bool force = false}) async {
    final acno = _currentAcno ?? _authService.getCurrentAcno();
    if (acno == null) return;

    // Clear cache if force refresh is requested
    if (force) {
      
      _lastParams = null;
      _cachedLoadSheets = null;
      _filteredLoadSheets = [];
    }

    final params = {
      'acno': acno,
      'startDate': _startDate.toIso8601String().split('T')[0],
      'endDate': _endDate.toIso8601String().split('T')[0],
      'courierId': _selectedCourierId != null ? int.tryParse(_selectedCourierId!) : null,
      'customerCourierId': _selectedCustomerCourierId != null ? int.tryParse(_selectedCustomerCourierId!) : null,
    };
    
    if (!force && _lastParams != null && _cachedLoadSheets != null &&
        _lastParams.toString() == params.toString()) {
      
      setState(() {
        _loadSheets = List<LoadSheetModel>.from(_cachedLoadSheets!);
        _applySearch();
      });
      return;
    }
    
   
    setState(() {
      isLoading = true;
    });
    
    _lastParams = params;
    try {
      final loadSheets = await _loadSheetService.getLoadSheets(
        acno: acno,
        startDate: _startDate.toIso8601String().split('T')[0],
        endDate: _endDate.toIso8601String().split('T')[0],
        courierId: _selectedCourierId != null ? int.tryParse(_selectedCourierId!) : null,
        customerCourierId: _selectedCustomerCourierId != null ? int.tryParse(_selectedCustomerCourierId!) : null,
      );

      
      setState(() {
        _loadSheets = loadSheets;
        _cachedLoadSheets = List<LoadSheetModel>.from(loadSheets); 
        _applySearch();
      });
    } catch (e) {
      print(' Error fetching load sheets: $e');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  void _applySearch() {
    if (_searchQuery != null && _searchQuery!.isNotEmpty) {
      final query = _searchQuery!.toLowerCase();
      _filteredLoadSheets = _loadSheets.where((sheet) {
        return sheet.sheetNo.toLowerCase().contains(query) ||
               sheet.courierName.toLowerCase().contains(query) ||
               (sheet.courierId?.toLowerCase() ?? '').contains(query) ||
               (sheet.consignmentNo ?? '').toLowerCase().contains(query) ||
               sheet.accountTitle.toLowerCase().contains(query);
      }).toList();
    } else {
      _filteredLoadSheets = _loadSheets;
    }
    
    if (_selectedCouriers.isNotEmpty) {
      _filteredLoadSheets = _filteredLoadSheets.where((sheet) {
        final sheetCourierName = sheet.courierName.toLowerCase().trim();
        final sheetAccountTitle = sheet.accountTitle.toLowerCase().trim();
        
        
        bool hasMatch = _selectedCouriers.any((selectedCourier) {
          final filterCourier = selectedCourier.toLowerCase().trim();
          
          
          if (filterCourier.contains('managed')) {
            return sheetAccountTitle.contains('managed');
          }
          
          else {
            
            bool courierMatches = sheetCourierName.contains(filterCourier) ||
                                 filterCourier.contains(sheetCourierName);
            
            
            if (courierMatches) {
              return !sheetAccountTitle.contains('managed');
            }
            return false;
          }
        });
        
        return hasMatch;
      }).toList();
    }
  }

  Future<void> _selectDateRange() async {
    final DateTimeRange? picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      initialDateRange: DateTimeRange(
        start: _startDate,
        end: _endDate,
      ),
    );

    if (picked != null) {
      setState(() {
        _startDate = picked.start;
        _endDate = picked.end;
      });
      await _loadLoadSheets(force: true);
    }
  }

  @override
  Widget build(BuildContext context) {
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        resizeToAvoidBottomInset: false,
        appBar: AppBar(
          backgroundColor: Colors.white,
          
          foregroundColor: Colors.white,
          surfaceTintColor: Colors.white,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
            onPressed: () => Navigator.of(context).maybePop(),
          ),
          title: const Text(
            'Load Sheet',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
          actions: [
            if (_searchQuery != null && _searchQuery!.isNotEmpty)
              IconButton(
                icon: const Icon(Icons.clear_rounded, color: Colors.grey),
                onPressed: () {
                  setState(() {
                    _searchController.clear();
                    _searchQuery = null;
                    _applySearch();
                  });
                },
              ),

            IconButton(
              icon: SvgPicture.asset(
                'assets/Filter.svg',
                width: 24,
                height: 24,
                color: Colors.black,
              ),
              onPressed: () async {
                await Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => LoadSheetFilterScreen(
                      initialCourier: (_selectedCouriers.isNotEmpty && _selectedCourierId != null && _selectedCustomerCourierId != null)
                          ? {
                              'customer_courier_id': _selectedCustomerCourierId,
                              'courier_id': _selectedCourierId,
                              'courier_name': _selectedCouriers.first,
                            }
                          : null,
                      onApply: (courier) async {
                        setState(() {
                          _selectedCouriers = [courier['courier_name'] ?? ''];
                          _selectedCourierId = courier['courier_id'];
                          _selectedCustomerCourierId = courier['customer_courier_id'];
                        });
                        
                        await _loadLoadSheets(force: true);
                        _applySearch(); // Apply filters to the loaded data
                        customSnackBar('Success', 'Filters applied successfully');
                      },
                      onReset: () async {
                        setState(() {
                          _selectedCouriers = [];
                          _selectedCourierId = null;
                          _selectedCustomerCourierId = null;
                        });
                        await _loadLoadSheets(force: true);
                        _applySearch(); // Apply filters to the loaded data
                        customSnackBar('Success', 'Filters cleared');
                      },
                    ),
                  ),
                );
              },
            ),
            IconButton(
              icon: SvgPicture.asset(
    'assets/Calender.svg',
    width: 24,
    height: 24,
    color: Colors.black, 
  ),
            onPressed: () async {
              final picked = await showModalBottomSheet<DateTimeRange>(
                context: context,
                isScrollControlled: true,
                backgroundColor: Colors.transparent,
                builder: (context) => Container(
                  width: MediaQuery.of(context).size.width,
                  height: MediaQuery.of(context).size.height * 0.6,
                  decoration: const BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                  ),
                  child: CustomDateSelector(
                    initialStartDate: _startDate,
                    initialEndDate: _endDate,
                  ),
                ),
              );
              if (picked != null) {
                setState(() {
                  _startDate = picked.start;
                  _endDate = picked.end;
                });
                await _loadLoadSheets(force: true);
                _applySearch(); // Apply filters after date change
              }
            },
          ),
        ],
      ),
      body: isLoading
        ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
        : GestureDetector(
            behavior: HitTestBehavior.translucent,
            onTap: () {
              FocusScope.of(context).unfocus();
            },
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 8),
              Padding(
                padding: const EdgeInsets.only(bottom: 4, top: 8),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      _getDateRangeFormatted(),
                      style: GoogleFonts.poppins(
                        fontSize: 13,
                        fontWeight: FontWeight.w400,
                        color: Colors.grey,
                      ),
                    ),
                    GestureDetector(
                      onTap: () async {
                        final result = await Navigator.of(context).push(
                          MaterialPageRoute(builder: (_) => CreateLoadsheetScreen()),
                        );
                        
                        if (result == true) {
                          await _loadLoadSheets(force: true);
                        }
                      },
                      child: Text(
                        'Add Loadsheet',
                        style: GoogleFonts.poppins(
                          fontWeight: FontWeight.w500,
                          fontSize: 14,
                          color: Color(0xFF007AFF),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 4),
                child: TextField(
                  controller: _searchController,
                  focusNode: _searchFocusNode,
                  decoration: InputDecoration(
                    hintText: 'Search',
                    suffixIcon: Icon(Icons.search_rounded),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    filled: true,
                    fillColor: const Color(0xFFF5F5F7),
                    contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide.none,
                    ),
                  ),
                ),
              ),
              
              
              if (_selectedCouriers.isNotEmpty && _selectedCouriers.first.isNotEmpty) ...[
                const SizedBox(height: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.blue.withOpacity(0.3)),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.filter_list_rounded, size: 16, color: Colors.blue[700]),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'Courier: ${_selectedCouriers.join(", ")} (${_selectedCouriers.isNotEmpty ? _loadSheets.where((sheet) => _selectedCouriers.contains(sheet.courierName)).length : _loadSheets.length})',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.blue[700],
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      ),
                      GestureDetector(
                        onTap: () async {
                          setState(() {
                            _selectedCouriers = [];
                            _selectedCourierId = null;
                            _selectedCustomerCourierId = null;
                          });
                          await _loadLoadSheets(force: true);
                          customSnackBar('Success', 'Filters cleared');
                        },
                        child: Icon(Icons.clear_rounded, size: 16, color: Colors.blue[700]),
                      ),
                    ],
                  ),
                ),
              ],
              Expanded(child: _buildBody()),
            ],
          ),
        ),
      ),
              bottomNavigationBar: AppBottomBar(
                selectedIndex: 3,
                onOrderListTap: () => Get.to(() => order_list.OrderListScreen(from: 'loadsheet')),
                onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'loadsheet')),
              ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (context) => const CreateOrderScreen(),
            ),
          );
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
    ),
  );
  }

  Widget _buildBody() {
    if (_isRefreshing) {
      return const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)));
    }

    final list = (_searchQuery != null && _searchQuery!.isNotEmpty || _selectedCouriers.isNotEmpty) ? _filteredLoadSheets : _loadSheets;
    if (list.isEmpty) {
      return const Center(
        child: Text(
          'No data found',
          style: TextStyle(fontSize: 16, color: Colors.grey),
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _manualRefresh,
      child: AnimatedListViewSeparated(
        padding: const EdgeInsets.only(bottom: 120, top: 12),
              itemCount: list.length,
        physics: const AlwaysScrollableScrollPhysics(),
              separatorBuilder: (context, i) => const SizedBox(height: 8),
              itemBuilder: (context, i) {
                final sheet = list[i];
                return Container(
                  padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                  decoration: BoxDecoration(
                    color: const Color(0xFFF5F5F7),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  margin: const EdgeInsets.only(top: 4, bottom: 4),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: Padding(
                              padding: const EdgeInsets.only(top: 8),
                              child: Text(
                                'Sheet No: ${sheet.sheetNo}',
                                style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                              ),
                            ),
                          ),
                          Column(
                            children: [
                              SizedBox(height: 6),
                              Container(
                                constraints: const BoxConstraints(minWidth: 50, maxWidth: 70),
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
                                decoration: BoxDecoration(
                                  color: const Color(0xFF28C76F).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  'Active',
                                  style: GoogleFonts.inter(
                                    color: const Color(0xFF28C76F),
                                    fontWeight: FontWeight.w500,
                                    fontSize: 12
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                      const SizedBox(height: 8),
                      _defListRow('Date', _formatDate(sheet.createdAt)),
                      SizedBox(height: 4),
                      _defListRow('Shipments', sheet.shipmentCount),
                      SizedBox(height: 4),
                      _defListRow('Account', sheet.accountTitle),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          SizedBox(
                            width: sheet.courierName != null &&
                                   sheet.courierName.toString().length > 10
                                 ? 113
                                 : 98,
                            child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                          ),
                          const SizedBox(width: 26), 
                          CourierLogoWidget(
                            pngUrl: sheet.courierName,
                            courierId: sheet.courierId,
                            accountTitle: sheet.accountTitle,
                            width: 78,
                            height: 36,
                            fit: BoxFit.contain,
                          ),
                        ],
                      ),
                      if (sheet.consignmentNo != null && sheet.consignmentNo!.isNotEmpty) ...[
                        SizedBox(height: 4),
                        _defListRow('CN', sheet.consignmentNo!),
                      ],
                      const SizedBox(height: 4),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          SizedBox(
                            width: 100,
                            child: Text('Action', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                          ),
                          const SizedBox(width: 36),
                          Expanded(
                            child: Row(
                              children: [
                                GestureDetector(
                                  onTap: () async {
                                    final details = await _getLoadSheetDetails(sheet.sheetNo);
                                    if (details != null && details.isNotEmpty) {
                                      final result = await Navigator.of(context).push(
                                        MaterialPageRoute(
                                          builder: (context) => LoadsheetDetailsScreen(
                                            loadsheetDataList: details,
                                            onRefresh: () async {

                                              await _refreshAfterOperation();
                                            },
                                          ),
                                        ),
                                      );
                                      
                                      // Additional refresh when returning from details screen
                                      if (result == true) {
                                        
                                        await _refreshAfterOperation();
                                      }
                                    } else {
                                      customSnackBar('Error', 'Failed to load loadsheet details');
                                    }
                                  },
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      SvgPicture.asset(
                                        'assets/Edit.svg',
                                        width: 20,
                                        height: 20,
                                        color: const Color(0xFF007AFF),
                                      ),
                                      const SizedBox(width: 4),
                                      Text('Edit', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                    ],
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                );
              },
      ),
    );
  }

  String _formatDate(String dateString) {
    try {
      final date = DateTime.parse(dateString);
      return '${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
    } catch (e) {
      return dateString;
    }
  }

  String _getDateRangeText() {
    final now = DateTime.now();
    final difference = now.difference(_startDate).inDays;
    
    if (difference == 0) {
      return 'Today';
    } else if (difference == 1) {
      return 'L';
    } else if (difference <= 7) {
      return '';
    } else if (difference <= 30) {
      final weeks = (difference / 7).round();
      return '';
    } else if (difference <= 365) {
      final months = (difference / 30).round();
      return '';
    } else {
      final years = (difference / 365).round();
      return '';
    }
  }

  String _getDateRangeFormatted() {
    String format(DateTime d) =>
        '${d.day.toString().padLeft(2, '0')}-${d.month.toString().padLeft(2, '0')}-${d.year}';
    return '${format(_startDate)} to ${format(_endDate)}';
  }

  Future<void> _showLoadSheetEditDialog(LoadSheetModel sheet) async {
    final details = await _fetchLoadSheetSingle(sheet.sheetNo);
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: Padding(
            padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Row(
                        children: [
                          const Text(
                            'Loadsheet Details',
                            style: TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                              fontFamily: 'SF Pro Display',
                            ),
                          ),
                          const SizedBox(width: 12),
                          Container(
                            constraints: const BoxConstraints(minWidth: 90, maxWidth: 140),
                            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                            decoration: BoxDecoration(
                              color: () {
                                final status = details?['order_status']?.toString().toLowerCase();
                                if (status == 'cancelled' || status == 'deleted') return Colors.red;
                                if (status == 'booked') return Color(0xFF8e24aa); 
                                if (status == 'new') return Color(0xFF1DA1F2); 
                                if (status == 'pickup ready') return Color(0xFF43A047); 
                                return Colors.grey;
                              }(),
                              borderRadius: BorderRadius.circular(16),
                            ),
                            alignment: Alignment.center,
                            child: Text(
                              details?['order_status']?.toString().capitalize ?? '',
                              style: GoogleFonts.inter(color: Colors.white, fontWeight: FontWeight.w500, fontSize: 15),
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                      IconButton(
                        icon: const Icon(Icons.close_rounded),
                        onPressed: () => Navigator.of(context).pop(),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  _orderDetailRow('ID', details?['id'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Loadsheet ID', details?['loadsheet_id'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Account No', details?['acno'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Order ID', details?['order_id'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Consignment No', details?['consignment_no'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Courier ID', details?['courier_id'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Customer Courier ID', details?['customer_courier_id'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Status', details?['status'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Is Deleted', details?['is_deleted'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Created At', details?['created_at'] ?? ''),
                  SizedBox(height: 10),
                  _orderDetailRow('Updated At', details?['updated_at'] ?? ''),
                  SizedBox(height: 10),
                                        _orderDetailRow('Order Last Status ID', details?['order_last_status_id'] ?? ''),
                  const SizedBox(height: 12),
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      SizedBox(
                        width: 90,
                        child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 14)),
                      ),
                      const SizedBox(width: 36),
                      GestureDetector(

                        
                        onTap: () async {
                          final orderIdStr = details?['order_id']?.toString() ?? '';
                          final consignmentNo = details?['consignment_no']?.toString() ?? '';
                          final orderId = int.tryParse(orderIdStr);
                          if (orderId == null || consignmentNo.isEmpty) {
                            customSnackBar('Error', 'Invalid order ID or consignment no');
                            return;
                          }
                          final result = await _deleteLoadSheetByApi(orderId, consignmentNo);
                          if (result['success']) {
                            customSnackBar('Success', result['message']);
                            Navigator.of(context).pop();
                            await _loadLoadSheets(force: true);
                          } else {
                            customSnackBar('Error', 'Failed to delete load sheet');
                          }
                        },
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.delete_rounded, color: Color(0xFF007AFF)),
                            SizedBox(width: 8),
                            Text('Delete', style: GoogleFonts.inter(color: Color(0xFF007AFF), fontWeight: FontWeight.w500)),
                          ],
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _orderDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 13)),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }

  void _showLoadSheetDetails(LoadSheetModel sheet) async {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) {
        return FutureBuilder<Map<String, dynamic>?>(
          future: _fetchLoadSheetSingle(sheet.sheetNo),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Padding(
                padding: EdgeInsets.all(32),
                child: Center(child: CircularProgressIndicator(color: Color(0xFF007AFF))),
              );
            }
            if (snapshot.hasError || snapshot.data == null) {
              return const Padding(
                padding: EdgeInsets.all(32),
                child: Center(child: Text('Failed to load details', style: TextStyle(color: Colors.red))),
              );
            }
            final details = snapshot.data!;
            return Padding(
              padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text(
                          'Tracking Details',
                          style: TextStyle(fontSize: 18, fontWeight: FontWeight.w700, fontFamily: 'SF Pro Display'),
                        ),
                        Row(
                          children: [
                            IconButton(
                              icon: const Icon(Icons.delete_rounded, color: Colors.red),
                              tooltip: 'Delete',
                              onPressed: () async {
                                final orderIdStr = details['order_id']?.toString() ?? '';
                                final consignmentNo = details['consignment_no']?.toString() ?? '';
                                final orderId = int.tryParse(orderIdStr);
                                if (orderId == null || consignmentNo.isEmpty) {
                                  customSnackBar('Error', 'Invalid order ID or consignment no');
                                  return;
                                }
                                final result = await _deleteLoadSheetByApi(orderId, consignmentNo);
                                if (result['success']) {
                                  customSnackBar('Success', result['message']);
                                  Navigator.of(context).pop();
                                  await _loadLoadSheets(force: true);
                                } else {
                                  customSnackBar('Error', result['message']);
                                }
                              },
                            ),
                            IconButton(
                              icon: const Icon(Icons.close_rounded),
                              onPressed: () => Navigator.of(context).pop(),
                            ),
                          ],
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    _defListRow('ID', details['id'] ?? ''),
                    _defListRow('Loadsheet ID', details['loadsheet_id'] ?? ''),
                    _defListRow('Account No', details['acno'] ?? ''),
                    _defListRow('Order ID', details['order_id'] ?? ''),
                    _defListRow('Consignment No', details['consignment_no'] ?? ''),
                    _defListRow('Courier ID', details['courier_id'] ?? ''),
                    _defListRow('Customer Courier ID', details['customer_courier_id'] ?? ''),
                    _defListRow('Status', details['status'] ?? ''),
                    _defListRow('Order Status', details['order_status'] ?? ''),
                    _defListRow('Created At', details['created_at'] ?? ''),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<Map<String, dynamic>?> _fetchLoadSheetSingle(String sheetNo) async {
    try {
      final intSheetNo = int.tryParse(sheetNo) ?? sheetNo;
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetSingleEndpoint),
        data: {'sheet_no': intSheetNo},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
     
      if (response.statusCode == 200 && response.data['status'] == 1 && response.data['payload'] is List && response.data['payload'].isNotEmpty) {
        return Map<String, dynamic>.from(response.data['payload'][0]);
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  void _showDeleteLoadSheetDialog(BuildContext context, LoadSheetModel sheet) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFEFF6FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(24),
                  child: SvgPicture.asset(
                    'assets/Delete.svg',
                    width: 56,
                    height: 56,
                    color: const Color(0xFF007AFF),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w700,
                    fontFamily: 'SF Pro Display',
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                const Text(
                  'You want to delete this loadsheet',
                  style: TextStyle(
                    fontSize: 15,
                    fontWeight: FontWeight.w400,
                    fontFamily: 'SF Pro Display',
                    color: Color(0xFF6B7280),
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF3F4F6),
                          foregroundColor: const Color(0xFF111827),
                          elevation: 0,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () async {
                          Navigator.of(context).pop(true);
                          await _deleteLoadSheet(sheet);
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          foregroundColor: Colors.white,
                          elevation: 0,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Future<void> _deleteLoadSheet(LoadSheetModel sheet) async {
    try {
      
      
      
      final detailsList = await _getLoadSheetDetails(sheet.sheetNo);
      
      if (detailsList == null || detailsList.isEmpty) {
        customSnackBar('Error', 'Failed to fetch load sheet details for deletion');
        return;
      }

      
      final details = detailsList.first;

      
      final orderId = int.tryParse(details['order_id']?.toString() ?? '');
      final consignmentNo = details['consignment_no']?.toString() ?? '';
      
      
      
      if (consignmentNo.isEmpty) {
        customSnackBar('Error', 'Consignment number not available for deletion');
        
        return;
      }

      if (orderId == null) {
        customSnackBar('Error', 'Invalid order ID for deletion');
        
        return;
      }

      

      
      final authService = Get.find<AuthService>();
      final acno = authService.getCurrentAcno();
      
      
      final requestBody = {
        'order_ids': [orderId.toString()],
        'consignment_nos': [consignmentNo],
        'acno': acno ?? '',
      };
     
   
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetDeleteEndpoint),
        data: requestBody,
        options: Options(headers: {'Content-Type': 'application/json'}),
      );

   

      if (response.statusCode == 200 && response.data['status'] == 1) {
        customSnackBar('Success', response.data['message'] ?? 'Load sheet deleted successfully!');
        
        await _loadLoadSheets(force: true);
      } else {
        customSnackBar('Error','Failed to delete load sheet');
      }
    } catch (e) {
      print('Exception in delete load sheet: $e');
      customSnackBar('Error', 'Failed to delete load sheet');
    }
  }

  static Widget _row(String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        children: [
          Text(label, style: _labelStyle),
          const SizedBox(width: 32),
          Text(value, style: _valueStyle),
        ],
      ),
    );
  }

  Future<void> _fetchCouriers() async {
    setState(() { _isLoadingCouriers = true; });
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        
        setState(() { _isLoadingCouriers = false; });
        return;
      }
      
      
      
      // Try to get cached couriers first
      final cachedCouriers = CourierService.getCachedCouriers(acno);
      if (cachedCouriers != null && cachedCouriers.isNotEmpty) {
       
        final courierOptions = _processCourierData(cachedCouriers);
        setState(() {
          _courierOptions = courierOptions;
        });
       
        setState(() { _isLoadingCouriers = false; });
        return;
      }
      
      
      
      // Fetch from API directly
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.courierAccountsEndpoint),
        data: {"acno": acno},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      
      
      List<dynamic> data = [];
      if (response.data is List) {
        data = response.data;
        
      } else if (response.data is Map) {
        if (response.data['data'] is List) {
          data = response.data['data'];
          
        } else if (response.data['payload'] is List) {
          data = response.data['payload'];
         
        } else {
         
          data = [];
        }
      }
      
      if (data.isEmpty) {
       
        setState(() {
          _courierOptions = [];
        });
        setState(() { _isLoadingCouriers = false; });
        return;
      }
      
     
      
      final courierOptions = _processCourierData(data);
      
      setState(() {
        _courierOptions = courierOptions;
      });
      

      
    } catch (e) {
      
      setState(() {
        _courierOptions = [];
      });
    } finally {
      setState(() { _isLoadingCouriers = false; });
    }
  }

  List<String> _processCourierData(List<dynamic> courierData) {
    return courierData.map((c) {
      final name = c['name']?.toString() ?? '';
      final courierName = c['courier_name']?.toString() ?? '';
      final accountTitle = c['account_title']?.toString() ?? '';
      
      String displayName;
      if (accountTitle.isNotEmpty && courierName.isNotEmpty) {
        displayName = '$accountTitle ($courierName)';
      } else if (accountTitle.isNotEmpty) {
        displayName = accountTitle;
      } else if (courierName.isNotEmpty) {
        displayName = courierName;
      } else if (name.isNotEmpty) {
        displayName = name;
      } else {
        displayName = 'Unknown Courier';
      }
      
      return displayName;
    }).where((s) => s.isNotEmpty && s != 'Unknown Courier').toList();
  }

  Future<void> _manualRefresh() async {
    setState(() { _isRefreshing = true; });
    await _loadLoadSheets(force: true);
    setState(() { _isRefreshing = false; });
  }
}

const _labelStyle = TextStyle(
  fontFamily: 'SF Pro Display',
  fontWeight: FontWeight.w400,
  fontSize: 14,
  color: Colors.black,
);

const _valueStyle = TextStyle(
  fontFamily: 'SF Pro Display',
  fontWeight: FontWeight.w300,
  fontSize: 14,
  color: Colors.black,
);

class _LoadsheetDetailsBottomSheet extends StatefulWidget {
  final LoadSheetModel sheet;
  final VoidCallback onDelete;

  const _LoadsheetDetailsBottomSheet({
    Key? key,
    required this.sheet,
    required this.onDelete,
  }) : super(key: key);

  @override
  State<_LoadsheetDetailsBottomSheet> createState() => _LoadsheetDetailsBottomSheetState();
}

class _LoadsheetDetailsBottomSheetState extends State<_LoadsheetDetailsBottomSheet> {

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Loadsheet Details',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                  fontFamily: 'SF Pro Display',
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close_rounded),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
          ),
          const SizedBox(height: 12),
          _detailRow('Sheet ID', widget.sheet.id),
          _detailRow('Sheet No', widget.sheet.sheetNo),
          _detailRow('Courier', widget.sheet.courierName),
          _detailRow('Account', widget.sheet.accountTitle),
          _detailRow('Shipments', widget.sheet.shipmentCount),
          if (widget.sheet.consignmentNo != null && widget.sheet.consignmentNo!.isNotEmpty)
            _detailRow('Consignment No', widget.sheet.consignmentNo!),
          _detailRow('Created At', _formatDate(widget.sheet.createdAt)),
          if (widget.sheet.consignmentNo != null && widget.sheet.consignmentNo!.isNotEmpty)
            _detailRow('Consignment No', widget.sheet.consignmentNo!),
          
          const SizedBox(height: 12),
          Row(
            children: [
              const Text('Action', style: TextStyle(fontWeight: FontWeight.w400)),
              const SizedBox(width: 16),
              GestureDetector(
                onTap: () async {
                  final confirmed = await showModalBottomSheet<bool>(
                    context: context,
                    isScrollControlled: true,
                    backgroundColor: Colors.transparent,
                    builder: (context) => _DeleteConfirmationBottomSheet(),
                  );
                  if (confirmed == true) {
                    Navigator.of(context).pop(); 
                    
                    widget.onDelete();
                  }
                },
                child: Row(
                  children: const [
                    Icon(Icons.delete_rounded, color: Color(0xFF007AFF)),
                    SizedBox(width: 4),
                    Text('Delete', style: TextStyle(color: Color(0xFF007AFF), fontWeight: FontWeight.w400)),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }



  Widget _detailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        children: [
          Text(
            label,
            style: const TextStyle(
              fontWeight: FontWeight.w400,
              fontFamily: 'SF Pro Display',
              fontSize: 15,
            ),
          ),
          const SizedBox(width: 16),
          Text(
            value,
            style: const TextStyle(
              fontWeight: FontWeight.w300,
              fontFamily: 'SF Pro Display',
              fontSize: 15,
            ),
          ),
        ],
      ),
    );
  }

  String _formatDate(String dateString) {
    try {
      final date = DateTime.parse(dateString);
      return '${date.year.toString().padLeft(4, '0')}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
    } catch (e) {
      return dateString;
    }
  }
}

class _DeleteConfirmationBottomSheet extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFEFF6FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(24),
              child: Icon(Icons.delete_rounded, size: 56, color: Color(0xFF007AFF)),
            ),
            const SizedBox(height: 24),
            const Text(
              'Are you Sure?',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.w700,
                fontFamily: 'SF Pro Display',
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            const Text(
              'You want to delete this load sheet',
              style: TextStyle(
                fontSize: 15,
                fontWeight: FontWeight.w400,
                fontFamily: 'SF Pro Display',
                color: Color(0xFF6B7280),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(false),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFFF3F4F6),
                      foregroundColor: const Color(0xFF111827),
                      elevation: 0,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: const Text('No', style: TextStyle(fontWeight: FontWeight.w400)),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(true),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      foregroundColor: Colors.white,
                      elevation: 0,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w400)),
                  ),
                ),
              ],
            ),
                      ],
                    ),
                  ),
                );
  }
}

class _DeleteSuccessBottomSheet extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(32),
              child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
            ),
            const SizedBox(height: 24),
            const Text(
              'Success!',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
            ),
            const SizedBox(height: 8),
            const Text(
              'You have successfully deleted load sheet',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => Navigator.of(context).pop(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  elevation: 0,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Colors.white)),
              ),
            ),
          ],
        ),
      ),
    );
  }
} 


class LoadSheetFilterScreen extends StatefulWidget {
  final Function(Map<String, String?> courier) onApply;
  final VoidCallback onReset;
  final Map<String, String?>? initialCourier;
  const LoadSheetFilterScreen({Key? key, required this.onApply, required this.onReset, this.initialCourier}) : super(key: key);

  @override
  State<LoadSheetFilterScreen> createState() => _LoadSheetFilterScreenState();
}

class _LoadSheetFilterScreenState extends State<LoadSheetFilterScreen> {
  CourierAccount? selectedCourier;
  List<CourierAccount> courierAccounts = [];
  bool _isLoadingCouriers = false;
  final AuthService _authService = Get.find<AuthService>();

  
  static List<CourierAccount>? _cachedCouriers;

  
  static void clearAllLoadsheetFilterCaches() {
    _cachedCouriers = null;
  }

  // Method to refresh data and clear cache
  Future<void> refreshData() async {
    _cachedCouriers = null;
    await fetchDropdownData();
  }

  @override
  void initState() {
    super.initState();
    // Load data immediately in background
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadUserDataAndFetchData();
    });
  }

  Future<void> _loadUserDataAndFetchData() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchDropdownData();
  }

  Future<void> fetchDropdownData() async {
    // Show cached data immediately if available
    if (_cachedCouriers != null) {
      setState(() {
        courierAccounts = List<CourierAccount>.from(_cachedCouriers!);
        _matchInitialCourier();
      });
      return;
    }

    // Show loading state briefly while fetching
    setState(() {
      _isLoadingCouriers = true;
      courierAccounts = [];
    });

    // Fetch data in background
    await _fetchCouriers();
    
    setState(() {
      _isLoadingCouriers = false;
    });
  }

  
  void _matchInitialCourier() {
    if (widget.initialCourier != null && selectedCourier == null) {
      final initialCourierId = widget.initialCourier!['customer_courier_id'];
      final initialCourierName = widget.initialCourier!['courier_name'];
      
      if (initialCourierId != null) {
        

        
        
        selectedCourier = courierAccounts.firstWhereOrNull((c) => c.id == initialCourierId.toString());
        
        if (selectedCourier != null) {

        } else {

          
          
          if (initialCourierName != null) {
            
            String extractedCourierName = initialCourierName;
            final bracketMatch = RegExp(r'\(([^)]+)\)').firstMatch(initialCourierName);
            if (bracketMatch != null) {
              extractedCourierName = bracketMatch.group(1)?.trim() ?? initialCourierName;

            }
            
            selectedCourier = courierAccounts.firstWhereOrNull((c) => 
              c.courierName.toLowerCase() == extractedCourierName.toLowerCase() ||
              c.accountTitle.toLowerCase() == extractedCourierName.toLowerCase() ||
              c.courierName.toLowerCase() == initialCourierName.toLowerCase() ||
              c.accountTitle.toLowerCase() == initialCourierName.toLowerCase()
            );
            
            if (selectedCourier != null) {
 
            } else {

            }
          }
        }
      }
    }
  }

  Future<void> _fetchCouriers() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        setState(() {
          courierAccounts = [];
        });
        return;
      }

      // Use timeout to prevent hanging requests
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.courierAccountsEndpoint),
        data: {"acno": acno},
        options: Options(
          headers: {'Content-Type': 'application/json'},
          sendTimeout: const Duration(seconds: 10),
          receiveTimeout: const Duration(seconds: 10),
        ),
      ).timeout(const Duration(seconds: 15));

      final List<dynamic> data = response.data is List
          ? response.data
          : (response.data['data'] ?? []);
      
      if (data.isNotEmpty) {
        setState(() {
          courierAccounts = data.map((e) => CourierAccount.fromJson(e)).toList();
          _cachedCouriers = List<CourierAccount>.from(courierAccounts);
          _matchInitialCourier();
        });
      } else {
        // Keep existing data if API returns empty
        if (_cachedCouriers != null) {
          setState(() {
            courierAccounts = List<CourierAccount>.from(_cachedCouriers!);
            _matchInitialCourier();
          });
        }
      }
    } catch (e) {
      // On error, try to use cached data if available
      if (_cachedCouriers != null) {
        setState(() {
          courierAccounts = List<CourierAccount>.from(_cachedCouriers!);
          _matchInitialCourier();
        });
      } else {
        setState(() {
          courierAccounts = [];
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final String? selectedCourierLabel = selectedCourier == null
        ? null
        : (selectedCourier!.accountTitle.isNotEmpty && selectedCourier!.courierName.isNotEmpty
            ? '${selectedCourier!.accountTitle} (${selectedCourier!.courierName})'
            : (selectedCourier!.accountTitle.isNotEmpty
                ? selectedCourier!.accountTitle
                : selectedCourier!.courierName));
    final List<String> courierLabels = courierAccounts.map((c) =>
        (c.accountTitle.isNotEmpty && c.courierName.isNotEmpty)
            ? '${c.accountTitle} (${c.courierName})'
            : (c.accountTitle.isNotEmpty ? c.accountTitle : c.courierName)
    ).toList();
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        backgroundColor: Colors.white,
        
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Padding(
          padding: const EdgeInsets.only(left: 8),
          child: const Text(
            'Filter',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Stack(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Column(
              children: [
                const SizedBox(height: 24),
                
                GestureDetector(
                  onTap: () async {
                    final result = await _showSingleSelectDialog(
                      context: context,
                      title: 'Select Courier',
                      options: courierLabels,
                      selectedValue: selectedCourierLabel,
                    );
                    if (result != null) {
                      final idx = courierLabels.indexOf(result);
                      if (idx != -1) {
                        setState(() {
                          selectedCourier = courierAccounts[idx];
                        });
                      }
                    }
                  },
                  child: Container(
                    margin: const EdgeInsets.only(bottom: 16),
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF5F5F7),
                      borderRadius: BorderRadius.circular(14),
                      border: Border.all(color: Colors.transparent, width: 1),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.grey.withOpacity(0.08),
                          blurRadius: 8,
                          offset: Offset(0, 2),
                        ),
                      ],
                    ),
                                            child: Row(
                          children: [
                            Expanded(
                              child: Text(
                                selectedCourierLabel ?? 'Select Courier',
                                style: TextStyle(fontSize: 15, color: selectedCourierLabel == null ? Colors.black : Colors.black),
                                overflow: TextOverflow.ellipsis,
                                maxLines: 1,
                              ),
                            ),
                            if (_isLoadingCouriers)
                              Padding(
                                padding: const EdgeInsets.only(right: 8),
                                child: SizedBox(
                                  width: 16,
                                  height: 16,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    color: const Color(0xFF007AFF),
                                  ),
                                ),
                              ),
                            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                          ],
                        ),
                  ),
                ),
                const SizedBox(height: 6),
                SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                    onPressed: () {
                      if (selectedCourier == null) {
                        final rootContext = Navigator.of(context, rootNavigator: true).context;
                        ScaffoldMessenger.of(rootContext).showSnackBar(
                          SnackBar(
                            content: const Text('Please select at least one filter'),
                            backgroundColor: Colors.red,
                            behavior: SnackBarBehavior.floating,
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                            margin: const EdgeInsets.all(16),
                            duration: const Duration(seconds: 3),
                          ),
                        );
                        return;
                      }
                      widget.onApply({
                        'customer_courier_id': selectedCourier!.id,
                        'courier_id': selectedCourier!.courierId,
                        'courier_name': selectedCourier!.courierName,
                      });
                      Navigator.of(context).pop();
                    },
                    child: const Text('Apply Filters', style: TextStyle(fontSize: 18, color: Colors.white)),
                  ),
                ),
                const SizedBox(height: 16),
                GestureDetector(
                  onTap: () {
                    setState(() {
                      selectedCourier = null;
                    });
                    widget.onReset();
                  },
                  child: const Text('Reset Filter', style: TextStyle(color: Colors.red, fontWeight: FontWeight.w400, fontSize: 16)),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  
  Future<String?> _showSingleSelectDialog({
    required BuildContext context,
    required String title,
    required List<String> options,
    required String? selectedValue,
  }) async {
    return await showModalBottomSheet<String>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => _SingleSelectDialog(
        items: options,
        initialValue: selectedValue,
        title: title,
      ),
    );
  }

  Widget _customSingleSelectField({
    required BuildContext context,
    required String title,
    required List<CourierAccount> items,
    required CourierAccount? selectedItem,
    required void Function(CourierAccount?) onConfirm,
  }) {
    return GestureDetector(
      onTap: () async {
        CourierAccount? result = await showDialog<CourierAccount>(
          context: context,
          builder: (ctx) => Dialog(
            backgroundColor: Colors.white,
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            insetPadding: const EdgeInsets.symmetric(horizontal: 8, vertical: 24),
            child: LayoutBuilder(
              builder: (context, constraints) {
                final maxHeight = MediaQuery.of(context).size.height * 0.5;
                return ConstrainedBox(
                  constraints: BoxConstraints(
                    maxHeight: maxHeight,
                    minWidth: 300,
                    maxWidth: 400,
                  ),
                  child: SingleChildScrollView(
                    child: Padding(
                      padding: const EdgeInsets.all(20),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                          const SizedBox(height: 12),
                          SingleSelectList(
                            items: items,
                            selectedItem: selectedItem,
                            onSelected: (item) {
                              Navigator.of(ctx).pop(item);
                            },
                          ),
                        ],
                      ),
                    ),
                  ),
                );
              },
            ),
          ),
        );
        if (result != null) {
          onConfirm(result);
        }
      },
      child: Container(
        margin: const EdgeInsets.only(bottom: 4),
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.grey[300]!, width: 1),
          boxShadow: [
            BoxShadow(
              color: Colors.grey.withOpacity(0.03),
              blurRadius: 2,
              offset: Offset(0, 1),
            ),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              child: Text(
                selectedItem == null ? title : selectedItem.courierName,
                style: TextStyle(fontSize: 15, color: selectedItem == null ? Colors.grey : Colors.black),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
          ],
        ),
      ),
    );
  }
} 


Widget _defListRow(String label, String value) {
  return Row(
    crossAxisAlignment: CrossAxisAlignment.center,
    children: [
      SizedBox(
        width: 100,
        child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
      ),
      const SizedBox(width: 36),
      Expanded(
        child: Text(
          value.isEmpty ? '-' : value,
          style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
          textAlign: TextAlign.left,
        ),
      ),
    ],
  );
} 

  Future<Map<String, dynamic>> _deleteLoadSheetByApi(int orderId, String consignmentNo) async {
    try {
      
      final authService = Get.find<AuthService>();
      final acno = authService.getCurrentAcno();
      
      final requestBody = {
        'order_ids': [orderId.toString()],
        'consignment_nos': [consignmentNo],
        'acno': acno ?? '',
      };

      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetDeleteEndpoint),
        data: requestBody,
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
     
      
      if (response.statusCode == 200 && response.data['status'] == 1) {
        return {'success': true, 'message':'Load sheet deleted successfully!'};
      } else {
        return {'success': false, 'message':'Failed to delete load sheet'};
      }
    } catch (e) {
      print('Delete API error: $e');
      return {'success': false, 'message': 'Failed to delete load sheet'};
    }
  }

  Future<List<Map<String, dynamic>>?> _getLoadSheetDetails(String sheetNo) async {
    try {
      final intSheetNo = int.tryParse(sheetNo) ?? sheetNo;
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetSingleEndpoint),
        data: {'sheet_no': intSheetNo},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
     
      if (response.statusCode == 200 && response.data['status'] == 1 && response.data['payload'] is List) {
        final List<dynamic> payload = response.data['payload'];
        return payload.map((item) => Map<String, dynamic>.from(item)).toList();
      }
      return null;
    } catch (e) {
      print('Loadsheet details API error: $e');
      return null;
    }
  }

  void _showLoadSheetDetailsBottomSheet(BuildContext context, LoadSheetModel sheet, {
    required VoidCallback onEdit,
    required VoidCallback onDelete,
  }) async {
    try {
      final detailsList = await _getLoadSheetDetails(sheet.sheetNo);

      if (detailsList == null || detailsList.isEmpty) {
        customSnackBar('Error', 'Failed to load loadsheet details');
        return;
      }

      
      final details = detailsList.first;

      showModalBottomSheet(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (context) {
          return Container(
            width: double.infinity,
            padding: EdgeInsets.only(
              left: 0,
              right: 0,
              bottom: MediaQuery.of(context).viewInsets.bottom,
            ),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
            ),
            child: AnimationLimiter(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 500),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Row(
                              children: [
                                Text(
                                  'Loadsheet Details',
                                  style: TextStyle(
                                    fontWeight: FontWeight.w600,
                                    fontSize: 18,
                                    fontFamily: 'SF Pro Display',
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Container(
                                  constraints: const BoxConstraints(minWidth: 70, maxWidth: 100),
                                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                  decoration: BoxDecoration(
                                    color: details['status'] == '1'
                                        ? const Color(0xFF28C76F).withOpacity(0.1)
                                        : const Color(0xFFFF0000).withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  alignment: Alignment.center,
                                  child: Text(
                                    details['status'] == '1' ? 'Active' : 'Inactive',
                                    style: GoogleFonts.inter(
                                      color: details['status'] == '1'
                                          ? const Color(0xFF28C76F)
                                          : const Color(0xFFFF0000),
                                      fontWeight: FontWeight.w500,
                                      fontSize: 15
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                            IconButton(
                              icon: const Icon(Icons.close_rounded),
                              onPressed: () => Navigator.of(context).pop(),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        _loadSheetDetailRow('ID', details['id']?.toString() ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Account No', details['acno'] ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Order ID', details['order_id']?.toString() ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Consignment No', details['consignment_no'] ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Courier ID', details['courier_id']?.toString() ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Customer Courier ID', details['customer_courier_id']?.toString() ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Status', details['status'] ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Is Deleted', details['is_deleted'] ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Created At', details['created_at'] ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Updated At', details['updated_at'] ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Order Last Status ID', details['order_last_status_id']?.toString() ?? ''),
                        SizedBox(height: 10),
                        _loadSheetDetailRow('Order Status', details['order_status'] ?? ''),
                        SizedBox(height: 10),
                        Row(
                          crossAxisAlignment: CrossAxisAlignment.center,
                          children: [
                            SizedBox(
                              width: 100,
                              child: Text(
                                'Actions',
                                style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14),
                              ),
                            ),
                            const SizedBox(width: 36),
                            Expanded(
                              child: GestureDetector(
                                onTap: () {
                                  Navigator.of(context).pop();
                                  onDelete();
                                },
                                child: Row(
                                  children: [
                                    SvgPicture.asset(
                                      'assets/Delete.svg',
                                      width: 18,
                                      height: 18,
                                      color: const Color(0xFF007AFF),
                                    ),
                                    const SizedBox(width: 4),
                                    Text(
                                      'Delete',
                                      style: GoogleFonts.inter(
                                        fontWeight: FontWeight.w300,
                                        fontSize: 13,
                                        color: const Color(0xFF007AFF),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      );
    } catch (e) {
      customSnackBar('Error', 'Failed to load loadsheet details: ${e.toString()}');
    }
  }

  Widget _loadSheetDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(
            label,
            style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14),
          ),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  } 

class _SingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _SingleSelectDialog({Key? key, required this.items, required this.initialValue, required this.title}) : super(key: key);

  @override
  State<_SingleSelectDialog> createState() => _SingleSelectDialogState();
}

class _SingleSelectDialogState extends State<_SingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: AnimatedListViewSeparated(
                            itemCount: filteredItems.length,
                            separatorBuilder: (_, __) => Container(
                              height: 1,
                              color: Colors.black.withOpacity(0.08),
                              margin: const EdgeInsets.symmetric(horizontal: 8),
                            ),
                            itemBuilder: (context, i) {
                              final item = filteredItems[i];
                              final isSelected = selected == item;
                              return ListTile(
                                title: Text(item),
                                trailing: isSelected
                                    ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                    : null,
                                onTap: () {
                                  setState(() {
                                    selected = item;
                                  });
                                  Navigator.of(context).pop(item);
                                },
                                selected: isSelected,
                                selectedTileColor: const Color(0xFFE6F0FF),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(8),
                                ),
                              );
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import '../widgets/courier_logo_widget.dart';
import '../utils/custom_snackbar.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'dashboard_screen.dart' as dash;
import 'menu.dart' as menu;
import 'report.dart' as report;
import 'order_list_screen.dart';
import 'create_order.dart';
import 'package:dio/dio.dart';
import '../config/api_config.dart';
import '../services/auth_service.dart';
import 'load_sheet_screen.dart';

class LoadsheetDetailsScreen extends StatefulWidget {
  final List<Map<String, dynamic>> loadsheetDataList;
  final VoidCallback? onRefresh;
  
  const LoadsheetDetailsScreen({
    Key? key,
    required this.loadsheetDataList,
    this.onRefresh,
  }) : super(key: key);

  @override
  State<LoadsheetDetailsScreen> createState() => _LoadsheetDetailsScreenState();
}

class _LoadsheetDetailsScreenState extends State<LoadsheetDetailsScreen> {
  bool isLoading = false;
  bool selectAll = false;
  final Set<String> selectedLoadsheets = {};

  Future<void> _deleteLoadsheet(Map<String, dynamic> details) async {
    try {
      setState(() {
        isLoading = true;
      });

      final orderId = int.tryParse(details['order_id']?.toString() ?? '');
      final consignmentNo = details['consignment_no']?.toString() ?? '';
      
      if (consignmentNo.isEmpty) {
        customSnackBar('Error', 'Consignment number not available for deletion');
        return;
      }

      if (orderId == null) {
        customSnackBar('Error', 'Invalid order ID for deletion');
        return;
      }

      print('Calling delete API with orderId: $orderId, consignmentNo: $consignmentNo');

      
      final authService = Get.find<AuthService>();
      final acno = authService.getCurrentAcno();
      
      
      final requestBody = {
        'order_ids': [orderId.toString()],
        'consignment_nos': [consignmentNo],
        'acno': acno ?? '',
      };
      
   
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetDeleteEndpoint),
        data: requestBody,
        options: Options(headers: {'Content-Type': 'application/json'}),
      );

      

      if (response.statusCode == 200 && response.data['status'] == 1) {
        customSnackBar('Success', response.data['message'] ?? 'Loadsheet deleted successfully!');
        
        setState(() {
          widget.loadsheetDataList.remove(details);
        });
        
        // Call refresh callback if provided
        if (widget.onRefresh != null) {
          widget.onRefresh!();
        }
        
        Navigator.of(context).pop();
      } else {
        customSnackBar('Error', 'Failed to delete loadsheet');
      }
    } catch (e) {
      print('Exception in delete loadsheet: $e');
      customSnackBar('Error', 'Failed to delete loadsheet');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  Future<void> _deleteSelectedLoadsheets() async {
    if (selectedLoadsheets.isEmpty) return;
    
    try {
      setState(() {
        isLoading = true;
      });

      final selectedLoadsheetList = widget.loadsheetDataList
          .where((details) => selectedLoadsheets.contains(details['order_id']?.toString()))
          .toList();

      if (selectedLoadsheetList.isEmpty) {
        customSnackBar('Error', 'No loadsheets selected for deletion');
        return;
      }

      final orderIds = selectedLoadsheetList
          .map((details) => int.tryParse(details['order_id']?.toString() ?? ''))
          .whereType<int>()
          .toList();

      final consignmentNos = selectedLoadsheetList
          .map((details) => details['consignment_no']?.toString() ?? '')
          .where((cn) => cn.isNotEmpty)
          .toList();

      if (orderIds.isEmpty || consignmentNos.isEmpty) {
        customSnackBar('Error', 'Invalid data for deletion');
        return;
      }

      final authService = Get.find<AuthService>();
      final acno = authService.getCurrentAcno();

      final requestBody = {
        'order_ids': orderIds.map((id) => id.toString()).toList(),
        'consignment_nos': consignmentNos,
        'acno': acno ?? '',
      };

     

      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.loadSheetDeleteEndpoint),
        data: requestBody,
        options: Options(headers: {'Content-Type': 'application/json'}),
      );


      if (response.statusCode == 200 && response.data['status'] == 1) {
        customSnackBar('Success', 'Selected loadsheets deleted successfully!');
        
        setState(() {
          widget.loadsheetDataList.removeWhere(
            (details) => selectedLoadsheets.contains(details['order_id']?.toString())
          );
          selectedLoadsheets.clear();
          selectAll = false;
        });
        
        // Call refresh callback if provided
        if (widget.onRefresh != null) {
          widget.onRefresh!();
        }
        
        Navigator.of(context).pop(true); // Return true to indicate successful deletion
      } else {
        customSnackBar('Error', 'Failed to delete selected loadsheets');
      }
    } catch (e) {
      print('Exception in bulk delete loadsheet: $e');
      customSnackBar('Error', 'Failed to delete selected loadsheets');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  void _showDeleteLoadsheetDialog(BuildContext context, VoidCallback onConfirm) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFEFF6FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(24),
                  child: SvgPicture.asset(
                    'assets/Delete.svg',
                    width: 56,
                    height: 56,
                    color: const Color(0xFF007AFF),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w700,
                    fontFamily: 'SF Pro Display',
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                const Text(
                  'You want to delete this loadsheet',
                  style: TextStyle(
                    fontSize: 15,
                    fontWeight: FontWeight.w400,
                    fontFamily: 'SF Pro Display',
                    color: Color(0xFF6B7280),
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Get.back(result: false),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF3F4F6),
                          foregroundColor: const Color(0xFF111827),
                          elevation: 0,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          Get.back(result: true);
                          onConfirm();
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          foregroundColor: Colors.white,
                          elevation: 0,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

    @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => const CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
        child: SvgPicture.asset(
          'assets/Create Order.svg',
          width: 28,
          height: 28,
          color: Colors.white,
        ),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      appBar: AppBar(
        backgroundColor: Colors.white,
        shadowColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Padding(
          padding: const EdgeInsets.only(left: 8),
          child: Text(
            'Loadsheet Details',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
        ),
        centerTitle: false,
                 bottom: PreferredSize(
           preferredSize: Size.fromHeight(1),
           child: Container(
             height: 1,
             color: Colors.grey[300],
           ),
         ),
       ),
               body: Stack(
          children: [
            SingleChildScrollView(
              padding: const EdgeInsets.only(
                left: 16,
                right: 16,
                top: 16,
                bottom: 80, // Add bottom padding to prevent FAB overlap
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  
                  if (widget.loadsheetDataList.isNotEmpty) ...[
                    Padding(
                      padding: const EdgeInsets.only(bottom: 16),
                      child: Text(
                        'Total Items: ${widget.loadsheetDataList.length}',
                        style: GoogleFonts.inter(
                          fontWeight: FontWeight.w600,
                          fontSize: 18,
                          color: Colors.black,
                        ),
                      ),
                    ),
                    
                    // Select All and Bulk Delete Section
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 8),
                      child: Row(
                        children: [
                          Checkbox(
                            value: selectAll,
                            onChanged: (val) {
                              setState(() {
                                selectAll = val ?? false;
                                if (val == true) {
                                  selectedLoadsheets.clear();
                                  for (int i = 0; i < widget.loadsheetDataList.length; i++) {
                                    selectedLoadsheets.add(widget.loadsheetDataList[i]['order_id']?.toString() ?? '');
                                  }
                                } else {
                                  selectedLoadsheets.clear();
                                }
                              });
                            },
                            activeColor: const Color(0xFF007AFF),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            visualDensity: VisualDensity.compact,
                          ),
                          const Text('Select All', style: TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w400, fontSize: 15)),
                          const Spacer(),
                          if (selectedLoadsheets.isNotEmpty) ...[
                            GestureDetector(
                              onTap: () {
                                _showDeleteLoadsheetDialog(context, _deleteSelectedLoadsheets);
                              },
                              child: Container(
                                constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                decoration: BoxDecoration(
                                  color: Colors.red.withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(16),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  'Delete',
                                  style: GoogleFonts.inter(
                                    color: Colors.red,
                                    fontWeight: FontWeight.w500,
                                    fontSize: 15
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                  ],
                  
                  ...widget.loadsheetDataList.asMap().entries.map((entry) {
                    final index = entry.key;
                    final details = entry.value;
                    return _buildLoadsheetCard(details, index + 1);
                  }).toList(),
                ],
              ),
            ),
            if (isLoading)
              Container(
                color: Colors.black.withOpacity(0.3),
                child: const Center(
                  child: CircularProgressIndicator(color: Color(0xFF007AFF)),
                ),
              ),
          ],
        ),
      bottomNavigationBar: AppBottomBar(
        selectedIndex: 1,
        onHomeTap: () {
          Get.offAll(() => dash.DashboardScreen());
        },
        onMenuTap: () {
          Get.offAll(() => menu.MenuScreen());
        },
        onReportsTap: () {
          Get.offAll(() => report.ReportsScreen());
        },
        onOrderListTap: () {
          Get.offAll(() => OrderListScreen());
        },
      ),
    );
    }

  Widget _buildLoadsheetCard(Map<String, dynamic> details, int serialNumber) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.only(top: 4, bottom: 4),
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
      decoration: BoxDecoration(
        color: const Color(0xFFF5F5F7),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Transform.translate(
                offset: const Offset(-8, 0),
                child: Checkbox(
                  value: selectedLoadsheets.contains(details['order_id']?.toString()),
                  onChanged: (val) {
                    setState(() {
                      if (val == true) {
                        selectedLoadsheets.add(details['order_id']?.toString() ?? '');
                      } else {
                        selectedLoadsheets.remove(details['order_id']?.toString() ?? '');
                      }
                      
                      // Update select all checkbox
                      selectAll = selectedLoadsheets.length == widget.loadsheetDataList.length;
                    });
                  },
                  activeColor: const Color(0xFF007AFF),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                  materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                  visualDensity: VisualDensity.compact,
                ),
              ),
              const SizedBox(width: 0),
              Expanded(
                child: Padding(
                  padding: const EdgeInsets.only(top: 8),
                  child: Text(
                    'S.No: $serialNumber',
                    style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                  ),
                ),
              ),
              Column(
                children: [
                  SizedBox(height: 6),
                  Container(
                    constraints: const BoxConstraints(minWidth: 80, maxWidth: 120),
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                    decoration: BoxDecoration(
                      color: () {
                        final orderStatus = details['order_status']?.toString().toLowerCase();
                        if (orderStatus == 'pickup ready') return Color(0xFF43A047).withOpacity(0.1);
                        if (orderStatus == 'delivered') return Color(0xFF007AFF).withOpacity(0.1);
                        if (orderStatus == 'in transit') return Color(0xFFFF9800).withOpacity(0.1);
                        if (orderStatus == 'pending') return Color(0xFF9E9E9E).withOpacity(0.1);
                        return Colors.grey.withOpacity(0.1);
                      }(),
                      borderRadius: BorderRadius.circular(16),
                    ),
                    alignment: Alignment.center,
                    child: Text(
                      details['order_status']?.toString() ?? 'Unknown',
                      style: GoogleFonts.inter(
                        color: () {
                          final orderStatus = details['order_status']?.toString().toLowerCase();
                          if (orderStatus == 'pickup ready') return Color(0xFF43A047);
                          if (orderStatus == 'delivered') return Color(0xFF007AFF);
                          if (orderStatus == 'in transit') return Color(0xFFFF9800);
                          if (orderStatus == 'pending') return Color(0xFF9E9E9E);
                          return Colors.grey;
                        }(),
                        fontWeight: FontWeight.w500, 
                        fontSize: 12
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ],
          ),
          const SizedBox(height: 4),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    SizedBox(
                      width: 100,
                      child: Text('Order ID', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                    ),
                    const SizedBox(width: 36),
                    Expanded(
                      child: Text((details['order_id'] ?? '').toString().isEmpty ? '-' : (details['order_id'] ?? '').toString(), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    SizedBox(
                      width: 100,
                      child: Text('CN', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                    ),
                    const SizedBox(width: 36),
                    Expanded(
                      child: Text((details['consignment_no'] ?? '').isEmpty ? '-' : (details['consignment_no'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    SizedBox(
                      width: 100,
                      child: Text('Account No', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                    ),
                    const SizedBox(width: 36),
                    Expanded(
                      child: Text((details['acno'] ?? '').isEmpty ? '-' : (details['acno'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 4),
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                   
                    const SizedBox(width: 36),
                                                       GestureDetector(
                                     onTap: () {
                                       
                                       _showDeleteLoadsheetDialog(context, () => _deleteLoadsheet(details));
                                     },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          
                         
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}  
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'dashboard_screen.dart';
import '../services/auth_service.dart';
import 'sign_in_screen.dart';
import 'report.dart' as report;
import 'create_order.dart' as create_order;
import 'order_list_screen.dart';
import 'load_sheet_screen.dart';
import 'profile_screen.dart';
import 'package:dio/dio.dart';
import 'rules_screen.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../controllers/sign_in_controller.dart';
import '../controllers/dashboard_controller.dart';
import '../controllers/courier_performance_controller.dart';
import '../controllers/help_video_controller.dart';
import 'create_loadsheet_screen.dart';
import '../config/api_config.dart';
import 'package:shared_preferences/shared_preferences.dart';

class MenuScreen extends StatefulWidget {
  const MenuScreen({Key? key}) : super(key: key);

  @override
  State<MenuScreen> createState() => _MenuScreenState();
}

class _MenuScreenState extends State<MenuScreen> {
  bool _isDialogOpen = false;
  Map<String, dynamic>? profileData;
  bool isLoading = false; 
  String? error;
  final AuthService _authService = Get.find<AuthService>();

  
  static Map<String, dynamic>? _cachedProfileData;
  static String? _cachedUserId;

  @override
  void initState() {
    super.initState();
    _loadUserDataAndFetchProfile();
  }

  Future<void> _loadUserDataAndFetchProfile() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    final userId = _authService.currentUser.value?.userId;
    if (_cachedProfileData != null && _cachedUserId == userId) {
      setState(() {
        profileData = _cachedProfileData;
        isLoading = false;
        error = null;
      });
      return;
    }
    
    _fetchProfileInBackground();
  }

  Future<void> _fetchProfileInBackground() async {
    try {
      
      final userData = _authService.getCurrentUserData();
      if (userData == null) {
        setState(() {
          error = 'User not logged in.';
        });
        return;
      }

      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.profileEndpoint),
        data: userData,
      );
      if (response.data['status'] == 1 && response.data['payload'] is List && response.data['payload'].isNotEmpty) {
        setState(() {
          profileData = response.data['payload'][0];
          error = null;
        });
        
        _cachedProfileData = profileData;
        _cachedUserId = _authService.currentUser.value?.userId;
      } else {
        setState(() {
          error = 'No profile data found.';
        });
      }
    } catch (e) {
      setState(() {
        error = 'Failed to load profile.';
      });
    }
  }

  Future<void> fetchProfile() async {
    
    _fetchProfileInBackground();
  }

  Future<void> showSuccessDialog(BuildContext context, {String title = 'Success!', String message = 'Action completed successfully.'}) {
    return showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: Color(0xFFF5F5F7),
                    shape: BoxShape.circle,
                  ),
                  padding: EdgeInsets.all(32),
                  child: Icon(Icons.check_circle_rounded, color: Color(0xFF007AFF), size: 64),
                ),
                SizedBox(height: 24),
                Text(
                  title,
                  style: GoogleFonts.inter(
                    fontWeight: FontWeight.w700,
                    fontSize: 22,
                    color: Colors.black,
                  ),
                ),
                SizedBox(height: 8),
                Text(
                  message,
                  style: GoogleFonts.inter(
                    fontWeight: FontWeight.w400,
                    fontSize: 15,
                    color: Color(0xFF8E8E93),
                  ),
                ),
                SizedBox(height: 28),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Color(0xFF007AFF),
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                      padding: EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: Text(
                      'OK',
                      style: GoogleFonts.inter(
                        fontWeight: FontWeight.w500,
                        fontSize: 15,
                        color: Colors.white,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: [SystemUiOverlay.top, SystemUiOverlay.bottom]);

    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.dark,
        statusBarBrightness: Brightness.light,
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.dark,
        systemNavigationBarDividerColor: Colors.transparent,
      ),
      child: Scaffold(
        backgroundColor: Colors.white,
        extendBody: true,
        body: SafeArea(
          bottom: false,
          child: AnimationLimiter(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                
                AnimationConfiguration.staggeredList(
                  position: 0,
                  duration: const Duration(milliseconds: 600),
                  child: SlideAnimation(
                    verticalOffset: 50.0,
                    child: FadeInAnimation(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),
                        child: Container(
                          width: double.infinity,
                          padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 16),
                          decoration: BoxDecoration(
                            color: const Color(0xFFF7F8FA),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Row(
                            children: [
                              
                              Container(
                                width: 54,
                                height: 54,
                                decoration: BoxDecoration(
                                  color: const Color(0xFFE5E5E5),
                                  shape: BoxShape.circle,
                                ),
                                child: Icon(Icons.person_rounded, size: 38, color: Colors.grey[400]),
                              ),
                              const SizedBox(width: 16),
                              
                              Expanded(
                                child: Column(
                                        crossAxisAlignment: CrossAxisAlignment.start,
                                        children: [
                                          Text(
                                            profileData?['first_name'] != null && profileData?['last_name'] != null
                                              ? '${profileData?['first_name']} ${profileData?['last_name']}'
                                              : error != null
                                                ? 'User'
                                                : 'Loading...',
                                            style: GoogleFonts.inter(
                                              fontWeight: FontWeight.w700,
                                              fontSize: 18,
                                              color: Colors.black,
                                            ),
                                          ),
                                          const SizedBox(height: 4),
                                          Text(
                                            profileData?['email'] ?? (error != null ? 'user@example.com' : 'Loading...'),
                                            style: GoogleFonts.inter(
                                              fontWeight: FontWeight.w400,
                                              fontSize: 14,
                                              color: Color(0xFF8E8E93),
                                            ),
                                          ),
                                          const SizedBox(height: 8),
                                          SizedBox(
                                            height: 28,
                                            child: OutlinedButton(
                                              onPressed: () {
                                                Navigator.of(context).push(
                                                  MaterialPageRoute(builder: (_) => const ProfileScreen()),
                                                );
                                              },
                                              style: OutlinedButton.styleFrom(
                                                side: const BorderSide(color: Color(0xFF007AFF), width: 1),
                                                shape: RoundedRectangleBorder(
                                                  borderRadius: BorderRadius.circular(6),
                                                ),
                                                padding: const EdgeInsets.symmetric(horizontal: 16),
                                                minimumSize: const Size(0, 28),
                                                tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                                backgroundColor: Colors.transparent,
                                                elevation: 0,
                                              ),
                                              child: Text(
                                                'Profile',
                                                style: GoogleFonts.inter(
                                                  fontWeight: FontWeight.w500,
                                                  fontSize: 13,
                                                  color: Color(0xFF007AFF),
                                                ),
                                              ),
                                            ),
                                          ),
                                        ],
                                      ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                
                AnimationConfiguration.staggeredList(
                  position: 1,
                  duration: const Duration(milliseconds: 600),
                  child: SlideAnimation(
                    verticalOffset: 30.0,
                    child: FadeInAnimation(
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Text(
                          'Menu',
                          style: GoogleFonts.inter(
                            fontWeight: FontWeight.w700,
                            fontSize: 22,
                            color: Colors.black,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 10),
                
                Expanded(
                  child: AnimationLimiter(
                    child: ListView(
                      padding: const EdgeInsets.only(top: 0),
                      children: AnimationConfiguration.toStaggeredList(
                        duration: const Duration(milliseconds: 600),
                        childAnimationBuilder: (widget) => SlideAnimation(
                          horizontalOffset: 50.0,
                          child: FadeInAnimation(
                            child: widget,
                          ),
                        ),
                        children: [
                          _MenuItem(
                            svgAsset: 'assets/Courier Companies.svg',
                            label: 'Courier Companies',
                            onTap: () {
                              Get.toNamed('/courier-companies');
                            },
                          ),
                          _MenuItem(
                            svgAsset: 'assets/Notifications.svg',
                            label: 'Notifications',
                            onTap: () {
                              Get.toNamed('/notifications');
                            },
                          ),
                          _MenuItem(
                            svgAsset: 'assets/Loadsheet.svg',
                            label: 'Load Sheet',
                            onTap: () {
                              Navigator.of(context).push(
                                MaterialPageRoute(builder: (_) => const LoadSheetScreen()),
                              );
                            },
                          ),
                          _MenuItem(
                            svgAsset: 'assets/Rules.svg',
                            label: 'Rules',
                            onTap: () {
                              Navigator.of(context).push(
                                MaterialPageRoute(builder: (_) => const RulesScreen()),
                              );
                            },
                          ),
                          _MenuItem(
                            svgAsset: 'assets/Help Videos.svg',
                            label: 'Help',
                            onTap: () {
                              Get.toNamed('/help-videos');
                            },
                          ),
                          _MenuItem(
                            svgAsset: 'assets/Sign Out.svg',
                            label: 'Sign Out',
                            onTap: () => showLogoutBottomSheet(Get.context!),
                            iconColor: const Color(0xFF007AFF),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
        bottomNavigationBar: AppBottomBar(
          selectedIndex: 3,
          onHomeTap: () => Get.offAll(() => DashboardScreen()),
                            onOrderListTap: () => Get.to(() => OrderListScreen(from: 'menu')),
          onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'menu')),
          onMenuTap: () {}, 
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            Get.offAll(() => create_order.CreateOrderScreen(from: 'menu'));
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
         child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
        ),
      ),
    );
  }
}


Future<void> _clearAllAppCaches() async {
  
  _MenuScreenState._cachedProfileData = null;
  _MenuScreenState._cachedUserId = null;
  
  
  DashboardController.clearStaticCache();
  

  
  
  if (Get.isRegistered<DashboardController>()) {
    try {
      final dashboardController = Get.find<DashboardController>();
      dashboardController.clearCache();
    } catch (e) {
      
    }
  }
  
  
  try {
    final prefs = await SharedPreferences.getInstance();
    
    await prefs.remove('cached_dashboard_data');
    await prefs.remove('cached_filter_data');
    await prefs.remove('cached_order_data');
    await prefs.remove('cached_report_data');
    await prefs.remove('cached_ageing_report_data');
    await prefs.remove('cached_courier_insights_data');
    await prefs.remove('cached_cod_statement_data');
    await prefs.remove('cached_load_sheet_data');
    await prefs.remove('cached_platforms');
    await prefs.remove('cached_couriers');
    await prefs.remove('cached_cities');
    await prefs.remove('cached_statuses');
    await prefs.remove('cached_order_list_data');
    await prefs.remove('cached_order_list_params');
    await prefs.remove('cached_start_limit');
    await prefs.remove('cached_end_limit');
    await prefs.remove('cached_has_more');
    await prefs.remove('cached_profile_data');
    await prefs.remove('cached_user_id');
    await prefs.remove('dashboard_last_params');
    await prefs.remove('dashboard_cached_data');
    await prefs.remove('filter_cached_platforms');
    await prefs.remove('filter_cached_couriers');
    await prefs.remove('filter_cached_cities');
    await prefs.remove('filter_cached_statuses');
    await prefs.remove('ageing_report_last_params');
    await prefs.remove('ageing_report_cached_orders');
    await prefs.remove('courier_insights_last_params');
    await prefs.remove('courier_insights_cached_reports');
    await prefs.remove('cod_statement_last_params');
    await prefs.remove('cod_statement_cached_statements');
    await prefs.remove('load_sheet_last_params');
    await prefs.remove('load_sheet_cached_load_sheets');
    
    
  } catch (e) {
    
    print('SharedPreferences clearing error: $e');
  }
}

Future<void> showLogoutBottomSheet(BuildContext context) async {
  final state = context.findAncestorStateOfType<_MenuScreenState>();
  state?.setState(() => state._isDialogOpen = true);
  final result = await showModalBottomSheet<bool>(
    context: context,
    isScrollControlled: true,
    backgroundColor: Colors.transparent,
    builder: (context) {
      return Container(
        width: double.infinity,
        padding: EdgeInsets.only(
          left: 0,
          right: 0,
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
        ),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                decoration: BoxDecoration(
                  color: Color(0xFFF5F5F7),
                  shape: BoxShape.circle,
                ),
                padding: EdgeInsets.all(32),
                child: Icon(Icons.logout_rounded, color: Color(0xFF007AFF), size: 64),
              ),
              SizedBox(height: 24),
              Text(
                'Are you Sure?',
                style: GoogleFonts.inter(
                  fontWeight: FontWeight.w700,
                  fontSize: 22,
                  color: Colors.black,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'You want to logout',
                style: GoogleFonts.inter(
                  fontWeight: FontWeight.w400,
                  fontSize: 15,
                  color: Color(0xFF8E8E93),
                ),
              ),
              SizedBox(height: 28),
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton(
                      onPressed: () => Navigator.of(context).pop(false),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Color(0xFFF2F2F7),
                        elevation: 0,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                        padding: EdgeInsets.symmetric(vertical: 14),
                      ),
                      child: Text(
                        'No',
                        style: GoogleFonts.inter(
                          fontWeight: FontWeight.w500,
                          fontSize: 15,
                          color: Colors.black,
                        ),
                      ),
                    ),
                  ),
                  SizedBox(width: 16),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: () => Navigator.of(context).pop(true),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Color(0xFF007AFF),
                        elevation: 0,
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                        padding: EdgeInsets.symmetric(vertical: 14),
                      ),
                      child: Text(
                        'Yes',
                        style: GoogleFonts.inter(
                          fontWeight: FontWeight.w500,
                          fontSize: 15,
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      );
    },
  );
  state?.setState(() => state._isDialogOpen = false);
  if (result == true) {
    await Get.find<AuthService>().logout();
    
    
    await _clearAllAppCaches();
    
    
    if (Get.isRegistered<DashboardController>()) {
      final dashboardController = Get.find<DashboardController>();
      dashboardController.clearCache(); 
      Get.delete<DashboardController>();
    }
    if (Get.isRegistered<CourierPerformanceController>()) Get.delete<CourierPerformanceController>();
    if (Get.isRegistered<HelpVideoController>()) Get.delete<HelpVideoController>();
    if (Get.isRegistered<SignInController>()) Get.delete<SignInController>();
    
    final signInController = Get.isRegistered<SignInController>() ? Get.find<SignInController>() : null;
    signInController?.emailController.clear();
    signInController?.passwordController.clear();
    state?.setState(() => state._isDialogOpen = true);
    await state?.showSuccessDialog(context, title: 'Logged out!', message: 'You have been logged out successfully.');
    state?.setState(() => state._isDialogOpen = false);
    if (!Get.isRegistered<SignInController>()) {
      Get.lazyPut<SignInController>(() => SignInController());
    }
    if (!Get.isRegistered<DashboardController>()) {
      Get.lazyPut<DashboardController>(() => DashboardController());
    }
    Get.offAll(() => SignInScreen());
  }
}

class _MenuItem extends StatelessWidget {
  final IconData? icon;
  final String? svgAsset;
  final String label;
  final VoidCallback onTap;
  final Color? iconColor;

  const _MenuItem({
    Key? key,
    this.icon,
    this.svgAsset,
    required this.label,
    required this.onTap,
    this.iconColor,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              if (svgAsset != null)
                Container(
                  width: 22,
                  height: 22,
                  child: SvgPicture.asset(
                    svgAsset!,
                    width: 22,
                    height: 22,
                    color: iconColor ?? const Color(0xFF007AFF),
                  ),
                )
              else if (icon != null)
                Container(
                  width: 22,
                  height: 22,
                  child: Icon(
                    icon!,
                    color: iconColor ?? const Color(0xFF007AFF),
                    size: 22,
                  ),
                ),
              const SizedBox(width: 18),
              Expanded(
                child: Text(
                  label,
                  style: GoogleFonts.inter(
                    fontWeight: FontWeight.w500,
                    fontSize: 16,
                    color: Colors.black,
                  ),
                ),
              ),
              const Icon(Icons.chevron_right_rounded, color: Color(0xFF8E8E93), size: 22),
            ],
          ),
        ),
      ),
    );
  }
}

class CustomBottomNavBar extends StatelessWidget {
  final int selectedIndex;
  final VoidCallback? onHomeTap;
  final VoidCallback? onReportsTap;
  final VoidCallback? onMenuTap;
  final VoidCallback? onOrderListTap;
  final VoidCallback? onPencilTap;
  const CustomBottomNavBar({Key? key, required this.selectedIndex, this.onHomeTap, this.onReportsTap, this.onMenuTap, this.onOrderListTap, this.onPencilTap}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      top: false,
      child: BottomAppBar(
        shape: const CircularNotchedRectangle(),
        notchMargin: 8,
        elevation: 0,
        color: Colors.white,
        child: SizedBox(
          height: 64,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _NavBarItem(
                icon:Icons.home_rounded,
                label: 'Home',
                selected: selectedIndex == 0,
                onTap: onHomeTap ?? () {},
              ),
              _NavBarItem(
                icon: Icons.shopping_bag_rounded,
                label: 'Order List',
                selected: selectedIndex == 1,
                onTap: onOrderListTap ?? () {},
              ),
              const SizedBox(width: 56), 
              _NavBarItem(
                icon: Icons.tune_rounded,
                label: 'Reports',
                selected: selectedIndex == 2,
                onTap: onReportsTap ?? () {},
              ),
              _NavBarItem(
                icon: Icons.menu_rounded,
                label: 'Menu',
                selected: selectedIndex == 4,
                onTap: onMenuTap ?? () {},
                selectedColor: const Color(0xFF007AFF),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _NavBarItem extends StatelessWidget {
  final IconData icon;
  final String label;
  final bool selected;
  final VoidCallback onTap;
  final Color? selectedColor;

  const _NavBarItem({
    Key? key,
    required this.icon,
    required this.label,
    required this.selected,
    required this.onTap,
    this.selectedColor,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final color = selected
        ? (selectedColor ?? const Color(0xFF007AFF))
        : const Color(0xFF222222);
    return Expanded(
      child: InkWell(
        onTap: onTap,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const SizedBox(height: 8),
            Icon(icon, color: color, size: 26),
            const SizedBox(height: 2),
            Text(
              label,
              style: GoogleFonts.inter(
                fontWeight: selected ? FontWeight.w700 : FontWeight.w400,
                fontSize: 12,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../models/notification_model.dart';
import '../services/notification_service.dart';
import '../services/auth_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import '../utils/custom_snackbar.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'add_notification_screen.dart';
import 'create_order.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;
import 'package:flutter_svg/flutter_svg.dart';
import 'package:google_fonts/google_fonts.dart';
import '../widgets/transition.dart';

class NotificationScreen extends StatefulWidget {
  const NotificationScreen({Key? key}) : super(key: key);

  @override
  State<NotificationScreen> createState() => _NotificationScreenState();
}

class _NotificationScreenState extends State<NotificationScreen> {
  final NotificationService _notificationService = NotificationService();
  final AuthService _authService = Get.find<AuthService>();
  String? _currentAcno;
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  List<NotificationModel> _allNotifications = [];
  List<NotificationModel> _filteredNotifications = [];
  bool _loading = true;
  String? _error;

  
  static Map<String, dynamic>? _lastParams;
  static List<NotificationModel>? _cachedNotifications;

  
  static void clearAllNotificationCaches() {
    _lastParams = null;
    _cachedNotifications = null;
  }

  @override
  void initState() {
    super.initState();
    _restoreOrFetchNotifications();
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  
  void _restoreOrFetchNotifications() async {
    final user = _authService.currentUser.value;
    if (user != null) {
      final acno = user.acno;
      final params = {
        'acno': acno,
      };
      if (_lastParams != null && _cachedNotifications != null && _lastParams.toString() == params.toString()) {
        setState(() {
          _currentAcno = acno;
          _allNotifications = List<NotificationModel>.from(_cachedNotifications!);
          _filteredNotifications = List<NotificationModel>.from(_cachedNotifications!);
          _loading = false;
        });
        return;
      }
      await _loadCurrentUserAcno();
    }
  }

  Future<void> _loadCurrentUserAcno() async {
    final user = _authService.currentUser.value;
    if (user != null) {
      setState(() {
        _currentAcno = user.acno;
      });
      _fetchNotifications(user.acno);
    }
  }

  Future<void> _fetchNotifications(String acno) async {
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final notifications = await _notificationService.getNotifications(acno: acno);
      
      _lastParams = {'acno': acno};
      _cachedNotifications = List<NotificationModel>.from(notifications);
      setState(() {
        _allNotifications = notifications;
        _filteredNotifications = notifications;
        _loading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _loading = false;
      });
    }
  }

  void _onSearchChanged() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      _filteredNotifications = _allNotifications.where((notification) {
        return notification.message.toLowerCase().contains(query) ||
               notification.subject.toLowerCase().contains(query) ||
               notification.statusName.toLowerCase().contains(query) ||
               notification.courierName.toLowerCase().contains(query);
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_currentAcno == null) {
      return ConnectivityWrapper(
        showOfflineUI: true,
        child: const Scaffold(
          body: Center(child: CircularProgressIndicator(color: Color(0xFF007AFF))),
        ),
      );
    }

    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        appBar: AppBar(
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black),
            onPressed: () {
              Navigator.of(context).maybePop();
            },
          ),
          title: const Text(
            'Notifications',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          backgroundColor: Colors.white,
         
          foregroundColor: Colors.white,
          surfaceTintColor: Colors.white,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
        ),
        body: _loading
            ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
            : _error != null
                ? Center(child: Text('Error: $_error'))
                : GestureDetector(
                    behavior: HitTestBehavior.translucent,
                    onTap: () {
                      FocusScope.of(context).unfocus();
                    },
                    child: Column(
                      children: [
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text('Total Notifications: ${_filteredNotifications.length.toString().padLeft(2, '0')}',
                                  style: const TextStyle(fontWeight: FontWeight.w500)),
                              GestureDetector(
                                onTap: () async {
                                  final result = await Get.toNamed('/add-notification');
                                  if (result == true) {
                                    await _manualRefresh();
                                    setState(() {});
                                  }
                                },
                                child: const Text(
                                  'Add Notification',
                                  style: TextStyle(
                                    color: Color(0xFF007AFF),
                                    fontWeight: FontWeight.w600,
                                    decoration: TextDecoration.none,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                        Padding(
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                          child: TextField(
                            controller: _searchController,
                            focusNode: _searchFocusNode,
                            decoration: InputDecoration(
                              hintText: 'Search',
                              suffixIcon: Icon(Icons.search_rounded),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                              ),
                              filled: true,
                              fillColor: const Color(0xFFF5F5F7),
                              contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                              focusedBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                              ),
                              enabledBorder: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                            ),
                          ),
                        ),
                        Expanded(
                          child: _filteredNotifications.isEmpty
                              ? const Center(child: Text('No notifications found.'))
                              : RefreshIndicator(
                                  onRefresh: _manualRefresh,
                                  child: AnimatedListView(
                                  padding: const EdgeInsets.only(left: 12, right: 12, top: 4, bottom: 80),
                                  itemCount: _filteredNotifications.length,
                                  itemBuilder: (context, index) {
                                    final notification = _filteredNotifications[index];
                                    return Column(
                                      children: [
                                        Container(
                                      decoration: BoxDecoration(
                                        color: const Color(0xFFF5F5F7),
                                        borderRadius: BorderRadius.circular(12),
                                      ),
                                      margin: const EdgeInsets.only(top: 4, bottom: 4),
                                      child: Padding(
                                        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Padding(
                                                    padding: const EdgeInsets.only(top: 8),
                                                    child: Text(
                                                      'ID: ${notification.id}',
                                                      style: GoogleFonts.inter(fontWeight: FontWeight.w400),
                                                    ),
                                                  ),
                                                ),
                                                Column(
                                                  children: [
                                                    SizedBox(height: 6),
                                                    Container(
                                                      constraints: const BoxConstraints(minWidth: 50, maxWidth: 70),
                                                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
                                                      decoration: BoxDecoration(
                                                        color: notification.status == 'Y'
                                                            ? const Color(0xFF28C76F).withOpacity(0.1)
                                                            : const Color(0xFFFF0000).withOpacity(0.1),
                                                        borderRadius: BorderRadius.circular(12),
                                                      ),
                                                      alignment: Alignment.center,
                                                      child: Text(
                                                        notification.status == 'Y' ? 'Active' : 'Inactive',
                                                        style: GoogleFonts.inter(
                                                          color: notification.status == 'Y'
                                                              ? const Color(0xFF28C76F)
                                                              : const Color(0xFFDC3545),
                                                          fontWeight: FontWeight.w500,
                                                          fontSize: 12
                                                        ),
                                                        overflow: TextOverflow.ellipsis,
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 8),
                                            _infoRow('Order Status', notification.statusName.isNotEmpty ? notification.statusName : 'N/A'),
                                            _infoRow('Message', notification.message.isNotEmpty ? notification.message : 'No message available'),
                                            _infoRow('Subject', notification.subject.isNotEmpty ? notification.subject : 'No subject'),
                                            const SizedBox(height: 8),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.center,
                                              children: [
                                                SizedBox(
                                                  width: 100,
                                                  child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                ),
                                                const SizedBox(width: 36),
                                                Expanded(
                                                  child: Row(
                                                    children: [
                                                      InkWell(
                                                        onTap: () async {
                                                          final result = await Get.toNamed('/edit-notification', arguments: notification);
                                                          if (result == true) {
                                                            await _manualRefresh();
                                                            setState(() {});
                                                          }
                                                        },
                                                        borderRadius: BorderRadius.circular(8),
                                                        child: Row(
                                                          children: [
                                                            SvgPicture.asset(
                                                              'assets/Edit.svg',
                                                              width: 20,
                                                              height: 20,
                                                              color: const Color(0xFF007AFF),
                                                            ),
                                                            const SizedBox(width: 4),
                                                            Text('Edit', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                          ],
                                                        ),
                                                      ),
                                                      const SizedBox(width: 24),
                                                      GestureDetector(
                                                        onTap: () {
                                                          _showDeleteConfirmation(context, () {
                                                            _deleteNotification(notification);
                                                          });
                                                        },
                                                        child: Row(
                                                          children: [
                                                            SvgPicture.asset(
                                                              'assets/Delete.svg',
                                                              width: 18,
                                                              height: 18,
                                                              color: const Color(0xFF007AFF),
                                                            ),
                                                            const SizedBox(width: 4),
                                                            Text('Delete', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                          ],
                                                        ),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 8), 
                                          ],
                                        ),
                                      ),
                                        ),
                                        const SizedBox(height: 8),
                                      ],
                                    );
                                  },
                                ),
                              ),
                        ),
                      ],
                    ),
                  ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            Get.to(() => CreateOrderScreen());
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
          child: SvgPicture.asset(
    'assets/Create Order.svg',
    width: 28,
    height: 28,
    color: Colors.white,
  ),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        resizeToAvoidBottomInset: false,
                bottomNavigationBar: AppBottomBar(
                  selectedIndex: 3,
                  onOrderListTap: () => Get.to(() => OrderListScreen(from: 'notifications')),
                  onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'notifications')),
                ),
      ),
    );
  }

  Future<void> _deleteNotification(NotificationModel notification) async {
    try {
      final result = await _notificationService.deleteNotification(
        int.tryParse(notification.id) ?? 0,
        _currentAcno ?? '',
      );

      final bool success = result['success'] ?? false;
      final String message = result['message'] ?? 'Unknown response';

      if (success) {
        customSnackBar('Success', message);
        
        
        await _manualRefresh();
      } else {
        customSnackBar('Error', message);
      }
    } catch (e) {
      customSnackBar('Error', 'Failed to delete notification: ${e.toString()}');
    }
  }

  Widget _infoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          SizedBox(
            width: 100, 
            child: Text(label, style: const TextStyle(fontWeight: FontWeight.w400), textAlign: TextAlign.left),
          ),
          const SizedBox(width: 36), 
          Expanded(
            child: Align(
              alignment: Alignment.centerLeft,
              child: Text(value, style: const TextStyle(fontWeight: FontWeight.w300), textAlign: TextAlign.left),
            ),
          ),
        ],
      ),
    );
  }

  Widget _navBarItem(IconData icon, String label, String route) {
    return InkWell(
      onTap: () {
        Get.offAllNamed(route);
      },
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 28, color: const Color(0xFF0A2A3A)),
          const SizedBox(height: 2),
          Text(label, style: const TextStyle(fontSize: 12, color: Color(0xFF0A2A3A))),
        ],
      ),
    );
  }

  void _showDeleteConfirmation(BuildContext context, VoidCallback onConfirm) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFE6F0FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(32),
                  child: SvgPicture.asset(
                    'assets/Delete.svg',
                    width: 48,
                    height: 48,
                    color: const Color(0xFF007AFF),
                  ),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
                ),
                const SizedBox(height: 8),
                const Text(
                  'You want to delete this notification',
                  style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
                ),
                const SizedBox(height: 28),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF2F2F7),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.black)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          Navigator.of(context).pop();
                          onConfirm();
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  void _showDeleteSuccess(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFE6F0FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(32),
                  child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Success!',
                  style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
                ),
                const SizedBox(height: 8),
                const Text(
                  'You have successfully deleted notification',
                  style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
                ),
                const SizedBox(height: 28),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  
  Future<void> _manualRefresh() async {
    if (_currentAcno != null) {
      await _fetchNotifications(_currentAcno!);
    }
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'dashboard_screen.dart' as dash;
import 'report.dart' as report;
import 'menu.dart' as menu;
import 'create_order.dart' as create_order;
import 'create_cn_screen.dart';
import '../network/order_service.dart';
import 'filter_screen.dart';
import 'quick_edit_screen.dart';
import '../utils/Layout/app_bottom_bar.dart';
import 'bulk_tracking_screen.dart';
import '../widgets/custom_date_selector.dart';
import '../services/auth_service.dart';
import '../utils/custom_snackbar.dart';
import '../widgets/connectivity_wrapper.dart';
import 'package:dio/dio.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../widgets/courier_logo_widget.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'load_sheet_screen.dart' as load_sheet;
import 'create_loadsheet_screen.dart';
import '../config/api_config.dart';
import '../widgets/tracking_details_dialog.dart';


class OrderListScreen extends StatefulWidget {
  final String? snackbarMessage;
  final String? from;
  const OrderListScreen({Key? key, this.snackbarMessage, this.from}) : super(key: key);

  @override
  State<OrderListScreen> createState() => _OrderListScreenState();
}

class _OrderListScreenState extends State<OrderListScreen> {
  List<dynamic> orders = [];
  int startLimit = 1;
  int endLimit = 25;
  final int pageSize = 25;
  bool isLoading = false;
  bool isPaginating = false;
  bool _isRefreshing = false; 
  bool hasMore = true;
  final ScrollController _scrollController = ScrollController();
  final Set<int> expanded = {};
  final AuthService _authService = Get.find<AuthService>();

  
  bool selectAll = false;
  final Set<int> selectedOrders = {};

  
  int totalOrders = 0;
  int fulfilledOrders = 0;
  int deliveredOrders = 0;
  int returnedOrders = 0;

  
  String? _searchQuery;
  List<dynamic> _filteredOrders = [];
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  DateTime _startDate = DateTime.now().subtract(const Duration(days: 3));
  DateTime _endDate = DateTime.now();
  bool _datesLoaded = false;
  
  Map<String, dynamic>? _activeFilters;
  String? _selectedOrderStatus; 

  
  static Map<String, dynamic>? _lastOrderListParams;
  static List<dynamic>? _cachedOrderList;
  static int? _cachedStartLimit;
  static int? _cachedEndLimit;
  static bool? _cachedHasMore;

  @override
  void initState() {
    super.initState();
    _loadSavedDateRange();
    _scrollController.addListener(() {
      final currentPixels = _scrollController.position.pixels;
      final maxScrollExtent = _scrollController.position.maxScrollExtent;
      final threshold = maxScrollExtent - 200;
      
      
      
      // Prevent multiple rapid triggers
      if (mounted && currentPixels >= threshold && !isLoading && !isPaginating && hasMore) {
      
        fetchOrders();
      } else if (mounted && currentPixels >= threshold) {
        
      }
    });
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    selectedOrders.clear(); 
    
    if (widget.snackbarMessage != null && widget.snackbarMessage!.isNotEmpty) {
      if (widget.snackbarMessage == 'refresh') {
        fetchOrders(reset: true, force: true);
      } else {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          customSnackBar('Success', widget.snackbarMessage!);
        });
        
      }
    }
  }

  Future<void> _loadSavedDateRange() async {
    final prefs = await SharedPreferences.getInstance();
    final startStr = prefs.getString('order_list_start_date');
    final endStr = prefs.getString('order_list_end_date');
    if (startStr != null && endStr != null) {
      setState(() {
        _startDate = DateTime.parse(startStr);
        _endDate = DateTime.parse(endStr);
      });
    }
    setState(() { _datesLoaded = true; });
    _restoreOrFetchOrders();
  }

  void _restoreOrFetchOrders() async {
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
      'startDate': _startDate.toIso8601String().split('T')[0],
      'endDate': _endDate.toIso8601String().split('T')[0],
      'filters': _activeFilters?.toString() ?? '',
      'startLimit': startLimit,
      'endLimit': endLimit,
    };
    if (_lastOrderListParams != null && _cachedOrderList != null && _lastOrderListParams.toString() == params.toString()) {
      setState(() {
        orders = List.from(_cachedOrderList!);
        startLimit = _cachedStartLimit ?? startLimit;
        endLimit = _cachedEndLimit ?? endLimit;
        hasMore = _cachedHasMore ?? hasMore;
        _applySearch();
      });
      await fetchReportSummary(); 
      return;
    }
    await _loadUserDataAndFetchData();
  }

  Future<void> _loadUserDataAndFetchData() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchReportSummary();
    await fetchOrders(reset: true);
  }

  Future<void> _saveDateRange(DateTime start, DateTime end) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('order_list_start_date', start.toIso8601String());
    await prefs.setString('order_list_end_date', end.toIso8601String());
  }

  @override
  void dispose() {
    _searchController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text;
      _applySearch();
    });
  }

  void _applySearch() {
    List<dynamic> tempOrders = orders;
   
    
    
    if (_searchQuery != null && _searchQuery!.isNotEmpty) {
      tempOrders = tempOrders.where((order) {
        return order.values.any((v) => v != null && v.toString().toLowerCase().contains(_searchQuery!.toLowerCase()));
      }).toList();
      
    }
    
    
    if (_activeFilters != null) {
      tempOrders = tempOrders.where((order) {
        
        if (_activeFilters!['status'] != null && (_activeFilters!['status'] as List).isNotEmpty) {
          final status = (order['status']?.toString() ?? '').toLowerCase().trim();
          final statusFilters = (_activeFilters!['status'] as List).map((s) => s.toString().toLowerCase().trim()).toList();
          
          if (!statusFilters.any((filter) => status.contains(filter) || filter.contains(status))) {
            return false;
          }
        }
        
        if (_activeFilters!['platform'] != null && (_activeFilters!['platform'] as List).isNotEmpty) {
          final store = order['store_name']?.toString() ?? '';
          if (!(_activeFilters!['platform'] as List).contains(store)) {
            return false;
          }
        }
        
        if (_activeFilters!['courier'] != null && (_activeFilters!['courier'] as List).isNotEmpty) {
          final courier = (order['courier_name']?.toString() ?? '').toLowerCase().trim();
          final courierFilters = (_activeFilters!['courier'] as List).map((c) => c.toString().toLowerCase().trim()).toList();
          if (!courierFilters.any((filter) => courier.contains(filter) || filter.contains(courier))) {
            return false;
          }
        }
        
        if (_activeFilters!['city_ids'] != null && (_activeFilters!['city_ids'] as List).isNotEmpty) {
          final orderCityId = order['origin_city_id']?.toString() ?? order['destination_city_id']?.toString() ?? '';
          final cityIds = (_activeFilters!['city_ids'] as List).map((e) => e.toString()).toList();
         
          if (!cityIds.contains(orderCityId)) {
            
            return false;
          }
        }
        return true;
      }).toList();
    }
    _filteredOrders = tempOrders;
   
  }

  Future<void> fetchReportSummary() async {
    try {
      final acno = _authService.getCurrentAcno();
      if (acno == null) {
        
        return;
      }
      final summary = await OrderService.fetchReportSummary(
        acno: acno,
        startDate: _startDate.toIso8601String().split('T')[0],
        endDate: _endDate.toIso8601String().split('T')[0],
        module: 'order_report',
      );
      setState(() {
        totalOrders = int.tryParse(summary['orders']?['total']?.toString() ?? '0') ?? 0;
        fulfilledOrders = int.tryParse(summary['booked_orders']?['total']?.toString() ?? '0') ?? 0;
        deliveredOrders = int.tryParse(summary['delivered_orders']?['total']?.toString() ?? '0') ?? 0;
        returnedOrders = int.tryParse(summary['returned_orders']?['total']?.toString() ?? '0') ?? 0;
      });
    } catch (e) {
      
    }
  }

  void _clearLoadingState() {
    if (mounted) {
      setState(() {
        isLoading = false;
        isPaginating = false;
      });
    
    }
  }

  Future<void> fetchOrders({bool reset = false, bool force = false}) async {
    // Prevent duplicate API calls, but allow filter resets
    if ((isLoading || isPaginating) && !reset && !force) {
      
      return;
    }
    
    // If this is a filter reset, clear any existing loading state
    if (reset) {
      
      setState(() {
        isLoading = false;
        isPaginating = false;
      });
    }
    
    final acno = _authService.getCurrentAcno();
    final params = {
      'acno': acno,
      'startDate': _startDate.toIso8601String().split('T')[0],
      'endDate': _endDate.toIso8601String().split('T')[0],
      'filters': _activeFilters == null ? 'CLEARED' : _activeFilters.toString(),
      'startLimit': startLimit,
      'endLimit': endLimit,
    };
    
    
    
    if (!force && !reset && _lastOrderListParams != null && _cachedOrderList != null) {
      if (_lastOrderListParams.toString() == params.toString()) {
       
        setState(() {
          orders = List.from(_cachedOrderList!);
          startLimit = _cachedStartLimit ?? startLimit;
          endLimit = _cachedEndLimit ?? endLimit;
          hasMore = _cachedHasMore ?? hasMore;
          _applySearch();
        });
        return;
      }
    }
    if (reset) {
     
      setState(() {
        orders = [];
        startLimit = 1;
        endLimit = pageSize;
        hasMore = true;
      });
    }
    if (!hasMore) {
      
      return;
    }
    if (orders.isEmpty) {
      setState(() {
        isLoading = true;
        isPaginating = false;
      });
     
    } else {
      setState(() {
        isPaginating = true;
        isLoading = false;
      });
      
    }
    try {
      if (acno == null) {
        setState(() => isLoading = false);
        return;
      }
      
      Map<String, dynamic> extraParams = {};
      if (_activeFilters != null && _activeFilters!['order'] != null) {
        if (_activeFilters!['order'] == 'Booked') {
          extraParams['filter_orders'] = '1';
        } else if (_activeFilters!['order'] == 'Unbooked') {
          extraParams['filter_orders'] = '0';
        }
      }
      
      if (_activeFilters != null && _activeFilters!['status_ids'] != null && (_activeFilters!['status_ids'] as List).isNotEmpty) {
        final ids = (_activeFilters!['status_ids'] as List).map((e) => "'${e.toString()}'").join(',');
        extraParams['status_id'] = ids;
      }
      
      if (_activeFilters != null && _activeFilters!['city_ids'] != null && (_activeFilters!['city_ids'] as List).isNotEmpty) {
        final cityIds = (_activeFilters!['city_ids'] as List).map((e) => "'${e.toString()}'").join(',');
        extraParams['city_id'] = cityIds;
        
        // Debug: Show city filter details
      
      } else {
        
        if (_activeFilters != null) {
         
        }
      }
      
      if (_activeFilters != null && _activeFilters!['platform'] != null && (_activeFilters!['platform'] as List).isNotEmpty) {
        final platforms = (_activeFilters!['platform'] as List).map((e) => "'${e.toString()}'").join(',');
        extraParams['store_name'] = platforms;
      }
      
      if (_activeFilters != null && _activeFilters!['courier_ids'] != null && (_activeFilters!['courier_ids'] as List).isNotEmpty) {
        final courierIds = (_activeFilters!['courier_ids'] as List).map((e) => "'${e.toString()}'").join(',');
        extraParams['courier_ids'] = courierIds;
      }
     
      
  
      
     
      if (_activeFilters != null) {
        _activeFilters!.forEach((key, value) {
        
        });
      } else {
       
      }
    
      extraParams.forEach((key, value) {
        
      });
      
      // Add timeout protection for the API call
      final data = await OrderService.fetchOrders(
        startLimit: startLimit,
        endLimit: endLimit,
        acno: acno,
        startDate: _startDate.toIso8601String().split('T')[0],
        endDate: _endDate.toIso8601String().split('T')[0],
        extraParams: extraParams,
      ).timeout(
        const Duration(seconds: 30),
        onTimeout: () {
        
          throw Exception('API call timed out');
        },
      );
      
      final List<dynamic> newOrders = data['data'] ?? [];
      
      // Debug: Show API response details for city filters
      if (_activeFilters != null && _activeFilters!['city_ids'] != null && (_activeFilters!['city_ids'] as List).isNotEmpty) {
       
        
        if (newOrders.isNotEmpty) {
          // Check first few orders to see their city information
          final sampleSize = newOrders.length > 5 ? 5 : newOrders.length;
         
          for (int i = 0; i < sampleSize; i++) {
            final order = newOrders[i];
            final originCityId = order['origin_city_id']?.toString();
            final destinationCityId = order['destination_city_id']?.toString();
            final orderId = order['id']?.toString();
           
          }
          
          // Check if any orders have city IDs that match our filter
          final appliedCityIds = (_activeFilters!['city_ids'] as List).map((e) => e.toString()).toList();
          final matchingOrders = newOrders.where((order) {
            final originCityId = order['origin_city_id']?.toString();
            final destinationCityId = order['destination_city_id']?.toString();
            return appliedCityIds.contains(originCityId) || appliedCityIds.contains(destinationCityId);
          }).toList();
          
          
          if (matchingOrders.isEmpty && newOrders.isNotEmpty) {
            
          }
        }
      }
      
      
      // Debug: Show filter-specific response info
      if (_activeFilters != null && _activeFilters!.isNotEmpty) {
    
        if (newOrders.isEmpty) {
          
        }
      }
      
      
      data.forEach((key, value) {
        if (value is List) {
          
          if (value.isNotEmpty && value.first is Map) {
            
          }
        } else if (value is Map) {
         
        } else {
          
        }
      });
      
      if (newOrders.isNotEmpty) {
        
        
        for (int i = 0; i < newOrders.length; i++) {
          final order = newOrders[i];
          final courierName = order['courier_name'];

          if (courierName?.toString().toLowerCase() == 'bluex') {
           
          }
        }
      }
    
      
      
      // Check for duplicate data
      if (orders.isNotEmpty && newOrders.isNotEmpty) {
        final firstNewOrderId = newOrders.first['id']?.toString();
        final lastExistingOrderId = orders.last['id']?.toString();
        
        if (firstNewOrderId == lastExistingOrderId) {
         
          return;
        }
      }
      
      setState(() {
        
        final processedOrders = newOrders.map((order) {
          
          final courierName = order['courier_name'];
          if (courierName == null || courierName.toString().isEmpty) {
           
          }
          return order;
        }).toList();
        
        orders.addAll(processedOrders);
        
        _lastOrderListParams = params;
        _cachedOrderList = List.from(orders);
        _cachedStartLimit = startLimit;
        _cachedEndLimit = endLimit;
        _cachedHasMore = hasMore;
        
        // Update pagination limits
        startLimit = endLimit + 1;
        endLimit += pageSize;
        hasMore = newOrders.length == pageSize;
        
       
        
        _applySearch();
      });
    } catch (e) {
      print('   -  Error fetching orders: $e');
      print('   - Error type: ${e.runtimeType}');
      if (e is Exception) {
        
      }
      
      // Don't show API timeout errors to user
      if (mounted && !e.toString().contains('API call timed out')) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to load orders. Please try again.'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    } finally {
      // Always reset loading state, regardless of success or failure
      if (mounted) {
        setState(() {
          isLoading = false;
          isPaginating = false;
        });
      }
    }
  }

  Future<void> _deleteOrder(String orderId, {dynamic order}) async {
    try {
      final user = _authService.currentUser.value;
      final acno = user?.acno ?? '';
      final userId = user?.userId ?? '';
      if (acno == null || acno.isEmpty) {
        customSnackBar('Error', 'User not logged in');
        return;
      }
      
      if (order != null && (order['is_shipment'] == 1 || order['is_shipment'] == '1')) {
        final dio = Dio();
        final consigmentNo = order['consigment_no'] ?? '';
        final orderIdInt = int.tryParse(orderId) ?? 0;
        final response = await dio.post(
          ApiConfig.getEndpointUrl(ApiConfig.cancelShipmentsEndpoint),
          data: {
            "acno": acno,
            "user_id": userId,
            "detail": [
              {
                "order_id": orderIdInt,
                "consigment_no": consigmentNo,
              }
            ]
          },
          options: Options(headers: {'Content-Type': 'application/json'}),
        );
        if (response.statusCode == 200 && (response.data['status'] == 1 || response.data['success'] == true)) {
          
          customSnackBar('Success', 'Shipment cancelled successfully!');
          await fetchOrders(reset: true);
          await fetchReportSummary(); 
        } else {
         
          customSnackBar('Error', response.data['message'] ?? response.data['error'] ?? 'Failed to cancel shipment');
        }
        return;
      }
      
      if (order != null && (order['is_shipment'] == 0 || order['is_shipment'] == '0')) {
        final dio = Dio();
        final actualAcno = order['acno']?.toString() ?? acno;
        final actualOrderId = int.tryParse(order['id']?.toString() ?? '') ?? 0;
        final response = await dio.post(
          ApiConfig.getEndpointUrl(ApiConfig.orderUpdateEndpoint),
          data: {
            "acno": actualAcno,
            
            "orders": [actualOrderId],
            "status": "active",
          },
          options: Options(
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer QoVDWMtOU9sUzi543rtAVcaeAiEoDH/lQMmuxj4JbjO54gmraIr8QwAloW2F8KEM4PEU9zibMkdCp5RMU3LFqg==',
            },
          ),
        );
        if (response.statusCode == 200 && (response.data['status'] == 1 || response.data['success'] == true)) {
          customSnackBar('Success', 'Order deleted successfully!');
          
          _cachedOrderList = null;
          _lastOrderListParams = null;
          _cachedStartLimit = null;
          _cachedEndLimit = null;
          _cachedHasMore = null;
          await fetchOrders(reset: true);
          await fetchReportSummary(); 
        } else {
          customSnackBar('Error', response.data['message'] ?? response.data['error'] ?? 'Failed to delete order');
        }
        return;
      }
      
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderUpdateEndpoint),
        data: {
          "acno": acno,
          "orders": [orderId],
          "status": "inactive",
        },
        options: Options(
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer QoVDWMtOU9sUzi543rtAVcaeAiEoDH/lQMmuxj4JbjO54gmraIr8QwAloW2F8KEM4PEU9zibMkdCp5RMU3LFqg==',
          },
        ),
      );
      if (response.statusCode == 200 && (response.data['status'] == 1 || response.data['success'] == true)) {
        customSnackBar('Success', 'Order deleted successfully!');
        
        _cachedOrderList = null;
        _lastOrderListParams = null;
        _cachedStartLimit = null;
        _cachedEndLimit = null;
        _cachedHasMore = null;
        await fetchOrders(reset: true);
        await fetchReportSummary(); 
      } else {
        customSnackBar('Error', response.data['message'] ?? response.data['error'] ?? 'Failed to delete order');
      }
    } catch (e) {
      customSnackBar('Error', e.toString());
    }
  }

  
  static void clearAllOrderListCaches() {
    _cachedOrderList = null;
    _lastOrderListParams = null;
    _cachedStartLimit = null;
    _cachedEndLimit = null;
    _cachedHasMore = null;
  }

  void _showDeleteOrderDialog(BuildContext context, VoidCallback onConfirm) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Container(
                  decoration: BoxDecoration(
                    color: const Color(0xFFEFF6FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(24),
                  child: Icon(Icons.delete_rounded, size: 56, color: Color(0xFF007AFF)),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w700,
                    fontFamily: 'SF Pro Display',
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                const Text(
                  'You want to delete this order',
                  style: TextStyle(
                    fontSize: 15,
                    fontWeight: FontWeight.w400,
                    fontFamily: 'SF Pro Display',
                    color: Color(0xFF6B7280),
                  ),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Get.back(result: false),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF3F4F6),
                          foregroundColor: const Color(0xFF111827),
                          elevation: 0,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          Get.back(result: true);
                          onConfirm();
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          foregroundColor: Colors.white,
                          elevation: 0,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          padding: const EdgeInsets.symmetric(vertical: 14),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  

  

  String _getCourierLogoUrl(String courierName) {
    if (courierName.isEmpty) return '';
    
    final encodedName = Uri.encodeComponent(courierName.trim());
    return '${ApiConfig.assetBaseUrl}$encodedName.svg';
  }

  String _getOrderListFilterSummary() {
    if (_activeFilters == null) return '';
    final summary = <String>[];
    
    if (_activeFilters!['status'] != null && (_activeFilters!['status'] is List)) {
      final statusList = _activeFilters!['status'] as List;
      if (statusList.isNotEmpty && statusList.first is Map) {
        summary.add(statusList.map((e) => e['name']).join(", "));
      } else {
        summary.add(statusList.join(", "));
      }
    }
    
    if (_activeFilters!['platform'] != null && (_activeFilters!['platform'] as List).isNotEmpty) summary.add((_activeFilters!['platform'] as List).join(", "));
    
    if (_activeFilters!['courier'] != null && (_activeFilters!['courier'] as List).isNotEmpty) {
      final courierList = _activeFilters!['courier'] as List;
      if (courierList.isNotEmpty && courierList.first is Map) {
        summary.add(courierList.map((e) => e['name']).join(", "));
      } else {
        summary.add(courierList.join(", "));
      }
    }
    
    if (_activeFilters!['city'] != null && (_activeFilters!['city'] as List).isNotEmpty) {
      final cityList = _activeFilters!['city'] as List;
      if (cityList.isNotEmpty && cityList.first is Map) {
        summary.add(cityList.map((e) => e['name']).join(", "));
      } else {
        summary.add(cityList.join(", "));
      }
    }
    
    if (_activeFilters!['order'] != null && _activeFilters!['order'].toString().isNotEmpty) summary.add(_activeFilters!['order'].toString());
    
    final currentList = ((_searchQuery != null && _searchQuery!.isNotEmpty) || _activeFilters != null)
      ? _filteredOrders
      : orders;
    final count = currentList.length;
    final summaryString = summary.where((s) => s.isNotEmpty).join(", ");
    return summaryString.isNotEmpty ? (summaryString + (count > 0 ? ' ($count)' : '')) : (count > 0 ? '($count)' : '');
  }

  Widget _defListRowOrder(String label, Widget valueWidget) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100, 
          child: Text(label, style: TextStyle(fontWeight: FontWeight.w400, fontSize: 14, color: Colors.black)),
        ),
        const SizedBox(width: 36), 
        Expanded(
          child: valueWidget,
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    if (!_datesLoaded) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () {
          
            if (widget.from == 'create_loadsheet') {
              Get.offAll(() => CreateLoadsheetScreen());
            } else if (widget.from == 'create_order') {
              
              Get.offAll(() => create_order.CreateOrderScreen());
            } else {
              
              
              Navigator.of(context).maybePop();
            }
          },
        ),
        title: Padding(
          padding: const EdgeInsets.only(left: 8),
          child: const Text(
            'Orders',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
        actions: [
          if (_searchQuery != null && _searchQuery!.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.clear_rounded, color: Colors.grey),
              onPressed: () {
                setState(() {
                  _searchController.clear();
                  _searchQuery = null;
                  _applySearch();
                });
              },
            ),
          IconButton(
            icon: SvgPicture.asset(
    'assets/Filter.svg',
    width: 24,
    height: 24,
    color: Colors.black, 
  ),
            onPressed: () async {
              // Clear any existing loading state before opening filter
              _clearLoadingState();
              
              final result = await Get.to<Map<String, dynamic>>(() => FilterScreen(initialFilters: _activeFilters));
              if (result != null) {
                setState(() {
                  _activeFilters = result;
                  orders = [];
                  _filteredOrders = [];
                  selectedOrders.clear();
                });
                
               
                result.forEach((key, value) {
                  print('   - $key: $value (${value.runtimeType})');
                });
                
                // Debug: Show city filter specifically
                if (result['city_ids'] != null) {
                 
                  if ((result['city_ids'] as List).isNotEmpty) {
                   
                  }
                }
                
                // Add timeout protection for filter application
                try {
                  await fetchOrders(reset: true).timeout(
                    const Duration(seconds: 45),
                    onTimeout: () {
                    
                      _clearLoadingState();
                      throw Exception('Filter application timed out');
                    },
                  );
                  customSnackBar('Success', 'Filter applied'); 
                } catch (e) {
                  print(' Filter application failed: $e');
                  _clearLoadingState();
                  customSnackBar('Error', 'Failed to apply filter: ${e.toString()}');
                }
              } else {
                // Treat null result as reset from filter screen
                setState(() {
                  _activeFilters = null;
                  orders = [];
                  _filteredOrders = [];
                  selectedOrders.clear();
                });
                
                try {
                  await fetchOrders(reset: true, force: true).timeout(
                    const Duration(seconds: 45),
                    onTimeout: () {
                      print(' Filter clearing timed out after 45 seconds');
                      _clearLoadingState();
                      throw Exception('Filter clearing timed out');
                    },
                  );
                  customSnackBar('Success', 'Filters cleared');
                } catch (e) {
                  print(' Filter clearing failed: $e');
                  _clearLoadingState();
                  customSnackBar('Error', 'Failed to clear filters: ${e.toString()}');
                }
              }
            },
          ),
          IconButton(
            icon: SvgPicture.asset(
    'assets/Calender.svg', 
    width: 24,
    height: 24,
     
  ),
            onPressed: () async {
              final picked = await showModalBottomSheet<DateTimeRange>(
                context: context,
                isScrollControlled: true,
                backgroundColor: Colors.transparent,
                builder: (context) => Container(
                  width: MediaQuery.of(context).size.width,
                  height: MediaQuery.of(context).size.height * 0.6,
                  decoration: const BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                  ),
                  child: CustomDateSelector(
                    initialStartDate: _startDate,
                    initialEndDate: _endDate,
                  ),
                ),
              );
              if (picked != null) {
                setState(() {
                  _startDate = picked.start;
                  _endDate = picked.end;
                });
                await _saveDateRange(_startDate, _endDate);
                await fetchReportSummary();
                await fetchOrders(reset: true);
              }
            },
          ),
        ],
      ),
      body: GestureDetector(
        behavior: HitTestBehavior.translucent,
        onTap: () {
          FocusScope.of(context).unfocus();
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              
              Padding(
                padding: const EdgeInsets.only(bottom: 4, top: 8),
                child: Text(
                  _getDateRangeText(),
                  style: const TextStyle(
                    fontFamily: 'SF Pro Display',
                    fontWeight: FontWeight.w400,
                    fontSize: 14,
                    color: Colors.grey,
                  ),
                ),
              ),
              
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 4),
                child: TextField(
                  controller: _searchController,
                  focusNode: _searchFocusNode,
                  decoration: InputDecoration(
                    hintText: 'Search',
                    suffixIcon: Icon(Icons.search_rounded),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    filled: true,
                    fillColor: const Color(0xFFF5F5F7),
                    contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide.none,
                    ),
                  ),
                ),
              ),
              
              
              if (_activeFilters != null && _activeFilters!.isNotEmpty) ...[
                const SizedBox(height: 8),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.blue.withOpacity(0.3)),
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.filter_list_rounded, size: 16, color: Colors.blue[700]),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _getOrderListFilterSummary(),
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.blue[700],
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                      GestureDetector(
                        onTap: () async {
                          setState(() {
                            _activeFilters = null;
                            selectedOrders.clear();
                          });
                          await fetchOrders(reset: true); 
                          _applySearch();
                          customSnackBar('Success', 'Filters cleared');
                        },
                        child: Icon(Icons.clear_rounded, size: 16, color: Colors.blue[700]),
                      ),
                    ],
                  ),
                ),
              ],
              const SizedBox(height: 8), 
              
              
              
              
              Container(
                width: MediaQuery.of(context).size.width,
                padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 18), 
                decoration: BoxDecoration(
                  color: const Color(0xFFE6F1FF),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    _SummaryColumn(label: 'Total', value: totalOrders.toString()),
                    _SummaryColumn(label: 'Fulfilled', value: fulfilledOrders.toString()),
                    _SummaryColumn(label: 'Delivered', value: deliveredOrders.toString()),
                    _SummaryColumn(label: 'Returns', value: returnedOrders.toString()),
                  ],
                ),
              ),
              const SizedBox(height: 8), 
              
              Builder(
                builder: (context) {
                  final currentList = ((_searchQuery != null && _searchQuery!.isNotEmpty) || _activeFilters != null) ? _filteredOrders : orders;
                  if (!isLoading && currentList.isEmpty) {
                    return const Padding(
                      padding: EdgeInsets.symmetric(vertical: 32),
                      child: Center(child: Text('No data found', style: TextStyle(fontSize: 16, color: Colors.grey))),
                    );
                  }
                  if (currentList.isEmpty) {
                    return const SizedBox.shrink();
                  }
                  return Row(
                    children: [
                      Checkbox(
                        value: selectAll,
                        onChanged: (val) {
                          setState(() {
                            selectAll = val ?? false;
                            if (val == true) {
                              selectedOrders.clear();
                              for (int i = 0; i < currentList.length; i++) {
                                final status = (currentList[i]['status']?.toString().toLowerCase().trim() ?? '');
                                if (status != 'cancelled') {
                                  selectedOrders.add(i);
                                }
                              }
                            } else {
                              selectedOrders.clear();
                            }
                          });
                        },
                        activeColor: const Color(0xFF007AFF),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        visualDensity: VisualDensity.compact,
                      ),
                      const Text('Select All', style: TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w400, fontSize: 15)),
                      const Spacer(),
                      if (selectedOrders.isNotEmpty) ...[
                        GestureDetector(
                          onTap: () async {
                            
                            if (_activeFilters != null && _activeFilters!['order'] == 'Booked') {
                              customSnackBar('Error', 'This order is already booked, please try another.');
                              return;
                            }
                            bool anyBooked = selectedOrders.any((idx) =>
                              (currentList[idx]['status']?.toString().toLowerCase() == 'booked')
                            );
                            if (anyBooked) {
                              customSnackBar('Error', 'The order is already booked, please try another CN.');
                              return;
                            }
                            
                            bool anyShipment = selectedOrders.any((idx) =>
                              currentList[idx]['is_shipment'] == '1'
                            );
                            if (anyShipment) {
                              customSnackBar('Error', 'Consignment no already generated. Please try another cn');
                              return;
                            }
                            
                            final selectedOrdersList = selectedOrders.map((i) => currentList[i]).toList();
                            
                            setState(() {
                              selectedOrders.clear();
                              selectAll = false;
                            });
                            final result = await Get.to(() => CreateCnScreen(orders: selectedOrdersList));
                            
                            if (result == true) {
                              setState(() {
                                isLoading = true;
                              });
                              await fetchOrders(reset: true, force: true);
                              setState(() {
                                isLoading = false;
                              });
                            }
                          },
                          child: const Text('Create CN', style: TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w500, fontSize: 15, color: Color(0xFF007AFF), decoration: TextDecoration.none)),
                        ),
                        const SizedBox(width: 16),
                        GestureDetector(
                          onTap: () {
                            final selectedList = selectedOrders.map((idx) => currentList[idx]).toList();
                            
                            
                            bool allNoShipment = selectedList.every((order) => order['is_shipment'] == '0');
                            
                            if (allNoShipment) {
                              
                              _showChangeStatusDialog(context, selectedList);
                            } else {
                              
                              
                              bool anyNoShipment = selectedList.any((order) => order['is_shipment'] == '0');
                              if (anyNoShipment) {
                                customSnackBar('Error', 'Consignment no not found!');
                                return;
                              }
                              final orderIds = selectedList.map((order) => order['id']?.toString() ?? '').where((id) => id.isNotEmpty).join(',');
                              final consignmentNos = selectedList.map((order) => order['consigment_no']?.toString() ?? '').where((cn) => cn.isNotEmpty).join(',');
                              final acno = _authService.getCurrentAcno();
                              if (acno == null || acno.isEmpty) {
                                customSnackBar('Error', 'Account number not found. Please log in again.');
                                return;
                              }
                              Navigator.push(
                                context,
                                MaterialPageRoute(
                                  builder: (context) => BulkTrackingScreen(
                                    acno: acno,
                                    orderIds: orderIds,
                                    consignmentNos: consignmentNos,
                                  ),
                                ),
                              );
                            }
                          },
                          child: Text(
                            selectedOrders.isNotEmpty && selectedOrders.every((idx) => currentList[idx]['is_shipment'] == '0') 
                              ? 'Change Status' 
                              : 'Bulk Tracking', 
                            style: TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w500, fontSize: 15, color: selectedOrders.isNotEmpty && selectedOrders.every((idx) => currentList[idx]['is_shipment'] == '0') 
                              ? Color(0xFF007AFF)
                              : Color(0xFF007AFF), 
                              decoration: TextDecoration.none)
                          ),
                        ),
                      ],
                    ],
                  );
                },
              ),
              const SizedBox(height: 8), 
              
              Expanded(
                child: isLoading && orders.isEmpty
                  ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
                  : RefreshIndicator(
                      onRefresh: _manualRefresh,
                      child: AnimationLimiter(
                        child: ListView.builder(
                          controller: _scrollController,
                          padding: const EdgeInsets.only(bottom: 80), 
                          itemCount: ((_searchQuery != null && _searchQuery!.isNotEmpty) || _activeFilters != null ? _filteredOrders.length : orders.length) + (isPaginating && hasMore ? 1 : 0),
                          itemBuilder: (context, i) {
                            final list = ((_searchQuery != null && _searchQuery!.isNotEmpty) || _activeFilters != null ? _filteredOrders : orders);
                            if (i >= list.length) {
                              if (hasMore && list.isNotEmpty) {
                                return Center(child: Padding(
                                  padding: EdgeInsets.symmetric(vertical: 16),
                                  child: CircularProgressIndicator(color: Color(0xFF007AFF)),
                                ));
                              } else {
                                return const SizedBox.shrink();
                              }
                            }
                            final order = list[i];
                            return AnimationConfiguration.staggeredList(
                              position: i,
                              duration: const Duration(milliseconds: 450),
                              child: SlideAnimation(
                                verticalOffset: 50.0,
                                child: FadeInAnimation(
                                  child: Column(
                                    children: [
                                      Container(
                                        width: double.infinity,
                                        margin: const EdgeInsets.only(top: 4, bottom: 4),
                                        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 16), 
                                        decoration: BoxDecoration(
                                          color: const Color(0xFFF5F5F7),
                                          borderRadius: BorderRadius.circular(12),
                                        ),
                                        child: Column(
                                          crossAxisAlignment: CrossAxisAlignment.start,
                                          children: [
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                if ((order['status']?.toString().toLowerCase().trim() ?? '') != 'cancelled')
                                                  Transform.translate(
                                                    offset: Offset(-8, 0), 
                                                    child: Checkbox(
                                                      value: selectedOrders.contains(i),
                                                      onChanged: (val) {
                                                        setState(() {
                                                          if (val == true) {
                                                            selectedOrders.add(i);
                                                          } else {
                                                            selectedOrders.remove(i);
                                                          }
                                                        });
                                                      },
                                                      activeColor: const Color(0xFF007AFF),
                                                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                                                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                                                      visualDensity: VisualDensity.compact,
                                                    ),
                                                  ),
                                                const SizedBox(width: 0),
                                                Expanded(
                                                  child: Padding(
                                                    padding: const EdgeInsets.only(top: 8),
                                                    child: Text(
                                                      'Order ID: ${order['id'] ?? ''}',
                                                      style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                                                    ),
                                                  ),
                                                ),
                                                Column(
                                                  children: [
                                                    SizedBox(height: 6),
                                                    Container(
                                                      constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                                      decoration: BoxDecoration(
                                                        color: () {
                                                          final status = order['status']?.toString().toLowerCase().trim();
                                                          if (status == 'cancelled') return Colors.red.withOpacity(0.1);
                                                          if (status == 'booked') return const Color(0xFF8e24aa).withOpacity(0.1);
                                                          if (status == 'new') return const Color(0xFF1DA1F2).withOpacity(0.1);
                                                          if (status == 'pickup ready') return const Color(0xFF43A047).withOpacity(0.1);
                                                          if (status == 'in transit') return const Color(0xFFea7317).withOpacity(0.1);
                                                          if (status == 'out for delivery') return const Color(0xFFf2d016).withOpacity(0.1);
                                                          if (status == 'delivered') return const Color(0xFF43A047).withOpacity(0.1);
                                                          if (status == 'shipped') return const Color(0xFF4191ff).withOpacity(0.1);
                                                          if (status == 'onroute') return const Color(0xFFf2d016).withOpacity(0.1);
                                                          if (status == 'accepted') return const Color(0xFF9b51e0).withOpacity(0.1);
                                                          if (status == 'rejected') return const Color(0xFFff7400).withOpacity(0.1);
                                                          if (status == 'returned') return const Color(0xFFf83245).withOpacity(0.1);
                                                          if (status == 'replacement') return const Color(0xFF66cccc).withOpacity(0.1);
                                                          if (status == 'error' || status == 'badge-error') return const Color(0xFFf64e60).withOpacity(0.1);
                                                          return const Color(0xFF1DA1F2).withOpacity(0.1);
                                                        }(),
                                                        borderRadius: BorderRadius.circular(16),
                                                      ),
                                                      alignment: Alignment.center,
                                                      child: Text(
                                                        order['status']?.toString().capitalize ?? '',
                                                        style: GoogleFonts.inter(
                                                        color: () {
                                                          final status = order['status']?.toString().toLowerCase().trim();
                                                          if (status == 'cancelled') return Colors.red;
                                                          if (status == 'booked') return const Color(0xFF8e24aa);
                                                          if (status == 'new') return const Color(0xFF1DA1F2);
                                                          if (status == 'pickup ready') return const Color(0xFF43A047);
                                                          if (status == 'in transit') return const Color(0xFFea7317);
                                                          if (status == 'out for delivery') return const Color(0xFFf2d016);
                                                          if (status == 'delivered') return const Color(0xFF43A047);
                                                          if (status == 'shipped') return const Color(0xFF4191ff);
                                                          if (status == 'onroute') return const Color(0xFFf2d016);
                                                          if (status == 'accepted') return const Color(0xFF9b51e0);
                                                          if (status == 'rejected') return const Color(0xFFff7400);
                                                          if (status == 'returned') return const Color(0xFFf83245);
                                                          if (status == 'replacement') return const Color(0xFF66cccc);
                                                          if (status == 'error' || status == 'badge-error') return const Color(0xFFf64e60);
                                                          return const Color(0xFF1DA1F2);
                                                        }(),
                                                          fontWeight: FontWeight.w500, 
                                                          fontSize: 15
                                                      ),
                                                        overflow: TextOverflow.ellipsis,
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 4),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Row(
                                                    crossAxisAlignment: CrossAxisAlignment.center,
                                                    children: [
                                                      SizedBox(
                                                        width: 100,
                                                        child: Text('Name', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                      ),
                                                      const SizedBox(width: 36),
                                                      Expanded(
                                                        child: Text((order['consignee_name'] ?? '').isEmpty ? '-' : (order['consignee_name'] ?? ''), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 4),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Row(
                                                    crossAxisAlignment: CrossAxisAlignment.center,
                                                    children: [
                                                      SizedBox(
                                                        width: 100,
                                                        child: Text(order['is_shipment'] == '1' ? 'Booking Date' : 'Order Date', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                      ),
                                                      const SizedBox(width: 36),
                                                      Expanded(
                                                        child: Text((() {
                                                          final dateField = order['is_shipment'] == '1' ? order['booking_date'] : order['created_at'];
                                                          return (dateField ?? '').isEmpty ? '-' : (dateField ?? '');
                                                        })(), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 4),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Row(
                                                    crossAxisAlignment: CrossAxisAlignment.center,
                                                    children: [
                                                      SizedBox(
                                                        width: 100,
                                                        child: Text('Order Ref', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                      ),
                                                      const SizedBox(width: 36),
                                                      Expanded(
                                                        child: Text((order['order_ref'] ?? '').toString().isEmpty ? '-' : order['order_ref']?.toString() ?? '', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 4),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Row(
                                                    crossAxisAlignment: CrossAxisAlignment.center,
                                                    children: [
                                                      SizedBox(
                                                        width: 100,
                                                        child: Text('Contact', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                      ),
                                                      const SizedBox(width: 36),
                                                      Expanded(
                                                        child: Text((order['consignee_contact'] ?? '').toString().isEmpty ? '-' : order['consignee_contact']?.toString() ?? '', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            const SizedBox(height: 4),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Row(
                                                    crossAxisAlignment: CrossAxisAlignment.center,
                                                    children: [
                                                      SizedBox(
                                                        width: 100,
                                                        child: Text('Order Amount', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                      ),
                                                      const SizedBox(width: 36),
                                                      Expanded(
                                                        child: Text((order['order_amount'] ?? '').toString().isEmpty ? '-' : 'Rs. ${order['order_amount']?.toString() ?? ''}', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                      ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            if (order['is_shipment'] != '0') ...[
                                              const SizedBox(height: 4),
                                              Row(
                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                children: [
                                                  Expanded(
                                                    child: Row(
                                                      crossAxisAlignment: CrossAxisAlignment.center,
                                                      children: [
                                                        SizedBox(
                                                          width: 100,
                                                          child: Text('CN', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                        ),
                                                        const SizedBox(width: 36),
                                                        Expanded(
                                                          child: Text((() {
                                                            final consignmentNo = order['consigment_no'];
                                                            
                                                            return (consignmentNo ?? '').toString().isEmpty ? '-' : consignmentNo?.toString() ?? '';
                                                          })(), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                        ),
                                                      ],
                                                    ),
                                                  ),
                                                ],
                                              ),
                                              if (order['is_shipment'] == '1' && order['account_title'] != null && order['account_title'].toString().isNotEmpty) ...[
                                                const SizedBox(height: 4),
                                                Row(
                                                  crossAxisAlignment: CrossAxisAlignment.start,
                                                  children: [
                                                    Expanded(
                                                      child: Row(
                                                        crossAxisAlignment: CrossAxisAlignment.center,
                                                        children: [
                                                          SizedBox(
                                                            width: 100,
                                                            child: Text('Account', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                          ),
                                                          const SizedBox(width: 36),
                                                          Expanded(
                                                            child: Text(order['account_title'].toString(), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                                          ),
                                                        ],
                                                      ),
                                                    ),
                                                  ],
                                                ),
                                              ],
                                              const SizedBox(height: 4),
                                              Row(
                                                crossAxisAlignment: CrossAxisAlignment.start,
                                                children: [
                                                  Expanded(
                                                    child: Row(
                                                      crossAxisAlignment: CrossAxisAlignment.center,
                                                      children: [
                                                        SizedBox(
                                                          width: order['courier_name'] != null && 
                                                                 order['courier_name'].toString().length > 10 
                                                               ? 113 
                                                               : 98,
                                                          child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                        ),
                                                        const SizedBox(width: 26),
                                                        order['courier_name'] != null && order['courier_name'].toString().isNotEmpty
                                                        ? (() {
                                                            final courierName = order['courier_name'].toString();
                                                            final pngUrl = '${ApiConfig.assetPngBaseUrl}${Uri.encodeComponent(courierName.trim())}.png';
                                                            
                                                            
                                                            if (courierName.toLowerCase() == 'bluex') {
                                                              
                                                              return const SizedBox(height: 24); 
                                                            }
                                                            return (() {
                                                              final isManaged = courierName.toLowerCase().trim() == 'managed';
                                                              final courierId = order['courier_id']?.toString();
                                                              
                                                              
                                                              
                                                              return CourierLogoWidget(
                                                                pngUrl: courierName,
                                                                courierId: courierId,
                                                                accountTitle: order['account_title']?.toString(),
                                                                width: 78,
                                                                height: 36,
                                                                fit: BoxFit.contain,
                                                              );
                                                            })();
                                                          })()
                                                        : const SizedBox(height: 24),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),
                                            ],
                                            const SizedBox(height: 4),
                                            Row(
                                              crossAxisAlignment: CrossAxisAlignment.start,
                                              children: [
                                                Expanded(
                                                  child: Row(
                                                    crossAxisAlignment: CrossAxisAlignment.center,
                                                    children: [
                                                      if ((order['is_shipment'] != '1' && (order['status']?.toString().toLowerCase() != 'cancelled')) || 
                                                          (order['is_shipment'] == '1' && (order['status']?.toString().toLowerCase() != 'cancelled')))
                                                        Row(
                                                          crossAxisAlignment: CrossAxisAlignment.center,
                                                          children: [
                                                            SizedBox(
                                                              width: 100,
                                                              child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                                            ),
                                                            const SizedBox(width: 36),
                                                            
                                                            if (order['is_shipment'] != '1')
                                                              GestureDetector(
                                                                onTap: () async {
                                                                  
                                                                  setState(() {
                                                                    selectedOrders.clear();
                                                                    selectAll = false;
                                                                  });
                                                                  final result = await Get.to(() => QuickEditScreen(order: order));
                                                                  if (result == true) {
                                                                    await fetchOrders(reset: true, force: true);
                                                                    setState(() {});
                                                                  }
                                                                },
                                                                child: Row(
                                                                  children: [
                                                                    SvgPicture.asset(
                                                                      'assets/Edit.svg',
                                                                      width: 20,
                                                                      height: 20,
                                                                      color: const Color(0xFF007AFF),
                                                                    ),
                                                                    const SizedBox(width: 4),
                                                                    Text('Edit', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                                  ],
                                                                ),
                                                              ),
                                                            
                                                            if (order['is_shipment'] != '1')
                                                              const SizedBox(width: 24),
                                                            
                                                            GestureDetector(
                                                              onTap: () async {
                                                                final confirmed = await showModalBottomSheet<bool>(
                                                                  context: context,
                                                                  isScrollControlled: true,
                                                                  backgroundColor: Colors.transparent,
                                                                  builder: (context) => _DeleteConfirmationBottomSheet(),
                                                                );
                                                                if (confirmed == true) {
                                                                  await _deleteOrder(order['id'].toString(), order: order);
                                                                }
                                                              },
                                                              child: Row(
                                                                children: [
                                                                  SvgPicture.asset(
                                                                    'assets/Delete.svg',
                                                                    width: 18,
                                                                    height: 18,
                                                                    color: const Color(0xFF007AFF),
                                                                  ),
                                                                  const SizedBox(width: 4),
                                                                  Text('Delete', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                                                ],
                                                              ),
                                                            ),
                                                          ],
                                                        ),
                                                    ],
                                                  ),
                                                ),
                                              ],
                                            ),

                                            const SizedBox(height: 12), 
                                            GestureDetector(
                                              onTap: () {
                                                _showOrderDetailsBottomSheet(context, order);
                                              },
                                              child: Text(
                                                'View Details',
                                                style: GoogleFonts.inter(
                                                  color: const Color(0xFF007AFF),
                                                  fontWeight: FontWeight.w500,
                                                  fontSize: 14,
                                                  decoration: TextDecoration.none,
                                                ),
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                      const SizedBox(height: 8), 
                                    ],
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                      ),
                ),
              ),
            ],
          ),
        ),
      ),
              bottomNavigationBar: AppBottomBar(
                selectedIndex: 1,
                onHomeTap: () => Get.offAll(() => dash.DashboardScreen()),
                onOrderListTap: () {}, 
                onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'order_list')),
                onMenuTap: () => Get.offAll(() => menu.MenuScreen()),
              ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.offAll(() => create_order.CreateOrderScreen(from: 'order_list'));
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
         child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
      ),
    ),
    );
  }

  void _showOrderDetailsBottomSheet(BuildContext context, dynamic order) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: AnimationLimiter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: AnimationConfiguration.toStaggeredList(
                    duration: const Duration(milliseconds: 500),
                    childAnimationBuilder: (widget) => SlideAnimation(
                      verticalOffset: 30.0,
                      child: FadeInAnimation(
                        child: widget,
                      ),
                    ),
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            children: [
                              const Text(
                                'Order Details',
                                style: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  fontSize: 18,
                                  fontFamily: 'SF Pro Display',
                                ),
                              ),
                              const SizedBox(width: 12),
                              Container(
                                constraints: const BoxConstraints(minWidth: 70, maxWidth: 100),
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                decoration: BoxDecoration(
                                  color: () {
                                    final status = order['status']?.toString().toLowerCase().trim();
                                    if (status == 'cancelled') return Colors.red.withOpacity(0.1);
                                    if (status == 'booked') return const Color(0xFF8e24aa).withOpacity(0.1);
                                    if (status == 'new') return const Color(0xFF1DA1F2).withOpacity(0.1);
                                    if (status == 'pickup ready') return const Color(0xFF43A047).withOpacity(0.1);
                                    if (status == 'in transit') return const Color(0xFFea7317).withOpacity(0.1);
                                    if (status == 'out for delivery') return const Color(0xFFf2d016).withOpacity(0.1);
                                    if (status == 'delivered')  return const Color(0xFF43A047).withOpacity(0.1);
                                    if (status == 'shipped') return const Color(0xFF4191ff).withOpacity(0.1);
                                    if (status == 'onroute') return const Color(0xFFf2d016).withOpacity(0.1);
                                    if (status == 'accepted') return const Color(0xFF9b51e0).withOpacity(0.1);
                                    if (status == 'rejected') return const Color(0xFFff7400).withOpacity(0.1);
                                    if (status == 'returned') return const Color(0xFFf83245).withOpacity(0.1);
                                    if (status == 'replacement') return const Color(0xFF66cccc).withOpacity(0.1);
                                    if (status == 'error' || status == 'badge-error') return const Color(0xFFf64e60).withOpacity(0.1);
                                    return const Color(0xFF1DA1F2).withOpacity(0.1);                                            
                                  }(),
                                  borderRadius: BorderRadius.circular(16),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  order['status']?.toString().capitalize ?? '',
                                  style: GoogleFonts.inter(
                                  color: () {
                                    final status = order['status']?.toString().toLowerCase();
                                    if (status == 'cancelled') return Colors.red;
                                    if (status == 'booked') return Color(0xFF8e24aa); 
                                    if (status == 'new') return Color(0xFF1DA1F2); 
                                    if (status == 'pickup ready') return Color(0xFF43A047);
                                    if (status == 'in transit') return const Color(0xFFea7317);
                                    if (status == 'out for delivery') return const Color(0xFFf2d016);
                                    if (status == 'delivered')  return Color(0xFF43A047);
                                    if (status == 'shipped') return const Color(0xFF4191ff);
                                    if (status == 'onroute') return const Color(0xFFf2d016);
                                    if (status == 'accepted') return const Color(0xFF9b51e0);
                                    if (status == 'rejected') return const Color(0xFFff7400);
                                    if (status == 'returned') return const Color(0xFFf83245);
                                    if (status == 'replacement') return const Color(0xFF66cccc);
                                    if (status == 'error' || status == 'badge-error') return const Color(0xFFf64e60);
                                    return const Color(0xFF1DA1F2);
                                  }(),
                                    fontWeight: FontWeight.w500, 
                                    fontSize: 15
                                ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                          IconButton(
                            icon: const Icon(Icons.close_rounded),
                            onPressed: () => Navigator.of(context).pop(),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      
                      _orderDetailRow('Order ID', order['id']?.toString() ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Name', order['consignee_name'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Contact', order['consignee_contact'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Address', order['consignee_address'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('CN', order['consigment_no'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Order Amount', order['order_amount'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Booking Date', order['booking_date'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Create Date', order['created_at'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Store Name', order['store_name'] ?? ''),
                      if (order['is_shipment'] != '0') ...[
                        SizedBox(height: 10),
                        _orderDetailRow('Courier Name', order['courier_name'] ?? ''),
                      ],
                      SizedBox(height: 10),
                      _orderDetailRow('Payment Type', order['payment_type'] ?? ''),
                      SizedBox(height: 10),
                      _orderDetailRow('Tags', order['tags_name'] ?? ''),
                      SizedBox(height: 12),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          if (order['is_shipment'] != '0') ...[
                            SizedBox(
                              width: 90,
                              child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 15)),
                            ),
                            const SizedBox(width: 36),
                            GestureDetector(
                              onTap: () async {
                                String? acno = Get.find<AuthService>().getCurrentAcno();
                                if (acno == null || acno.isEmpty) {
                                  customSnackBar('Error', 'Account number not found. Please log in again.');
                                  return;
                                }
                                final int orderId = int.tryParse(order['id']?.toString() ?? '') ?? 0;
                                final String consignmentNo = order['consigment_no']?.toString() ?? '';
                                if (orderId == 0) {
                                  customSnackBar('Error', 'Order ID not found.');
                                  return;
                                }
                                if (consignmentNo.isEmpty) {
                                  customSnackBar('Error', 'Consignment No not found.');
                                  return;
                                }
                                final orderService = OrderService();
                                showDialog(
                                  context: context,
                                  barrierDismissible: false,
                                  builder: (_) => Center(child: CircularProgressIndicator()),
                                );
                                try {
                                  final payload = await orderService.fetchTrackingDetails(
                                    acno: acno,
                                    orderId: orderId,
                                    consignmentNo: consignmentNo,
                                  );
                                  Navigator.pop(context); 
                                  showModalBottomSheet(
                                    context: context,
                                    isScrollControlled: true,
                                    backgroundColor: Colors.transparent,
                                    builder: (context) {
                                      return Container(
                                        width: double.infinity,
                                        padding: EdgeInsets.only(
                                          left: 0,
                                          right: 0,
                                          bottom: MediaQuery.of(context).viewInsets.bottom,
                                        ),
                                        decoration: BoxDecoration(
                                          color: Colors.white,
                                          borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
                                          boxShadow: [],
                                        ),
                                        child: TrackingDetailsDialog(payload: payload!),
                                      );
                                    },
                                  );
                                } catch (e) {
                                  Navigator.pop(context); 
                                  showDialog(
                                    context: context,
                                    builder: (_) => AlertDialog(
                                      title: Text('Error'),
                                      content: Text(e.toString()),
                                    ),
                                  );
                                }
                              },
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  SvgPicture.asset(
                                    'assets/Tracking.svg',
                                    width: 20,
                                    height: 20,
                                    color: const Color(0xFF007AFF),
                                  ),
                                  const SizedBox(width: 4),
                                  Text('Tracking', style: GoogleFonts.inter(color: Color(0xFF007AFF), fontWeight: FontWeight.w500)),
                                ],
                              ),
                            ),
                          ],
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _orderDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(label, style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14)),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }

  String _getDateRangeText() {
    final days = _endDate.difference(_startDate).inDays;
    final start = '${_startDate.day.toString().padLeft(2, '0')}-${_startDate.month.toString().padLeft(2, '0')}-${_startDate.year}';
    final end = '${_endDate.day.toString().padLeft(2, '0')}-${_endDate.month.toString().padLeft(2, '0')}-${_endDate.year}';
    return ' $start to $end';
  }

  Future<void> _manualRefresh() async {
    setState(() { selectedOrders.clear(); });
    setState(() { _isRefreshing = true; });
    await fetchOrders(reset: true, force: true);
    setState(() { _isRefreshing = false; });
  }

  void _showChangeStatusDialog(BuildContext context, List<dynamic> orders) async {
    Map<String, dynamic>? selectedStatus;

    
    final statusResult = await showModalBottomSheet<Map<String, dynamic>>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (ctx) => _StatusSelectDialog(
        items: const [], 
        initialValue: null,
        title: 'Select Status',
      ),
    );

    if (statusResult == null) return; 

    selectedStatus = statusResult;

    
    final user = _authService.currentUser.value;
    final acno = user?.acno ?? '';

    if (acno.isEmpty) {
      customSnackBar('Error', 'Account number not found. Please log in again.');
      return;
    }

    try {
      final dio = Dio();
      
      
      for (final order in orders) {
        final orderId = int.tryParse(order['id']?.toString() ?? '');
        final statusId = selectedStatus!['id'] as int?;
        
        if (orderId == null || statusId == null) {
          customSnackBar('Error', 'Invalid order ID or status ID.');
          return;
        }

        final requestBody = {
          "acno": acno,
          "order_id": orderId,
          "status_id": statusId,
        };

        final response = await dio.post(
          ApiConfig.getEndpointUrl(ApiConfig.updateStatusEndpoint),
          data: requestBody,
          options: Options(
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ${user?.apiKey ?? ''}',
            },
          ),
        );

        if (response.statusCode != 200 || (response.data['status'] != 1 && response.data['success'] != true)) {
          customSnackBar('Error', 'Failed to update status for order ${order['id']}: ${response.data['message'] ?? response.data['error'] ?? 'Unknown error'}');
          return;
        }
      }

      customSnackBar('Success', 'Status updated successfully for ${orders.length} order${orders.length > 1 ? 's' : ''}!');
      
      setState(() {
        selectedOrders.clear();
        selectAll = false;
      });
      await fetchOrders(reset: true);
      await fetchReportSummary();
    } catch (e) {
      customSnackBar('Error', e.toString());
    }
  }
}

class _StatusSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _StatusSelectDialog({Key? key, required this.items, required this.initialValue, required this.title}) : super(key: key);

  @override
  State<_StatusSelectDialog> createState() => _StatusSelectDialogState();
}

class _StatusSelectDialogState extends State<_StatusSelectDialog> {
  String? selected;
  String _search = '';
  List<Map<String, dynamic>> statusOptions = [];
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
    _fetchStatusOptions();
  }

  Future<void> _fetchStatusOptions() async {
    try {
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.commonStatusEndpoint),
        data: {"status_type": "Customer Service"},
        options: Options(
          headers: {'Content-Type': 'application/json'},
        ),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        final List<dynamic> data = response.data is List
            ? response.data
            : (response.data['data'] ?? []);
        setState(() {
          statusOptions = data.map((s) => {
            'name': (s['name'] ?? s['status_name'] ?? '').toString(),
            'id': int.tryParse(s['id']?.toString() ?? '') ?? 0,
          }).where((s) => (s['name'] as String).isNotEmpty && (s['id'] as int) > 0).toList();
          isLoading = false;
        });
      } else {
        
        setState(() {
          statusOptions = [];
          isLoading = false;
        });
      }
    } catch (e) {
      
      setState(() {
        statusOptions = [];
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = statusOptions.where((item) => item['name']!.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: AnimationLimiter(
              child: SingleChildScrollView(
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: AnimationConfiguration.toStaggeredList(
                      duration: const Duration(milliseconds: 400),
                      childAnimationBuilder: (widget) => SlideAnimation(
                        verticalOffset: 30.0,
                        child: FadeInAnimation(
                          child: widget,
                        ),
                      ),
                      children: [
                        Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                        const SizedBox(height: 12),
                        TextField(
                          decoration: InputDecoration(
                            hintText: 'Search status...',
                            prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                            border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                          ),
                          onChanged: (val) => setState(() => _search = val),
                        ),
                        const SizedBox(height: 12),
                        SizedBox(
                          height: 300,
                          child: isLoading
                              ? const Center(child: CircularProgressIndicator())
                              : filteredItems.isEmpty
                                  ? const Center(child: Text('No status options found'))
                                  : ListView.separated(
                                      itemCount: filteredItems.length,
                                      separatorBuilder: (_, __) => Container(
                                        height: 1,
                                        color: Colors.black.withOpacity(0.08),
                                        margin: const EdgeInsets.symmetric(horizontal: 8),
                                      ),
                                      itemBuilder: (context, i) {
                                        final item = filteredItems[i];
                                        final isSelected = selected == item['name'];
                                        return ListTile(
                                          title: Text(item['name']!),
                                          trailing: isSelected
                                              ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                              : null,
                                          onTap: () {
                                            setState(() {
                                              selected = item['name'];
                                            });
                                            Navigator.of(context).pop(item);
                                          },
                                          selected: isSelected,
                                          selectedTileColor: const Color(0xFFE6F0FF),
                                          shape: RoundedRectangleBorder(
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                        );
                                      },
                                    ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _SummaryColumn extends StatelessWidget {
  final String label;
  final String value;
  const _SummaryColumn({required this.label, required this.value});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(value, style: const TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w500, fontSize: 16, color: Colors.black)),
        const SizedBox(height: 2),
        Text(label, style: const TextStyle(fontFamily: 'SF Pro Display', fontWeight: FontWeight.w300, fontSize: 12, color: Color(0xFF8E8E93))),
      ],
    );
  }
}



class _DeleteConfirmationBottomSheet extends StatelessWidget {
  const _DeleteConfirmationBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(32),
              child: SvgPicture.asset(
                'assets/Delete.svg',
                width: 64,
                height: 64,
                color: const Color(0xFF007AFF),
              ),
            ),
            const SizedBox(height: 24),
            const Text(
              'Are you Sure?',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
            ),
            const SizedBox(height: 8),
            const Text(
              'You want to delete this order',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(false),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFFF3F4F6),
                      foregroundColor: const Color(0xFF111827),
                      elevation: 0,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: const Text('Cancel', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15)),
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => Navigator.of(context).pop(true),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: const Color(0xFF007AFF),
                      elevation: 0,
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                      padding: const EdgeInsets.symmetric(vertical: 14),
                    ),
                    child: const Text('Delete', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

 import 'package:flutter/material.dart';
import 'package:dio/dio.dart';
import 'package:get/get.dart';
import 'dart:convert';
import 'dashboard_screen.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;
import 'change_password_screen.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../services/auth_service.dart';
import '../services/statement_service.dart';
import '../models/user_model.dart';
import '../utils/custom_snackbar.dart';
import '../config/api_config.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';
import 'create_order.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../widgets/transition.dart';


class ProfileScreen extends StatefulWidget {
  const ProfileScreen({Key? key}) : super(key: key);

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}


class _BankSearchDialog extends StatefulWidget {
  final List<Map<String, dynamic>> banks;
  final Map<String, dynamic>? initialBank;
  const _BankSearchDialog({Key? key, required this.banks, this.initialBank}) : super(key: key);

  @override
  State<_BankSearchDialog> createState() => _BankSearchDialogState();
}

class _BankSearchDialogState extends State<_BankSearchDialog> {
  late List<Map<String, dynamic>> filteredBanks;
  late TextEditingController searchController;
  Map<String, dynamic>? selected;

  @override
  void initState() {
    super.initState();
    filteredBanks = widget.banks;
    searchController = TextEditingController();
    selected = widget.initialBank;
    searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      final query = searchController.text.toLowerCase();
      filteredBanks = widget.banks.where((b) => b['name'].toString().toLowerCase().contains(query)).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: SingleChildScrollView(
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Text('Select Bank', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                    const SizedBox(height: 12),
                    TextField(
                      controller: searchController,
                      decoration: InputDecoration(
                        hintText: 'Search bank...',
                        prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                        contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 12),
                      ),
                    ),
                    const SizedBox(height: 12),
                    SizedBox(
                      height: 300,
                      child: filteredBanks.isEmpty
                          ? const Center(child: Text('No banks found.', style: TextStyle(color: Colors.grey)))
                          : AnimatedListViewSeparated(
                              itemCount: filteredBanks.length,
                              separatorBuilder: (_, __) => Container(
                                height: 1,
                                color: Colors.black.withOpacity(0.08),
                                margin: const EdgeInsets.symmetric(horizontal: 8),
                              ),
                              itemBuilder: (context, i) {
                                final bank = filteredBanks[i];
                                final isSelected = selected != null && bank['id'] == selected!['id'];
                                return ListTile(
                                  title: Text(
                                    bank['name'] ?? '',
                                    style: TextStyle(
                                      color: isSelected ? Colors.black : Colors.black,
                                      fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                                    ),
                                  ),
                                  selected: isSelected,
                                  selectedTileColor: const Color(0xFFE6F0FF),
                                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                  onTap: () {
                                    Navigator.of(context).pop(bank);
                                  },
                                  trailing: isSelected ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18) : null,
                                );
                              },
                            ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

Widget _profileField(String label, TextEditingController controller, bool isEditing, {bool hasError = false}) {
  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      Text(
        label,
        style: TextStyle(
          fontFamily: 'SF Pro Display',
          fontWeight: FontWeight.w500,
          fontSize: 14,
          color: hasError ? Colors.red : Colors.black,
        ),
      ),
      const SizedBox(height: 4),
      Container(
        margin: const EdgeInsets.only(bottom: 8),
        decoration: BoxDecoration(
          color: const Color(0xFFF5F5F7),
          borderRadius: BorderRadius.circular(10),
          border: Border.all(
            color: Colors.transparent,
            width: 1,
          ),
        ),
        child: TextField(
          enabled: isEditing,
          controller: controller,
          decoration: const InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          ),
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w400,
            fontSize: 15,
            color: hasError ? Colors.red : Colors.black,
          ),
        ),
      ),
    ],
  );
}

void _showProfileUpdateSuccessDialog(BuildContext context) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    backgroundColor: Colors.transparent,
    builder: (context) {
      return Container(
        width: double.infinity,
        padding: EdgeInsets.only(
          left: 0,
          right: 0,
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
        ),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                decoration: BoxDecoration(
                  color: const Color(0xFFE6F0FF),
                  shape: BoxShape.circle,
                ),
                padding: const EdgeInsets.all(32),
                child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
              ),
              const SizedBox(height: 24),
              const Text(
                'Success!',
                style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
              ),
              const SizedBox(height: 8),
              const Text(
                'Profile updated successfully',
                style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              ),
              const SizedBox(height: 28),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () => Navigator.of(context).pop(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF007AFF),
                    elevation: 0,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                    padding: const EdgeInsets.symmetric(vertical: 14),
                  ),
                  child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                ),
              ),
            ],
          ),
        ),
      );
    },
  );
}

class _ProfileScreenState extends State<ProfileScreen> {
  Map<String, dynamic>? profileData;
  bool isLoading = true;
  bool isEditing = false;
  bool isUpdating = false;
  String? error;
  bool _dialogShown = false;
  final AuthService _authService = Get.find<AuthService>();

  
  final TextEditingController firstNameController = TextEditingController();
  final TextEditingController lastNameController = TextEditingController();
  final TextEditingController emailController = TextEditingController();
  final TextEditingController phoneController = TextEditingController();
  final TextEditingController addressController = TextEditingController();
  final TextEditingController cnicController = TextEditingController();
  final TextEditingController cnicExpiryController = TextEditingController();
  final TextEditingController businessNameController = TextEditingController();
  final TextEditingController businessAddressController = TextEditingController();
  final TextEditingController ntnController = TextEditingController();
  final TextEditingController accountTitleController = TextEditingController();
  final TextEditingController accountNumberController = TextEditingController();
  final TextEditingController ibanController = TextEditingController();

  
  Map<String, bool> fieldErrors = {};

  Map<String, dynamic>? selectedBank;
  List<Map<String, dynamic>> banks = [];
  bool _isLoadingBanks = false;
  String? _bankError;

  
  XFile? _cnicImage;
  final ImagePicker _picker = ImagePicker();
  bool _removeCurrentCnic = false;

  Future<void> _pickCnicImage() async {
    final XFile? image = await _picker.pickImage(source: ImageSource.gallery);
    if (image != null) {
      setState(() {
        _cnicImage = image;
      });
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('cnic_image_path', image.path);
    }
  }

  void _removeCnicImage() {
    setState(() {
      _cnicImage = null;
    });
    // Clear the stored path
    SharedPreferences.getInstance().then((prefs) {
      prefs.remove('cnic_image_path');
    });
  }

  void _removeCurrentCnicImage() {
    // Show confirmation dialog
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove CNIC Image'),
        content: const Text('Are you sure you want to remove the current CNIC image? This action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              // Set a flag to indicate current CNIC should be removed
              setState(() {
                _removeCurrentCnic = true;
              });
            },
            child: const Text('Remove', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  void _showCnicImageFullScreen() {
    if (profileData?['cnic_image'] != null && profileData!['cnic_image'].toString().isNotEmpty) {
      showDialog(
        context: context,
        builder: (context) => Dialog(
          backgroundColor: Colors.transparent,
          child: Stack(
            children: [
              // Full screen image
              Center(
                child: InteractiveViewer(
                  child: Image.network(
                    getCnicImageUrl(profileData!['cnic_image'], profileData!['acno']),
                    fit: BoxFit.contain,
                    errorBuilder: (context, error, stackTrace) => const Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.broken_image, size: 64, color: Colors.white),
                          SizedBox(height: 16),
                          Text(
                            'Failed to load image',
                            style: TextStyle(color: Colors.white, fontSize: 16),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              // Close button
              Positioned(
                top: 40,
                right: 20,
                child: Container(
                  decoration: const BoxDecoration(
                    color: Colors.black54,
                    shape: BoxShape.circle,
                  ),
                  child: IconButton(
                    icon: const Icon(Icons.close_rounded, color: Colors.white),
                    onPressed: () => Navigator.of(context).pop(),
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }
  }

  @override
  void initState() {
    super.initState();
    _loadCnicImageFromPrefs();
    _loadUserDataAndFetchProfile();
    _fetchBanks();
  }

  Future<void> _loadCnicImageFromPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final path = prefs.getString('cnic_image_path');
    if (path != null && path.isNotEmpty) {
      setState(() {
        _cnicImage = XFile(path);
      });
    }
  }

  Future<void> _loadUserDataAndFetchProfile() async {
    
    if (_authService.currentUser.value == null) {
      await _authService.loadUserData();
    }
    await fetchProfile();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final args = Get.arguments;
    if (!_dialogShown && args != null && args['showSuccess'] == true) {
      _dialogShown = true;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _showProfileUpdateSuccessDialog(context);
      });
    }
  }

  Future<void> fetchProfile() async {
    setState(() {
      isLoading = true;
      error = null;
    });
    try {
      
      final userData = _authService.getCurrentUserData();
      if (userData == null) {
        setState(() {
          error = 'User not logged in.';
          isLoading = false;
        });
        return;
      }

      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.profileEndpoint),
        data: userData,
      );
      if (response.data['status'] == 1 && response.data['payload'] is List && response.data['payload'].isNotEmpty) {
        setState(() {
          profileData = response.data['payload'][0];
          _populateControllers();
          isLoading = false;
        });
      } else {
        setState(() {
          error = 'No profile data found.';
          isLoading = false;
        });
      }
    } catch (e) {
      setState(() {
        error = 'Failed to load profile.';
        isLoading = false;
      });
    }
  }

  void _populateControllers() {
    if (profileData != null) {
      
      
      firstNameController.text = profileData!['first_name'] ?? '';
      lastNameController.text = profileData!['last_name'] ?? '';
      emailController.text = profileData!['email'] ?? '';
      phoneController.text = profileData!['phone'] ?? '';
      addressController.text = profileData!['address'] ?? '';
      cnicController.text = profileData!['cnic'] ?? '';
      cnicExpiryController.text = profileData!['cnic_expiry'] ?? '';
      businessNameController.text = profileData!['business_name'] ?? '';
      businessAddressController.text = profileData!['business_address'] ?? '';
      ntnController.text = profileData!['ntn'] ?? '';
      accountTitleController.text = profileData!['account_title'] ?? '';
      accountNumberController.text = profileData!['account_number'] ?? '';
     String ibanValue = (profileData!['iban'] ?? '').toString();
     ibanController.text = (ibanValue.trim().isEmpty || ibanValue.trim() == '0') ? '' : ibanValue;

      
      if (profileData!['bank_id'] != null && banks.isNotEmpty) {
        try {
          selectedBank = banks.firstWhere(
            (b) => b['id'].toString() == profileData!['bank_id'].toString(),
          );

        } catch (e) {

          selectedBank = null;
        }
      } else {
       
        selectedBank = null;
      }
    }
  }

  Future<void> _fetchBanks() async {
    setState(() {
      _isLoadingBanks = true;
      _bankError = null;
    });
    try {
      final service = StatementService();
      final bankData = await service.fetchBanks(1); 
      setState(() {
        banks = bankData;
        _isLoadingBanks = false;
      });
      
      // Re-populate controllers after banks are loaded to ensure bank name is displayed
      if (profileData != null) {
        _populateControllers();
      }
    } catch (e) {
      setState(() {
        _bankError = 'Failed to load banks: $e';
        _isLoadingBanks = false;
      });
    }
  }

  Future<void> _updateProfile() async {
    
    Map<String, bool> errors = {};
    List<String> errorMessages = [];
    String email = emailController.text.trim();
    String phone = phoneController.text.trim();
    String cnic = cnicController.text.trim();
    String iban = ibanController.text.trim();
    String ntn = ntnController.text.trim();

    if (firstNameController.text.trim().isEmpty) errors['First Name'] = true;
    if (lastNameController.text.trim().isEmpty) errors['Last Name'] = true;
    if (email.isEmpty) {
      errors['Email'] = true;
      errorMessages.add('Email is required');
    } else if (!RegExp(r'^[\w\.-]+@[\w\.-]+\.\w{2,}').hasMatch(email)) {
      errors['Email'] = true;
      errorMessages.add('Invalid email format');
    }
    if (phone.isEmpty) {
      errors['Phone No'] = true;
      errorMessages.add('Phone number is required');
    } else if (!RegExp(r'^\d{11}$').hasMatch(phone)) {
      errors['Phone No'] = true;
      errorMessages.add('Phone number must be 11 digits');
    }
    if (addressController.text.trim().isEmpty) errors['Address'] = true;
    if (cnic.isEmpty) {
      errors['CNIC'] = true;
      errorMessages.add('CNIC is required');
    } else if (!RegExp(r'^(\d{13}|\d{5}-\d{7}-\d{1})$').hasMatch(cnic)) {
      errors['CNIC'] = true;
      errorMessages.add('CNIC must be 13 digits or in XXXXX-XXXXXXX-X format');
    }
    if (cnicExpiryController.text.trim().isEmpty) errors['CNIC Expiry Date'] = true;
    if (businessNameController.text.trim().isEmpty) errors['Business Name'] = true;
    if (businessAddressController.text.trim().isEmpty) errors['Business Address'] = true;
    if (ntn.isEmpty) {
      errors['NTN'] = true;
      errorMessages.add('NTN is required');
    } else if (!RegExp(r'^(\d{7}|\d{12})$').hasMatch(ntn)) {
      errors['NTN'] = true;
      errorMessages.add('NTN must be 7 or 12 digits');
    }
    if (accountTitleController.text.trim().isEmpty) errors['Account Title'] = true;
    if (accountNumberController.text.trim().isEmpty) errors['Account Number'] = true;
    
    // Check if selected bank is a wallet bank
    final bankName = (selectedBank?['name']?.toString() ?? '').toLowerCase();
    final isWallet = bankName.contains('easypaisa') || bankName.contains('jazzcash') || bankName.contains('sadapay') || bankName.contains('nayapay');
    
    
    
    // Only validate IBAN if it's not a wallet bank
    if (!isWallet) {
      
      if (iban.isEmpty) {
        errors['IBAN Number'] = true;
        errorMessages.add('IBAN is required');
      } else if (!RegExp(r'^[A-Za-z0-9]{16,24}$').hasMatch(iban)) {
        errors['IBAN Number'] = true;
        errorMessages.add('IBAN must be 16-24 alphanumeric characters');
      }
    } else {
      
    }
    setState(() {
      fieldErrors = errors;
    });
    if (errors.isNotEmpty) {
      customSnackBar('Error', errorMessages.isNotEmpty ? errorMessages.join('\n') : 'Please fill all required fields correctly');
      return;
    }

    setState(() {
      isUpdating = true;
    });

    try {
      final currentUser = _authService.currentUser.value;
      if (currentUser == null) {
        customSnackBar('Error', 'User not logged in.');
        return;
      }

      
      String cnicImageBase64 = '';
      
      // Check if user wants to remove current CNIC image
      if (_removeCurrentCnic) {
        cnicImageBase64 = ''; // Empty string to remove CNIC image
      } else if (_cnicImage != null) {
        // New CNIC image selected
        try {
          final bytes = await _cnicImage!.readAsBytes();
          cnicImageBase64 = 'data:image/jpeg;base64,${base64Encode(bytes)}';
        } catch (e) {
         
          customSnackBar('Error', 'Failed to process CNIC image');
          return;
        }
      } else if (profileData?['cnic_image'] != null && profileData!['cnic_image'].toString().isNotEmpty) {
        // If existing CNIC image is already in base64 format, use it as is
        if (profileData!['cnic_image'].toString().startsWith('data:image')) {
          cnicImageBase64 = profileData!['cnic_image'];
        } else {
          // If existing CNIC image is a filename, we need to fetch it and convert to base64
          try {
            final cnicImageUrl = getCnicImageUrl(profileData!['cnic_image'], profileData!['acno']);
            if (cnicImageUrl.isNotEmpty) {
              final response = await Dio().get(cnicImageUrl, options: Options(responseType: ResponseType.bytes));
              if (response.statusCode == 200) {
                cnicImageBase64 = 'data:image/jpeg;base64,${base64Encode(response.data)}';
              } else {
                // Fallback to existing image data
                cnicImageBase64 = profileData!['cnic_image'];
              }
            } else {
              // Fallback to existing image data
              cnicImageBase64 = profileData!['cnic_image'];
            }
          } catch (e) {
            
            // Fallback to existing image data
            cnicImageBase64 = profileData!['cnic_image'];
          }
        }
      } else {
        // No CNIC image
        cnicImageBase64 = '';
      }

      final bankName = (selectedBank?['name']?.toString() ?? '').toLowerCase();
      final isWallet = bankName.contains('easypaisa') || bankName.contains('jazzcash') || bankName.contains('sadapay') || bankName.contains('nayapay');

      final profile = CustomerProfile(
        customerId: currentUser.customerId,
        acno: currentUser.acno,
        email: emailController.text.trim(),
        firstName: firstNameController.text.trim(),
        lastName: lastNameController.text.trim(),
        phone: phoneController.text.trim(),
        address: addressController.text.trim(),
        cnic: cnicController.text.trim(),
        cnicExpiry: cnicExpiryController.text.trim(),
        cnicImage: cnicImageBase64,
        hostingReceipt: profileData?['hosting_receipt'] ?? '',
        businessName: businessNameController.text.trim(),
        businessAddress: businessAddressController.text.trim(),
        ntn: ntnController.text.trim(),
        accountTitle: accountTitleController.text.trim(),
        accountNumber: accountNumberController.text.trim(),
        iban: isWallet ? '0' : ibanController.text.trim(),
        bankId: selectedBank != null ? int.tryParse(selectedBank!['id'].toString()) ?? 0 : 0,
        isBase64: '1', 
        onboardType: profileData?['onboard_type'] ?? '',
      );

      final success = await _authService.updateCustomerProfile(profile);

      if (success) {
        customSnackBar('Success', 'Profile updated successfully!');
        
        // Clear temporary CNIC image and reset flags after successful update
        _cnicImage = null;
        _removeCurrentCnic = false;
        SharedPreferences.getInstance().then((prefs) {
          prefs.remove('cnic_image_path');
        });
        
        setState(() {
          isEditing = false;
        });
        
        
        await fetchProfile();
      } else {
        customSnackBar('Error', _authService.errorMessage.value);
      }
    } catch (e) {
      customSnackBar('Error', 'Failed to update profile: ${e.toString()}');
    } finally {
      setState(() {
        isUpdating = false;
      });
    }
  }

  String getCnicImageUrl(String? cnicImage, String? acno) {
    if (cnicImage == null || cnicImage.isEmpty || acno == null || acno.isEmpty) return '';
    return 'https://oms.getorio.com/uploads/$acno/$cnicImage';
  }

  @override
  Widget build(BuildContext context) {
    final String bankNameLower = (selectedBank?['name']?.toString() ?? '').toLowerCase();
    final bool isWalletBank = bankNameLower.contains('easypaisa') || bankNameLower.contains('jazzcash') || bankNameLower.contains('sadapay') || bankNameLower.contains('nayapay');
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        backgroundColor: Colors.white,
        
        foregroundColor: Colors.white,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: const Text(
          'Profile',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
        actions: [
          if (!isLoading && error == null)
            IconButton(
              icon: Icon(
                isEditing ? Icons.close_rounded : Icons.edit_rounded,
                color: Colors.black,
              ),
              onPressed: () {
                setState(() {
                  if (isEditing) {
                    // Cancel editing - restore original data and clear new image
                    _populateControllers();
                    _cnicImage = null;
                    _removeCurrentCnic = false;
                    // Clear stored path
                    SharedPreferences.getInstance().then((prefs) {
                      prefs.remove('cnic_image_path');
                    });
                  }
                  isEditing = !isEditing;
                });
              },
            ),
        ],
      ),
      body: isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
          : error != null
              ? Center(child: Text(error!))
              : SingleChildScrollView(
                  padding: const EdgeInsets.only(left: 16, right: 16, top: 16, bottom: 80),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      _profileField('First Name', firstNameController, isEditing, hasError: fieldErrors['First Name'] == true),
                      _profileField('Last Name', lastNameController, isEditing, hasError: fieldErrors['Last Name'] == true),
                      // Email field - always read-only
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Email',
                            style: TextStyle(
                              fontFamily: 'SF Pro Display',
                              fontWeight: FontWeight.w500,
                              fontSize: 14,
                              color: fieldErrors['Email'] == true ? Colors.red : Colors.black,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Container(
                            margin: const EdgeInsets.only(bottom: 8),
                            decoration: BoxDecoration(
                              color: const Color(0xFFF5F5F7),
                              borderRadius: BorderRadius.circular(10),
                              border: Border.all(
                                color: Colors.transparent,
                                width: 1,
                              ),
                            ),
                            child: TextField(
                              enabled: false, // Always disabled
                              controller: emailController,
                              decoration: const InputDecoration(
                                border: InputBorder.none,
                                contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                              ),
                              style: TextStyle(
                                fontFamily: 'SF Pro Display',
                                fontWeight: FontWeight.w400,
                                fontSize: 15,
                                color: Colors.grey, // Grey color to indicate disabled state
                              ),
                            ),
                          ),
                        ],
                      ),
                      _profileField('Phone No', phoneController, isEditing, hasError: fieldErrors['Phone No'] == true),
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Account No',
                            style: TextStyle(
                              fontFamily: 'SF Pro Display',
                              fontWeight: FontWeight.w500,
                              fontSize: 14,
                              color: fieldErrors['Email'] == true ? Colors.red : Colors.black,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Container(
                            margin: const EdgeInsets.only(bottom: 8),
                            decoration: BoxDecoration(
                              color: const Color(0xFFF5F5F7),
                              borderRadius: BorderRadius.circular(10),
                              border: Border.all(
                                color: Colors.transparent,
                                width: 1,
                              ),
                            ),
                            child: TextField(
                              enabled: false, // Always disabled
                              controller:TextEditingController(text: profileData?['acno'] ?? ''),
                              decoration: const InputDecoration(
                                border: InputBorder.none,
                                contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                              ),
                              style: TextStyle(
                                fontFamily: 'SF Pro Display',
                                fontWeight: FontWeight.w400,
                                fontSize: 15,
                                color: Colors.grey, // Grey color to indicate disabled state
                              ),
                            ),
                          ),
                        ],
                      ),
                    
                      _profileField('Address', addressController, isEditing, hasError: fieldErrors['Address'] == true),
                      _profileField('CNIC', cnicController, isEditing, hasError: fieldErrors['CNIC'] == true),
                      // CNIC Expiry Date field with date picker
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'CNIC Expiry Date',
                            style: TextStyle(
                              fontFamily: 'SF Pro Display',
                              fontWeight: FontWeight.w500,
                              fontSize: 14,
                              color: fieldErrors['CNIC Expiry Date'] == true ? Colors.red : Colors.black,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Container(
                            margin: const EdgeInsets.only(bottom: 8),
                            decoration: BoxDecoration(
                              color: const Color(0xFFF5F5F7),
                              borderRadius: BorderRadius.circular(10),
                              border: Border.all(
                                color: Colors.transparent,
                                width: 1,
                              ),
                            ),
                            child: Row(
                              children: [
                                Expanded(
                                  child: TextField(
                                    enabled: isEditing,
                                    controller: cnicExpiryController,
                                    readOnly: isEditing, // Make it read-only when editing to show date picker
                                    decoration: const InputDecoration(
                                      border: InputBorder.none,
                                      contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                                      hintText: 'Select expiry date',
                                    ),
                                    style: TextStyle(
                                      fontFamily: 'SF Pro Display',
                                      fontWeight: FontWeight.w400,
                                      fontSize: 15,
                                      color: fieldErrors['CNIC Expiry Date'] == true ? Colors.red : Colors.black,
                                    ),
                                  ),
                                ),
                                if (isEditing)
                                  IconButton(
                                    icon: SvgPicture.asset(
                                      'assets/Calender.svg',
                                      width: 24,
                                      height: 24,
                                      colorFilter: const ColorFilter.mode(Color(0xFF007AFF), BlendMode.srcIn),
                                    ),
                                    onPressed: () async {
                                      final DateTime? picked = await showDatePicker(
                                        context: context,
                                        initialDate: DateTime.now(),
                                        firstDate: DateTime.now(),
                                        lastDate: DateTime.now().add(const Duration(days: 365 * 10)), // 10 years from now
                                        builder: (context, child) {
                                          return Theme(
                                            data: Theme.of(context).copyWith(
                                              colorScheme: const ColorScheme.light(
                                                primary: Color(0xFF007AFF),
                                                onPrimary: Colors.white,
                                                surface: Colors.white,
                                                onSurface: Colors.black,
                                              ),
                                            ),
                                            child: child!,
                                          );
                                        },
                                      );
                                      if (picked != null) {
                                        setState(() {
                                          cnicExpiryController.text = "${picked.day.toString().padLeft(2, '0')}-${picked.month.toString().padLeft(2, '0')}-${picked.year}";
                                        });
                                      }
                                    },
                                  ),
                              ],
                            ),
                          ),
                        ],
                      ),
                      _profileField('Business Name', businessNameController, isEditing, hasError: fieldErrors['Business Name'] == true),
                      _profileField('Business Address', businessAddressController, isEditing, hasError: fieldErrors['Business Address'] == true),
                      _profileField('NTN', ntnController, isEditing, hasError: fieldErrors['NTN'] == true),
                      
                      // Bank field - show in both view and edit modes
                      if (isEditing) 
                        _bankDropdownSection()
                      else
                        _profileField('Bank Name', TextEditingController(text: selectedBank?['name'] ?? 'N/A'), false),
                      
                      _profileField('Account Title', accountTitleController, isEditing, hasError: fieldErrors['Account Title'] == true),
                      _profileField('Account Number', accountNumberController, isEditing, hasError: fieldErrors['Account Number'] == true),
                
                        if (!(isEditing && isWalletBank))
                          _profileField('IBAN Number', ibanController, isEditing, hasError: fieldErrors['IBAN Number'] == true),
                      
                      // CNIC Image Section - Show existing image when not editing
                      if (!isEditing && (profileData?['cnic_image'] != null && profileData!['cnic_image'].toString().isNotEmpty))
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text(
                              'CNIC Image',
                              style: TextStyle(
                                fontFamily: 'SF Pro Display',
                                fontWeight: FontWeight.w500,
                                fontSize: 14,
                                color: Colors.black,
                              ),
                            ),
                            const SizedBox(height: 8),
                            GestureDetector(
                              onTap: () => _showCnicImageFullScreen(),
                              child: Container(
                                width: double.infinity,
                                height: 200,
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF5F5F7),
                                  borderRadius: BorderRadius.circular(12),
                                  border: Border.all(color: const Color(0xFFE0E0E0)),
                                ),
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(12),
                                  child: Image.network(
                                    getCnicImageUrl(profileData!['cnic_image'], profileData!['acno']),
                                    width: double.infinity,
                                    height: 200,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) => const Center(
                                      child: Column(
                                        mainAxisAlignment: MainAxisAlignment.center,
                                        children: [
                                          Icon(Icons.broken_image, size: 48, color: Colors.grey),
                                          SizedBox(height: 8),
                                          Text(
                                            'Failed to load image',
                                            style: TextStyle(color: Colors.grey, fontSize: 12),
                                          ),
                                        ],
                                      ),
                                    ),
                                    loadingBuilder: (context, child, loadingProgress) {
                                      if (loadingProgress == null) return child;
                                      return const Center(
                                        child: CircularProgressIndicator(color: Color(0xFF007AFF)),
                                      );
                                    },
                                  ),
                                ),
                              ),
                            ),

                          ],
                        ),
                      
                      if (isEditing) ...[
                        
                                                // CNIC Image Upload Section when editing
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Text(
                              'CNIC Image',
                              style: TextStyle(
                                fontFamily: 'SF Pro Display',
                                fontWeight: FontWeight.w500,
                                fontSize: 14,
                                color: Colors.black,
                              ),
                            ),
                            const SizedBox(height: 8),
                            // Current CNIC Image (if exists)
                            if (profileData?['cnic_image'] != null && profileData!['cnic_image'].toString().isNotEmpty)
                              Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  const Text(
                                    'Current CNIC Image',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.grey,
                                      fontWeight: FontWeight.w500,
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                                  Container(
                                    width: double.infinity,
                                    height: 150,
                                    decoration: BoxDecoration(
                                      color: const Color(0xFFF5F5F7),
                                      borderRadius: BorderRadius.circular(8),
                                      border: Border.all(color: const Color(0xFFE0E0E0)),
                                    ),
                                    child: ClipRRect(
                                      borderRadius: BorderRadius.circular(8),
                                      child: Image.network(
                                        getCnicImageUrl(profileData!['cnic_image'], profileData!['acno']),
                                        width: double.infinity,
                                        height: 150,
                                        fit: BoxFit.cover,
                                        errorBuilder: (context, error, stackTrace) => const Center(
                                          child: Icon(Icons.broken_image, size: 32, color: Colors.grey),
                                        ),
                                      ),
                                    ),
                                  ),
                                                                     const SizedBox(height: 12),
                                 ],
                               ),
                            // New CNIC Image Selection
                            Container(
                              width: double.infinity,
                              height: 120,
                              decoration: BoxDecoration(
                                color: const Color(0xFFF5F5F7),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(color: const Color(0xFFE0E0E0)),
                              ),
                              child: Material(
                                color: Colors.transparent,
                                child: InkWell(
                                  borderRadius: BorderRadius.circular(8),
                                  onTap: _pickCnicImage,
                                  child: _cnicImage != null
                                      ? ClipRRect(
                                          borderRadius: BorderRadius.circular(8),
                                          child: Stack(
                                            children: [
                                              Image.file(
                                                File(_cnicImage!.path),
                                                width: double.infinity,
                                                height: 120,
                                                fit: BoxFit.cover,
                                              ),
                                              // Remove button overlay
                                              Positioned(
                                                top: 8,
                                                right: 8,
                                                child: Container(
                                                  decoration: const BoxDecoration(
                                                    color: Colors.red,
                                                    shape: BoxShape.circle,
                                                  ),
                                                  child: IconButton(
                                                    icon: const Icon(Icons.close_rounded, color: Colors.white, size: 16),
                                                    onPressed: _removeCnicImage,
                                                    padding: EdgeInsets.zero,
                                                    constraints: const BoxConstraints(minWidth: 24, minHeight: 24),
                                                  ),
                                                ),
                                              ),
                                            ],
                                          ),
                                        )
                                      : const Center(
                                          child: Column(
                                            mainAxisAlignment: MainAxisAlignment.center,
                                            children: [
                                              Icon(Icons.add_photo_alternate_rounded, color: Color(0xFF007AFF), size: 32),
                                              SizedBox(height: 8),
                                              Text(
                                                'Tap to select CNIC image',
                                                style: TextStyle(
                                                  fontSize: 14,
                                                  color: Color(0xFF007AFF),
                                                  fontWeight: FontWeight.w500,
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                ),
                              ),
                                                         ),
                             const SizedBox(height: 16),
                          ],
                        ),
                        
                        Row(
                          children: [
                            Expanded(
                              child: Container(
                                decoration: BoxDecoration(
                                  color: const Color(0xFFF5F5F7),
                                  borderRadius: BorderRadius.circular(10),
                                  border: Border.all(
                                    color: Colors.transparent,
                                    width: 1,
                                  ),
                                ),
                                child: Material(
                                  color: Colors.transparent,
                                  child: InkWell(
                                    borderRadius: BorderRadius.circular(10),
                                    onTap: () {
                                      Get.to(() => const ChangePasswordScreen());
                                    },
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(vertical: 16),
                                      child: const Center(
                                        child: Text(
                                          'Change Password',
                                          style: TextStyle(
                                            fontFamily: 'SF Pro Display',
                                            fontWeight: FontWeight.w500,
                                            fontSize: 15,
                                            color: Colors.black,
                                          ),
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: ElevatedButton(
                                onPressed: isUpdating ? null : _updateProfile,
                                style: ElevatedButton.styleFrom(
                                  backgroundColor: Color(0xFF007AFF),
                                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
                                  padding: const EdgeInsets.symmetric(vertical: 16),
                                  elevation: 0,
                                ),
                                child: isUpdating
                                  ? const SizedBox(
                                      height: 20,
                                      width: 20,
                                      child: CircularProgressIndicator(
                                        strokeWidth: 2,
                                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                      ),
                                    )
                                  : const Text(
                                      'Update Profile',
                                      style: TextStyle(
                                        fontFamily: 'SF Pro Display',
                                        fontWeight: FontWeight.w500,
                                        fontSize: 15,
                                        color: Colors.white,
                                      ),
                                    ),
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 24),
                      ],
                    ],
                  ),
                ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Get.to(() => CreateOrderScreen());
        },
        backgroundColor: const Color(0xFF0A253B),
        elevation: 4,
        shape: const CircleBorder(),
         child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
      ),
              bottomNavigationBar: AppBottomBar(
                selectedIndex: 3,
                onOrderListTap: () => Get.to(() => OrderListScreen(from: 'profile')),
                onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'profile')),
              ),
    );
  }

  Widget _bankDropdownSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Padding(
          padding: EdgeInsets.only(bottom: 8),
          child: Text(
            'Bank Name',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w500,
              fontSize: 14,
              color: Colors.black,
            ),
          ),
        ),
        if (_isLoadingBanks)
          Container(
            margin: const EdgeInsets.only(bottom: 12),
            padding: const EdgeInsets.symmetric(vertical: 16),
            child: const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF))),
          )
        else if (_bankError != null)
          Container(
            margin: const EdgeInsets.only(bottom: 12),
            padding: const EdgeInsets.symmetric(vertical: 8),
            child: Text(
              _bankError!,
              style: const TextStyle(color: Colors.red, fontSize: 12),
            ),
          )
        else
          _bankDropdown(),
      ],
    );
  }

  Widget _bankDropdown() {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      decoration: BoxDecoration(
        color: const Color(0xFFF5F5F7),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.transparent, width: 1),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.08),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: InkWell(
        onTap: banks.isNotEmpty ? () async {
          final selected = await showModalBottomSheet<Map<String, dynamic>>(
            context: context,
            isScrollControlled: true,
            backgroundColor: Colors.transparent,
            builder: (context) => _BankSearchDialog(
              banks: banks,
              initialBank: selectedBank,
            ),
          );
          if (selected != null) {
            setState(() {
              selectedBank = selected;
              
              // Clear IBAN validation errors if wallet bank is selected
              final bankName = (selected['name']?.toString() ?? '').toLowerCase();
              final isWallet = bankName.contains('easypaisa') || bankName.contains('jazzcash') || bankName.contains('sadapay') || bankName.contains('nayapay');
              if (isWallet && fieldErrors.containsKey('IBAN Number')) {
                 fieldErrors['IBAN Number'] = false;
              }
            });
          }
        } : null,
        borderRadius: BorderRadius.circular(10),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  selectedBank != null ? selectedBank!['name'] ?? 'Select Bank' : 'Select Bank',
                  style: TextStyle(
                    fontFamily: 'SF Pro Display',
                    fontWeight: FontWeight.w400,
                    fontSize: 15,
                    color: selectedBank != null ? Colors.black : Colors.grey,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
              const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
            ],
          ),
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'order_list_screen.dart';
import 'create_order.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../services/cities_service.dart';
import '../config/api_config.dart';
import 'package:dio/dio.dart';
import '../network/order_service.dart';
import '../utils/custom_snackbar.dart';
import 'package:flutter_svg/flutter_svg.dart';

class QuickEditScreen extends StatefulWidget {
  final Map<String, dynamic> order;
  const QuickEditScreen({Key? key, required this.order}) : super(key: key);

  @override
  State<QuickEditScreen> createState() => _QuickEditScreenState();
}

class _QuickEditScreenState extends State<QuickEditScreen> {
  late final TextEditingController nameController;
  late final TextEditingController emailController;
  late final TextEditingController contactController;
  late final TextEditingController addressController;
  late final TextEditingController address2Controller;
  late final TextEditingController weightController;
  late final TextEditingController tagController;
  late String selectedCity;
  bool _isLoading = false;

  
  List<String> cityList = [];
  List<Map<String, dynamic>> cityObjects = []; 
  bool _isLoadingCities = false;
  String? _cityError;

  
  List<String> tags = [];
  final TextEditingController _tagInputController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _initializeControllers();
    
    _loadCitiesImmediately();
  }

  void _loadCitiesImmediately() {
    
    final cachedCities = CitiesService.getCachedCities();
    if (cachedCities != null) {
      final cityNames = cachedCities.map((e) => (e['name'] ?? '').toString()).where((e) => e.isNotEmpty).toList();
      final cityObjects = cachedCities.map((e) => Map<String, dynamic>.from(e)).toList();
      setState(() {
        this.cityList = cityNames;
        this.cityObjects = cityObjects;
        
        if (widget.order['destination_city'] != null && cityList.contains(widget.order['destination_city'])) {
          selectedCity = widget.order['destination_city'];
        } else if (selectedCity.isEmpty || !cityList.contains(selectedCity)) {
          selectedCity = cityList.isNotEmpty ? cityList.first : '';
        }
        _isLoadingCities = false;
      });
    }
    
    
    _fetchCities();
  }

  void _initializeControllers() {
    final order = widget.order;
   
    
    nameController = TextEditingController(text: order['consignee_name'] ?? '');
    emailController = TextEditingController(text: order['consignee_email'] ?? '');
    contactController = TextEditingController(text: order['consignee_contact'] ?? '');
    addressController = TextEditingController(text: order['consignee_address'] ?? '');
    address2Controller = TextEditingController(text: order['consignee_address2'] ?? '');
    weightController = TextEditingController(text: order['weight']?.toString() ?? '');
    tagController = TextEditingController(text: order['tags_name'] ?? '');
    selectedCity = order['destination_city'] ?? '';
    
    
    final existingTags = order['tags_name']?.toString().trim() ?? '';
    if (existingTags.isNotEmpty && existingTags != '-' && existingTags.toUpperCase() != 'NONE') {
      tags = existingTags.split(',').map((tag) => tag.trim()).where((tag) => tag.isNotEmpty).toList();
    }
    
   
  }

  void _updateOrderData(Map<String, dynamic> updatedOrder) {
    
    nameController.text = updatedOrder['consignee_name'] ?? '';
    emailController.text = updatedOrder['consignee_email'] ?? '';
    contactController.text = updatedOrder['consignee_contact'] ?? '';
    addressController.text = updatedOrder['consignee_address'] ?? '';
    address2Controller.text = updatedOrder['consignee_address2'] ?? '';
    weightController.text = updatedOrder['weight']?.toString() ?? '';
    tagController.text = updatedOrder['tags_name'] ?? '';
    
    
    final existingTags = updatedOrder['tags_name']?.toString().trim() ?? '';
    if (existingTags.isNotEmpty && existingTags != '-' && existingTags.toUpperCase() != 'NONE') {
      setState(() {
        tags = existingTags.split(',').map((tag) => tag.trim()).where((tag) => tag.isNotEmpty).toList();
      });
    } else {
      setState(() {
        tags = [];
      });
    }
    
    
    final newCity = updatedOrder['destination_city'] ?? '';
    if (newCity.isNotEmpty && newCity != selectedCity) {
      setState(() {
        selectedCity = newCity;
      });
    }
  }

  Future<void> _fetchCities() async {
    
    if (cityList.isNotEmpty && !_isLoadingCities) {
      return;
    }
    
    setState(() { _isLoadingCities = true; _cityError = null; });
    try {
      
      final cachedCities = CitiesService.getCachedCities();
      if (cachedCities != null) {
        final cityNames = cachedCities.map((e) => (e['name'] ?? '').toString()).where((e) => e.isNotEmpty).toList();
        final cityObjects = cachedCities.map((e) => Map<String, dynamic>.from(e)).toList();
        setState(() {
          this.cityList = cityNames;
          this.cityObjects = cityObjects;
          
          if (widget.order['destination_city'] != null && cityList.contains(widget.order['destination_city'])) {
            selectedCity = widget.order['destination_city'];
          } else if (selectedCity.isEmpty || !cityList.contains(selectedCity)) {
            selectedCity = cityList.isNotEmpty ? cityList.first : '';
          }
          _isLoadingCities = false;
        });
        return;
      }
      
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
        data: {"country_id": 1},
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        List<dynamic> cityApiList;
        if (data is List) {
          cityApiList = data;
        } else if (data is Map && data['payload'] is List) {
          cityApiList = data['payload'];
        } else {
          cityApiList = [];
        }
        final cityNames = cityApiList.map((e) => (e['name'] ?? e['city_name'] ?? '').toString()).where((e) => e.isNotEmpty).toList();
        final cityObjects = cityApiList.map((e) => Map<String, dynamic>.from(e)).toList();
        setState(() {
          this.cityList = cityNames;
          this.cityObjects = cityObjects;
          
          if (widget.order['destination_city'] != null && cityList.contains(widget.order['destination_city'])) {
            selectedCity = widget.order['destination_city'];
          } else if (selectedCity.isEmpty || !cityList.contains(selectedCity)) {
            selectedCity = cityList.isNotEmpty ? cityList.first : '';
          }
          _isLoadingCities = false;
        });
      } else {
        setState(() {
          _cityError = 'Failed to load cities';
          _isLoadingCities = false;
        });
      }
    } catch (e) {
      setState(() {
        _cityError = 'Failed to load cities: $e';
        _isLoadingCities = false;
      });
    }
  }

  @override
  void dispose() {
    nameController.dispose();
    emailController.dispose();
    contactController.dispose();
    addressController.dispose();
    address2Controller.dispose();
    weightController.dispose();
    tagController.dispose();
    _tagInputController.dispose();
    super.dispose();
  }

  Map<String, dynamic> _getUpdatedOrderData() {
    return {
      ...widget.order,
      'consignee_name': nameController.text.trim(),
      'consignee_email': emailController.text.trim(),
      'consignee_contact': contactController.text.trim(),
      'consignee_address': addressController.text.trim(),
      'consignee_address2': address2Controller.text.trim(),
      'weight': weightController.text.trim(),
      'tags_name': tags.join(','),
      'destination_city': selectedCity,
    };
  }

  void _addTag(String tag) {
    final trimmedTag = tag.trim();
    if (trimmedTag.isNotEmpty && !tags.contains(trimmedTag)) {
      setState(() {
        tags.add(trimmedTag);
      });
      _tagInputController.clear();
    }
  }

  void _removeTag(String tag) {
    setState(() {
      tags.remove(tag);
    });
  }

  Future<void> _submitQuickEdit() async {
    setState(() { _isLoading = true; });
    try {
      final acno = widget.order['acno']?.toString() ?? '';
      final idRaw = widget.order['id'] ?? '';
      final id = int.tryParse(idRaw.toString()) ?? 0;
      
      
      int destinationCityId = 655; 
      
      
      final originalCity = widget.order['destination_city']?.toString() ?? '';
      if (selectedCity == originalCity) {
        final originalCityId = widget.order['destination_city_id'];
        destinationCityId = int.tryParse(originalCityId?.toString() ?? '655') ?? 655;
       
      } else if (selectedCity.isNotEmpty) {
        
        try {
          print(' Looking for city: "$selectedCity"');
          print(' Available cities: ${cityObjects.length}');
          
          
          Map<String, dynamic>? selectedCityData;
          for (final city in cityObjects) {
            final cityName = (city['name'] ?? '').toString();
            final cityNameAlt = (city['city_name'] ?? '').toString();
            
            if (cityName == selectedCity || cityNameAlt == selectedCity) {
              selectedCityData = city;
              
              break;
            }
          }
          
          if (selectedCityData != null) {
            destinationCityId = int.tryParse(selectedCityData['id']?.toString() ?? '655') ?? 655;
           
          } else {
            
            
            
            final cachedCities = CitiesService.getCachedCities();
            if (cachedCities != null) {
              
              
              
              for (final city in cachedCities) {
                final cityName = (city['name'] ?? '').toString();
                final cityNameAlt = (city['city_name'] ?? '').toString();
                
                if (cityName == selectedCity || cityNameAlt == selectedCity) {
                  selectedCityData = city;

                  break;
                }
              }
              
              if (selectedCityData != null) {
                destinationCityId = int.tryParse(selectedCityData['id']?.toString() ?? '655') ?? 655;
                
              } else {
                
                destinationCityId = 655;
              }
            } else {
              
              
              final response = await Dio().post(
                ApiConfig.getEndpointUrl(ApiConfig.citiesEndpoint),
                data: {"country_id": 1},
                options: Options(headers: {'Content-Type': 'application/json'}),
              );
              if (response.statusCode == 200 && response.data != null) {
                final data = response.data;
                List<dynamic> cityApiList;
                if (data is List) {
                  cityApiList = data;
                } else if (data is Map && data['payload'] is List) {
                  cityApiList = data['payload'];
                } else {
                  cityApiList = [];
                }
                
               
                
                
                for (final city in cityApiList) {
                  final cityName = (city['name'] ?? '').toString();
                  final cityNameAlt = (city['city_name'] ?? '').toString();
                  
                  if (cityName == selectedCity || cityNameAlt == selectedCity) {
                    selectedCityData = city;
                    
                    break;
                  }
                }
                
                if (selectedCityData != null) {
                  destinationCityId = int.tryParse(selectedCityData['id']?.toString() ?? '655') ?? 655;
                  
                } else {
                  
                  destinationCityId = 655;
                }
              }
            }
          }
        } catch (e) {
          print(' Error mapping city name to ID: $e');
          destinationCityId = 655;
        }
      }
      
      
      final shippingChargesRaw = widget.order['shipping_charges'] ?? 0;
      final shippingCharges = int.tryParse(shippingChargesRaw.toString()) ?? 0;
      
      final weightRaw = weightController.text.trim();
      final weight = double.tryParse(weightRaw) ?? 0.0;
      
      final requestBody = {
          "acno": acno,
          "id": id,
          "consignee_name": nameController.text.trim(),
          "consignee_email": emailController.text.trim(),
          "consignee_no": contactController.text.trim(),
          "consignee_address": addressController.text.trim(),
        "shipping_charges": shippingCharges,
        "destination_city_id": destinationCityId,
        "weight": weight,
        "tags_name": tags.join(','),
      };
      
      
      
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer QoVDWMtOU9sUzi543rtAVcaeAiEoDH/lQMmuxj4JbjO54gmraIr8QwAloW2F8KEM4PEU9zibMkdCp5RMU3LFqg==',
      };
      
      final response = await Dio().post(
        ApiConfig.getEndpointUrl(ApiConfig.orderQuickEditEndpoint),
        data: requestBody,
        options: Options(
          headers: requestHeaders,
        ),
      );
      
      if (response.statusCode == 200 && (response.data['status'] == 1 || response.data['success'] == true)) {
        
        try {
          final originalTags = (widget.order['tags_name'] ?? '').toString().trim();
          final newTags = tags.join(',');
          final isOriginalEmpty = originalTags.isEmpty || originalTags == '-' || originalTags.toUpperCase() == 'NONE';
          final type = isOriginalEmpty ? 'add' : 'update';
          if (newTags.isNotEmpty || !isOriginalEmpty) {
            await OrderService.upsertOrderTags(
              acno: acno,
              orderId: id,
              tagsCommaSeparated: newTags,
              type: type,
              checkLimit: 'N',
            );
          }
        } catch (_) {}

        
        final status = widget.order['status']?.toString().toLowerCase();
        customSnackBar('Success', status == 'booked' ? 'Order updated successfully' : 'Order details updated successfully');
        Navigator.of(context).pop(true);
        return;
      } else {
        
        if (response.statusCode == 403) {
          customSnackBar('Success', 'Order updated successfully');
        } else {
          customSnackBar('Error', 'Failed to update order details');
        }
      }
    } catch (e) {
      customSnackBar('Error', 'Failed to update order details: $e');
    } finally {
      setState(() { _isLoading = false; });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: true,
      appBar: AppBar(
        backgroundColor: Colors.white,
        
        foregroundColor: Colors.black,
        surfaceTintColor: Colors.white,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
          onPressed: () {
            
            final hasChanges = nameController.text.trim() != (widget.order['consignee_name'] ?? '') ||
                              emailController.text.trim() != (widget.order['consignee_email'] ?? '') ||
                              contactController.text.trim() != (widget.order['consignee_contact'] ?? '') ||
                              addressController.text.trim() != (widget.order['consignee_address'] ?? '') ||
                              address2Controller.text.trim() != (widget.order['consignee_address2'] ?? '') ||
                              weightController.text.trim() != (widget.order['weight']?.toString() ?? '') ||
                              tags.join(',') != (widget.order['tags_name'] ?? '') ||
                              selectedCity != (widget.order['destination_city'] ?? '');
            
            if (hasChanges) {
              
              Navigator.of(context).pop(_getUpdatedOrderData());
            } else {
              
              Navigator.of(context).pop();
            }
          },
        ),
        title: const Text(
          'Quick Edit',
          style: TextStyle(
            fontFamily: 'SF Pro Display',
            fontWeight: FontWeight.w600,
            fontSize: 20,
            color: Colors.black,
          ),
        ),
        centerTitle: false,
        bottom: PreferredSize(
          preferredSize: Size.fromHeight(1),
          child: Container(
            height: 1,
            color: Colors.grey[300],
          ),
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        child: SingleChildScrollView(
          child: Column(
            children: [
            _labeledInputField('Full Name', nameController),
            const SizedBox(height: 12),
            _labeledInputField('Email', emailController),
            const SizedBox(height: 12),
            _labeledInputField('Phone', contactController),
            const SizedBox(height: 12),
            _labeledInputField('Address', addressController),
            const SizedBox(height: 12),
            
            Align(
              alignment: Alignment.centerLeft,
              child: Text('Destination City', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w500, color: Colors.black)),
            ),
            const SizedBox(height: 6),
            GestureDetector(
              onTap: () async {
                                    final result = await showModalBottomSheet<String>(
                      context: context,
                      isScrollControlled: true,
                      backgroundColor: Colors.transparent,
                      builder: (ctx) => _SingleSelectDialog(
                        items: cityList,
                        initialValue: selectedCity,
                        title: 'Select City',
                      ),
                    );
                    if (result != null) {
                      setState(() => selectedCity = result);
                    }
                  },
                  child: Container(
                    margin: const EdgeInsets.only(bottom: 8),
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
                    decoration: BoxDecoration(
                      color: const Color(0xFFF5F5F7),
                      borderRadius: BorderRadius.circular(10),
                      border: Border.all(color: Colors.transparent, width: 0),
                    ),
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            selectedCity.isEmpty ? 'Select City' : selectedCity,
                            style: TextStyle(fontSize: 15, color: selectedCity.isEmpty ? Colors.grey : Colors.black),
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        ),
                        const Icon(Icons.keyboard_arrow_down_rounded, color: Color(0xFF222222)),
                      ],
                    ),
                  ),
                ),
            
            _labeledInputField('Weight', weightController, keyboardType: TextInputType.number),
            const SizedBox(height: 12),
            _buildTagInput(),
            const SizedBox(height: 16), 
            SizedBox(
              width: double.infinity,
              height: 48,
              child: ElevatedButton(
                onPressed: _isLoading ? null : _submitQuickEdit,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                child: _isLoading
                    ? const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                        ),
                      )
                    : const Text('Update', style: TextStyle(fontSize: 18, color: Colors.white)),
              ),
            ),
            const SizedBox(height: 24), 
          ],
        ),
      ),
      ),
      floatingActionButton: MediaQuery.of(context).viewInsets.bottom == 0
          ? FloatingActionButton(
        onPressed: () {
          Get.to(() => CreateOrderScreen(from: 'quick_edit'));
        },
        backgroundColor: const Color(0xFF0A253B),
        shape: const CircleBorder(),
              child: SvgPicture.asset(
                'assets/Create Order.svg',
                width: 28,
                height: 28,
                color: Colors.white,
              ),
        elevation: 4,
            )
          : null,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
              bottomNavigationBar: const AppBottomBar(selectedIndex: 1),
    );
  }

  Widget _buildTagInput() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('Order Tags', style: TextStyle(fontSize: 15, fontWeight: FontWeight.w500, color: Colors.black)),
        const SizedBox(height: 6),
        Container(
          decoration: BoxDecoration(
            color: const Color(0xFFF5F5F7),
            borderRadius: BorderRadius.circular(10),
          ),
          child: Column(
            children: [
              
              if (tags.isNotEmpty)
                Padding(
                  padding: const EdgeInsets.all(12),
                  child: Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: tags.map((tag) => _buildTagChip(tag)).toList(),
                  ),
                ),
              
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
                child: TextField(
                  controller: _tagInputController,
                  decoration: const InputDecoration(
                    hintText: 'Enter tag',
                    border: InputBorder.none,
                    isDense: true,
                    contentPadding: EdgeInsets.symmetric(vertical: 12),
                  ),
                  style: const TextStyle(fontSize: 16, color: Colors.black),
                  onSubmitted: _addTag,
                  textInputAction: TextInputAction.done,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTagChip(String tag) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: const Color(0xFF007AFF),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            tag,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(width: 6),
          GestureDetector(
            onTap: () => _removeTag(tag),
            child: const Icon(
              Icons.close,
              color: Colors.white,
              size: 16,
            ),
          ),
        ],
      ),
    );
  }

  Widget _labeledInputField(String label, TextEditingController controller, {TextInputType keyboardType = TextInputType.text, String? hint}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: const TextStyle(fontSize: 15, fontWeight: FontWeight.w500, color: Colors.black)),
        const SizedBox(height: 6),
        TextField(
          controller: controller,
          keyboardType: keyboardType,
          decoration: InputDecoration(
            filled: true,
            fillColor: const Color(0xFFF5F5F7),
            border: OutlineInputBorder(borderRadius: BorderRadius.circular(10), borderSide: BorderSide.none),
            isDense: true,
            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
            hintText: hint,
          ),
          style: const TextStyle(fontSize: 16, color: Colors.black),
        ),
      ],
    );
  }
}

class _QuickEditSuccessBottomSheet extends StatelessWidget {
  const _QuickEditSuccessBottomSheet({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 0,
        right: 0,
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              decoration: BoxDecoration(
                color: const Color(0xFFE6F0FF),
                shape: BoxShape.circle,
              ),
              padding: const EdgeInsets.all(32),
              child: const Icon(Icons.check_rounded, color: Color(0xFF007AFF), size: 64),
            ),
            const SizedBox(height: 24),
            const Text(
              'Success!',
              style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
            ),
            const SizedBox(height: 8),
            const Text(
              'Consignment detail updated',
              style: TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 28),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () {
                  Navigator.of(context).popUntil((route) => route.isFirst);
                  Navigator.of(context).pushReplacement(
                    MaterialPageRoute(builder: (_) => OrderListScreen()),
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  elevation: 0,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 14),
                ),
                child: const Text('Ok', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _SingleSelectDialog extends StatefulWidget {
  final List<String> items;
  final String? initialValue;
  final String title;

  const _SingleSelectDialog({Key? key, required this.items, required this.initialValue, required this.title}) : super(key: key);

  @override
  State<_SingleSelectDialog> createState() => _SingleSelectDialogState();
}

class _SingleSelectDialogState extends State<_SingleSelectDialog> {
  String? selected;
  String _search = '';

  @override
  void initState() {
    super.initState();
    selected = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) {
    final filteredItems = widget.items.where((item) => item.toLowerCase().contains(_search.toLowerCase())).toList();
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          
          Container(
            margin: const EdgeInsets.only(top: 8),
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey[300],
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          
          Flexible(
            child: SingleChildScrollView(
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(widget.title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                    const SizedBox(height: 12),
                    TextField(
                      decoration: InputDecoration(
                        hintText: 'Search',
                        prefixIcon: const Icon(Icons.search_rounded, color: Colors.black),
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                      ),
                      onChanged: (val) => setState(() => _search = val),
                    ),
                    const SizedBox(height: 12),
                    SizedBox(
                      height: 300,
                      child: ListView.separated(
                        itemCount: filteredItems.length,
                        separatorBuilder: (_, __) => Container(
                          height: 1,
                          color: Colors.black.withOpacity(0.08),
                          margin: const EdgeInsets.symmetric(horizontal: 8),
                        ),
                        itemBuilder: (context, i) {
                          final item = filteredItems[i];
                          final isSelected = selected == item;
                          return ListTile(
                            title: Text(item),
                            trailing: isSelected
                                ? const Icon(Icons.arrow_forward_ios_rounded, color: Color(0xFF007AFF), size: 18)
                                : null,
                            onTap: () {
                              setState(() {
                                selected = item;
                              });
                              Navigator.of(context).pop(item);
                            },
                            selected: isSelected,
                            selectedTileColor: Colors.grey[200],
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          );
                        },
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'dashboard_screen.dart';
import 'menu.dart';
import 'create_order.dart' as create_order;
import 'order_list_screen.dart';
import 'cod_statement_screen.dart';
import 'ageing_report_screen.dart';
import 'load_sheet_screen.dart';
import 'courier_companies_screen.dart' as courier_companies;
import 'rules_screen.dart' as rules;
import 'notification_screen.dart' as notification;
import 'help_videos_screen.dart' as help_videos;
import 'create_loadsheet_screen.dart' as create_loadsheet;
import 'add_courier_company_screen.dart' as add_courier_company;
import 'add_notification_screen.dart' as add_notification;
import 'profile_screen.dart' as profile;
import '../utils/Layout/app_bottom_bar.dart';
import 'package:flutter_svg/flutter_svg.dart';

class ReportsScreen extends StatelessWidget {
  final String? from;
  const ReportsScreen({Key? key, this.from}) : super(key: key);

  @override
  Widget build(BuildContext context) {
     SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: [SystemUiOverlay.top, SystemUiOverlay.bottom]);


    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: const SystemUiOverlayStyle(
        statusBarColor: Colors.white,
        statusBarIconBrightness: Brightness.dark,
        statusBarBrightness: Brightness.light,
        systemNavigationBarColor: Colors.white,
        systemNavigationBarIconBrightness: Brightness.dark,
      ),
      child: Scaffold(
        backgroundColor: Colors.white,
        extendBody: true,
        appBar: AppBar(
          backgroundColor: Colors.white,
          foregroundColor: Colors.black,
          surfaceTintColor: Colors.white,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
            onPressed: () {
              print('Back button pressed, from: $from');
              if (from == 'menu') {
                Get.offAll(() => MenuScreen());
              } else if (from == 'dashboard') {
                Get.offAll(() => DashboardScreen());
              } else if (from == 'order_list') {
                Get.offAll(() => OrderListScreen());
              } else if (from == 'create_order') {
                Get.offAll(() => create_order.CreateOrderScreen());
              } else if (from == 'courier_companies') {
                Get.offAll(() => courier_companies.CourierCompaniesScreen());
              } else if (from == 'loadsheet') {
                Get.offAll(() => LoadSheetScreen());
              } else if (from == 'rules') {
                Get.offAll(() => rules.RulesScreen());
              } else if (from == 'notifications') {
                Get.offAll(() => notification.NotificationScreen());
              } else if (from == 'help_videos') {
                Get.offAll(() => help_videos.HelpVideosScreen());
              } else if (from == 'create_loadsheet') {
                Get.offAll(() => create_loadsheet.CreateLoadsheetScreen());
              } else if (from == 'add_courier_company') {
                Get.offAll(() => add_courier_company.AddCourierCompanyScreen());
              } else if (from == 'add_notification') {
                Get.offAll(() => add_notification.AddNotificationScreen());
              } else if (from == 'profile') {
                Get.offAll(() => profile.ProfileScreen());
              } else {
                
                Navigator.of(context).maybePop();
              }
            },
          ),
          title: Padding(
            padding: const EdgeInsets.only(left: 8),
            child: const Text(
              'Reports',
              style: TextStyle(
                fontFamily: 'SF Pro Display',
                fontWeight: FontWeight.w600,
                fontSize: 20,
                color: Colors.black,
              ),
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
        ),
        body: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
          child: AnimationLimiter(
            child: GridView.builder(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                mainAxisSpacing: 20,
                crossAxisSpacing: 20,
                childAspectRatio: 1.1,
              ),
              itemCount: 4,
              itemBuilder: (context, index) {
                final cards = [
                  _ReportCard(
                    svgAsset: 'assets/COD Statment.svg',
                    label: 'COD Statements',
                    onTap: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(builder: (_) => CODStatementScreen()),
                      );
                    },
                  ),
                  _ReportCard(
                    svgAsset: 'assets/Ageing Report.svg',
                    label: 'Ageing Report',
                    onTap: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(builder: (_) => const AgeingReportScreen()),
                      );
                    },
                  ),
                  _ReportCard(
                    svgAsset: 'assets/Courier Insights Report.svg',
                    label: 'Courier Insights Report',
                    onTap: () {
                      Get.toNamed('/courier-insights');
                    },
                  ),
                  _ReportCard(
                    svgAsset: 'assets/Courier Performance.svg',
                    label: 'Courier Performance',
                    onTap: () {
                      Get.toNamed('/courier-performance');
                    },
                  ),
                ];
                
                return AnimationConfiguration.staggeredList(
                  position: index,
                  duration: const Duration(milliseconds: 500),
                  child: ScaleAnimation(
                    scale: 0.8,
                    child: FadeInAnimation(
                      child: SlideAnimation(
                        verticalOffset: 50.0,
                        child: cards[index],
                      ),
                    ),
                  ),
                );
              },
            ),
          ),
        ),
        bottomNavigationBar: AppBottomBar(
          selectedIndex: 2,
          onHomeTap: () => Get.offAll(() => DashboardScreen()),
                            onOrderListTap: () => Get.to(() => OrderListScreen(from: 'reports')),
          onReportsTap: () {}, 
          onMenuTap: () => Get.offAll(() => MenuScreen()),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            Get.to(() => const create_order.CreateOrderScreen());
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
           child: SvgPicture.asset(
  'assets/Create Order.svg',
  width: 28,
  height: 28,
  color: Colors.white,
),
        ),
      ),
    );
  }
}

class _ReportCard extends StatelessWidget {
  final IconData? icon;
  final String? svgAsset;
  final String label;
  final VoidCallback onTap;
  const _ReportCard({this.icon, this.svgAsset, required this.label, required this.onTap});

  @override
  Widget build(BuildContext context) {
    return Material(
      color: const Color(0xFFF5F5F7),
      borderRadius: BorderRadius.circular(16),
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: onTap,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            SizedBox(
              height: 60,
              child: Center(
                child: svgAsset != null
                    ? SvgPicture.asset(
                        svgAsset!,
                width: 48,
                height: 48,
                fit: BoxFit.contain,
              )
                    : Icon(icon, color: Color(0xFF007AFF), size: 32),
              ),
            ),
            const SizedBox(height: 12),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: Text(
              label,
              textAlign: TextAlign.center,
                style: GoogleFonts.poppins(
                fontWeight: FontWeight.w500,
                  fontSize: 14,
                color: Colors.black,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class CustomBottomNavBar extends StatelessWidget {
  final int selectedIndex;
  final VoidCallback? onMenuTap;
  final VoidCallback? onHomeTap;
  final VoidCallback? onReportsTap;
  final VoidCallback? onOrderListTap;
  final VoidCallback? onPencilTap;
  const CustomBottomNavBar({Key? key, required this.selectedIndex, this.onMenuTap, this.onHomeTap, this.onReportsTap, this.onOrderListTap, this.onPencilTap}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      top: false,
      child: Stack(
        children: [
          
          Positioned(
            top: 0,
            left: 0,
            right: 0,
            child: Container(
              height: 1,
              color: const Color(0xFFB0B0B0),
              
              child: DecoratedBox(
                decoration: BoxDecoration(
                  boxShadow: [
                    BoxShadow(
                      color: Color(0x22000000), 
                      blurRadius: 4,
                      offset: Offset(0, 2),
                    ),
                  ],
                ),
              ),
            ),
          ),
          
          BottomAppBar(
            shape: const CircularNotchedRectangle(),
            notchMargin: 8,
            elevation: 0,
            color: Colors.white,
            child: SizedBox(
              height: 64,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  _NavBarItem(
                    icon:Icons.home_rounded,
                    label: 'Home',
                    selected: selectedIndex == 0,
                    onTap: onHomeTap ?? () {},
                  ),
                  _NavBarItem(
                    icon:Icons.shopping_bag_rounded,
                    label: 'Order List',
                    selected: selectedIndex == 1,
                    onTap: onOrderListTap ?? () {},
                  ),
                  const SizedBox(width: 56), 
                  _NavBarItem(
                    icon: Icons.tune_rounded,
                    label: 'Reports',
                    selected: selectedIndex == 2,
                    onTap: onReportsTap ?? () {},
                  ),
                  _NavBarItem(
                    icon:Icons.menu_rounded,
                    label: 'Menu',
                    selected: selectedIndex == 4,
                    onTap: onMenuTap ?? () {},
                    selectedColor: const Color(0xFF007AFF),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _NavBarItem extends StatelessWidget {
  final IconData icon;
  final String label;
  final bool selected;
  final VoidCallback onTap;
  final Color? selectedColor;

  const _NavBarItem({
    Key? key,
    required this.icon,
    required this.label,
    required this.selected,
    required this.onTap,
    this.selectedColor,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final color = selected
        ? (selectedColor ?? const Color(0xFF007AFF))
        : const Color(0xFF222222);
    return Expanded(
      child: InkWell(
        onTap: onTap,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const SizedBox(height: 8),
            Icon(icon, color: color, size: 26),
            const SizedBox(height: 2),
            Text(
              label,
              style: GoogleFonts.poppins(
                fontWeight: selected ? FontWeight.w600 : FontWeight.w400,
                fontSize: 11,
                color: color,
              ),
            ),
          ],
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import 'sign_in_screen.dart';

class ResetPasswordController extends GetxController {
  var obscurePassword = true.obs;
  var obscureConfirm = true.obs;
  
  
  final TextEditingController passwordController = TextEditingController();
  final TextEditingController confirmPasswordController = TextEditingController();
  
  
  var passwordError = false.obs;
  var confirmPasswordError = false.obs;
  var passwordErrorMessage = ''.obs;
  var confirmPasswordErrorMessage = ''.obs;
  
  @override
  void onClose() {
    passwordController.dispose();
    confirmPasswordController.dispose();
    super.onClose();
  }
  
  bool validatePasswords() {
    
    passwordError.value = false;
    confirmPasswordError.value = false;
    passwordErrorMessage.value = '';
    confirmPasswordErrorMessage.value = '';
    
    
    if (passwordController.text.trim().isEmpty) {
      passwordError.value = true;
      passwordErrorMessage.value = 'Password is required';
      return false;
    }
    
    
    if (confirmPasswordController.text.trim().isEmpty) {
      confirmPasswordError.value = true;
      confirmPasswordErrorMessage.value = 'Confirm password is required';
      return false;
    }
    
    
    if (passwordController.text != confirmPasswordController.text) {
      confirmPasswordError.value = true;
      confirmPasswordErrorMessage.value = 'Passwords do not match';
      return false;
    }
    
    
    if (passwordController.text.length < 6) {
      passwordError.value = true;
      passwordErrorMessage.value = 'Password must be at least 6 characters long';
      return false;
    }
    
    return true;
  }
}

class ResetPasswordScreen extends StatelessWidget {
  ResetPasswordScreen({Key? key}) : super(key: key);
  final ResetPasswordController controller = Get.put(ResetPasswordController());

  @override
  Widget build(BuildContext context) {
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
      systemNavigationBarColor: Colors.white,
      systemNavigationBarIconBrightness: Brightness.dark,
    ));
    final size = MediaQuery.of(context).size;
    final width = size.width;
    final height = size.height;
    double blockH = height / 100;
    double blockW = width / 100;

    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            physics: const BouncingScrollPhysics(),
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: blockW * 6),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  SizedBox(height: blockH * 2),
                  Container(
                    width: 110,
                    height: 110,
                    decoration: const BoxDecoration(
                      color: Color(0xFFE6F0FF),
                      shape: BoxShape.circle,
                    ),
                    child: Center(
                      child: Icon(
                        Icons.lock_outline,
                        color: Color(0xFF007AFF),
                        size: 56,
                      ),
                    ),
                  ),
                  SizedBox(height: blockH * 4),
                  Text(
                    'Forgot Password',
                    style: GoogleFonts.inter(
                      fontWeight: FontWeight.w700,
                      fontSize: blockW * 7.2,
                      color: Color(0xFF183046),
                    ),
                    textAlign: TextAlign.center,
                  ),
                  SizedBox(height: blockH * 3),
                  Obx(() => Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        decoration: BoxDecoration(
                          color: const Color(0xFFF3F3F3),
                          borderRadius: BorderRadius.circular(blockW * 2),
                          border: controller.passwordError.value
                              ? Border.all(color: Colors.red, width: 1.5)
                              : null,
                        ),
                        child: TextField(
                          controller: controller.passwordController,
                          obscureText: controller.obscurePassword.value,
                          style: GoogleFonts.inter(
                            fontWeight: FontWeight.w400,
                            fontSize: blockW * 4.1,
                            color: Colors.black,
                          ),
                          decoration: InputDecoration(
                            hintText: 'Enter Password',
                            hintStyle: GoogleFonts.inter(
                              fontWeight: FontWeight.w400,
                              fontSize: blockW * 4.1,
                              color: const Color(0xFF6B6B6B),
                            ),
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: blockW * 4, vertical: 12),
                            suffixIcon: IconButton(
                              icon: Icon(
                                controller.obscurePassword.value ? Icons.visibility_off : Icons.visibility,
                                color: const Color(0xFFBDBDBD),
                              ),
                              onPressed: () => controller.obscurePassword.value = !controller.obscurePassword.value,
                            ),
                          ),
                        ),
                      ),
                      if (controller.passwordError.value)
                        Padding(
                          padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                          child: Obx(() => Text(
                            controller.passwordErrorMessage.value,
                            style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                          )),
                        ),
                    ],
                  )),
                  SizedBox(height: blockH * 2),
                  Obx(() => Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        decoration: BoxDecoration(
                          color: const Color(0xFFF3F3F3),
                          borderRadius: BorderRadius.circular(blockW * 2),
                          border: controller.confirmPasswordError.value
                              ? Border.all(color: Colors.red, width: 1.5)
                              : null,
                        ),
                        child: TextField(
                          controller: controller.confirmPasswordController,
                          obscureText: controller.obscureConfirm.value,
                          style: GoogleFonts.inter(
                            fontWeight: FontWeight.w400,
                            fontSize: blockW * 4.1,
                            color: Colors.black,
                          ),
                          decoration: InputDecoration(
                            hintText: 'Confirm Password',
                            hintStyle: GoogleFonts.inter(
                              fontWeight: FontWeight.w400,
                              fontSize: blockW * 4.1,
                              color: const Color(0xFF6B6B6B),
                            ),
                            border: InputBorder.none,
                            contentPadding: EdgeInsets.symmetric(horizontal: blockW * 4, vertical: 12),
                            suffixIcon: IconButton(
                              icon: Icon(
                                controller.obscureConfirm.value ? Icons.visibility_off : Icons.visibility,
                                color: const Color(0xFFBDBDBD),
                              ),
                              onPressed: () => controller.obscureConfirm.value = !controller.obscureConfirm.value,
                            ),
                          ),
                        ),
                      ),
                      if (controller.confirmPasswordError.value)
                        Padding(
                          padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                          child: Obx(() => Text(
                            controller.confirmPasswordErrorMessage.value,
                            style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                          )),
                        ),
                    ],
                  )),
                  SizedBox(height: blockH * 3),
                  SizedBox(
                    height: blockH * 6.2,
                    child: ElevatedButton(
                      onPressed: () {
                        FocusScope.of(context).unfocus();
                        
                        
                        if (!controller.validatePasswords()) {
                          return; 
                        }
                        
                        showModalBottomSheet(
                          context: context,
                          isScrollControlled: true,
                          backgroundColor: Colors.transparent,
                          builder: (context) {
                            return Container(
                              margin: const EdgeInsets.only(bottom: 0),
                              padding: const EdgeInsets.symmetric(horizontal: 0),
                              child: Container(
                                decoration: const BoxDecoration(
                                  color: Colors.white,
                                  borderRadius: BorderRadius.only(
                                    topLeft: Radius.circular(28),
                                    topRight: Radius.circular(28),
                                  ),
                                ),
                                padding: const EdgeInsets.fromLTRB(24, 32, 24, 24),
                                child: Column(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Container(
                                      width: 90,
                                      height: 90,
                                      decoration: const BoxDecoration(
                                        color: Color(0xFFE6F0FF),
                                        shape: BoxShape.circle,
                                      ),
                                      child: const Center(
                                        child: Icon(
                                          Icons.check,
                                          color: Color(0xFF007AFF),
                                          size: 56,
                                        ),
                                      ),
                                    ),
                                    const SizedBox(height: 24),
                                    Text(
                                      'Success!',
                                      style: GoogleFonts.inter(
                                        fontWeight: FontWeight.w700,
                                        fontSize: 22,
                                        color: Color(0xFF183046),
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      'Your password has been changed',
                                      style: GoogleFonts.inter(
                                        fontWeight: FontWeight.w400,
                                        fontSize: 15,
                                        color: Color(0xFF222222),
                                      ),
                                      textAlign: TextAlign.center,
                                    ),
                                    const SizedBox(height: 24),
                                                                         SizedBox(
                                       width: double.infinity,
                                       height: 44,
                                       child: ElevatedButton(
                                         onPressed: () {
                                           Navigator.of(context).pop();
                                           Get.offAll(() => SignInScreen());
                                         },
                                        style: ElevatedButton.styleFrom(
                                          backgroundColor: const Color(0xFF007AFF),
                                          shape: RoundedRectangleBorder(
                                            borderRadius: BorderRadius.circular(8),
                                          ),
                                          elevation: 0,
                                        ),
                                        child: Text(
                                          'Ok',
                                          style: GoogleFonts.inter(
                                            fontWeight: FontWeight.w600,
                                            fontSize: 17,
                                            color: Colors.white,
                                          ),
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                            );
                          },
                        );
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: const Color(0xFF007AFF),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(blockW * 2),
                        ),
                        elevation: 0,
                      ),
                      child: Text(
                        'Reset',
                        style: GoogleFonts.inter(
                          fontWeight: FontWeight.w600,
                          fontSize: blockW * 4.4,
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ),
                  SizedBox(height: blockH * 3.5),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        'Already have an account? ',
                        style: GoogleFonts.inter(
                          fontWeight: FontWeight.w400,
                          fontSize: blockW * 3.6,
                          color: const Color(0xFF6B6B6B),
                        ),
                      ),
                      GestureDetector(
                        onTap: () => Get.to(() => SignInScreen()),
                        child: Text(
                          'Click here to Sign In',
                          style: GoogleFonts.inter(
                            fontWeight: FontWeight.w500,
                            fontSize: blockW * 3.6,
                            color: const Color(0xFF007AFF),
                            decoration: TextDecoration.underline,
                          ),
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: blockH * 2.2),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:get/get.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'package:google_fonts/google_fonts.dart';
import '../widgets/transition.dart';
import '../utils/Layout/app_bottom_bar.dart';
import '../services/rules_service.dart';
import '../services/auth_service.dart';
import '../services/courier_service.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'create_rule_screen.dart';
import 'edit_rule_screen.dart';
import '../widgets/courier_logo_widget.dart';
import '../utils/custom_snackbar.dart';
import 'create_order.dart';
import 'order_list_screen.dart';
import 'report.dart' as report;
import 'package:flutter_svg/flutter_svg.dart';
import 'package:dio/dio.dart';
import '../config/api_config.dart';

class RulesScreen extends StatefulWidget {
  const RulesScreen({Key? key}) : super(key: key);

  @override
  State<RulesScreen> createState() => _RulesScreenState();
}

class _RulesScreenState extends State<RulesScreen> with WidgetsBindingObserver {
  late RulesService _rulesService;
  String? _acno;
  
  
  String? _searchQuery;
  List<Map<String, dynamic>> _filteredRules = [];
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();

  
  bool isLoading = false;
  bool _needsRefresh = false;

  
  static Map<String, dynamic>? _lastParams;
  static List<Map<String, dynamic>>? _cachedRules;
  
  
  static List<Map<String, dynamic>>? _cachedCourierAccounts;
  static String? _cachedCourierAccountsAcno;
  
  // Service code mapping cache
  static Map<String, String>? _cachedServiceCodeNames;
  static String? _cachedServiceCodeNamesAcno;

  
  static void clearAllRulesCaches() {
    _lastParams = null;
    _cachedRules = null;
    _cachedCourierAccounts = null;
    _cachedCourierAccountsAcno = null;
    _cachedServiceCodeNames = null;
    _cachedServiceCodeNamesAcno = null;
  }

  // Clear only rules cache to force refresh after deletion
  static void clearRulesCache() {
    _lastParams = null;
    _cachedRules = null;
  }

  @override
  void initState() {
    super.initState();
    
    // Add lifecycle observer
    WidgetsBinding.instance.addObserver(this);
    
    _filteredRules = [];
    _initializeService();
    _searchController.addListener(_onSearchChanged);
    _searchFocusNode.addListener(() {
      if (!_searchFocusNode.hasFocus) {
        
        setState(() {});
      }
    });
    
    final args = Get.arguments;
    if (args != null && args['message'] != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        customSnackBar('Success', args['message']);
      });
    }

    // Check if we need to refresh when coming back to this screen
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkAndRefreshIfNeeded();
    });


  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    
    // Check if we need to refresh when screen comes into focus
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkAndRefreshIfNeeded();
    });
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.resumed) {
      // Refresh data when app is resumed to ensure cache is up to date
      clearRulesCache();
      _loadRules(force: true);
    }
  }

  // Method to refresh data when screen is focused again
  void _refreshOnFocus() {
    // Clear cache and refresh data to ensure we have the latest count
    clearRulesCache();
    _loadRules(force: true);
  }

  // Check if refresh is needed when screen comes into focus
  void _checkAndRefreshIfNeeded() {
    if (_needsRefresh) {
      _needsRefresh = false;
      _loadRules(force: true);
    }
  }

  @override
  void dispose() {
    // Remove lifecycle observer
    WidgetsBinding.instance.removeObserver(this);
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  void _onSearchChanged() {
    setState(() {
      _searchQuery = _searchController.text;
      _applySearch();
    });
  }

  void _initializeService() {
    try {
      _rulesService = Get.find<RulesService>();
    } catch (e) {
      
      _rulesService = Get.put(RulesService(Get.find<AuthService>()), permanent: true);
    }
    _restoreOrFetchRules();
  }

  
  void _restoreOrFetchRules() async {
    final acno = _acno ?? await _getAcno();
    if (acno == null) {
      await _loadAcnoAndFetchRules();
      return;
    }
    
    final params = {
      'acno': acno,
    };
    
    // Check if we need to refresh due to rule deletion or navigation back
    if (_needsRefresh) {
      _needsRefresh = false;
      clearRulesCache(); // Clear cache to ensure fresh data
      await _loadRules(force: true);
      return;
    }
    
    if (_lastParams != null && _cachedRules != null && _lastParams.toString() == params.toString()) {
      setState(() {
        _rulesService.rules.value = List<Map<String, dynamic>>.from(_cachedRules!);
        _applySearch();
      });
      return;
    }
    await _loadRules(force: true);
  }

  Future<String?> _getAcno() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString('acno');
    } catch (e) {
      print('RulesScreen: Error getting acno: $e');
      return null;
    }
  }

  Future<void> _loadAcnoAndFetchRules() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _acno = prefs.getString('acno');
      
      if (_acno != null) {
        await _loadRules();
      } else {
       
      }
    } catch (e) {
      print('RulesScreen: Error loading acno: $e');
    }
  }

  Future<void> _loadRules({bool force = false}) async {
    final acno = _acno ?? await _getAcno();
    if (acno == null) return;

    
    if (_acno == null) {
      _acno = acno;
    }

    final params = {
      'acno': acno,
    };
    
    if (!force && _lastParams != null && _cachedRules != null &&
        _lastParams.toString() == params.toString()) {
      setState(() {
        _rulesService.rules.value = List<Map<String, dynamic>>.from(_cachedRules!);
        _applySearch();
      });
      return;
    }
    
    
    setState(() {
      isLoading = true;
    });
    
    _lastParams = params;
    try {
      await _rulesService.getRules(acno: acno);
      
      await _loadCourierAccounts();
      await _loadServiceCodeNames();
      setState(() {
        _cachedRules = List<Map<String, dynamic>>.from(_rulesService.rules);
        _applySearch();
      });
    } catch (e) {
      print('Error fetching rules: $e');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  void _applySearch() {
    if (_searchQuery != null && _searchQuery!.isNotEmpty) {
              _filteredRules = _rulesService.rules.where((rule) {
          final query = _searchQuery!.toLowerCase();
          final serviceName = _getServiceNameFromCode(rule['service_code']?.toString()).toLowerCase();
          return (rule['rule_name'] ?? '').toLowerCase().contains(query) ||
                 (rule['rule_title'] ?? '').toLowerCase().contains(query) ||
                 (rule['courier_name'] ?? '').toLowerCase().contains(query) ||
                 (rule['service_code'] ?? '').toLowerCase().contains(query) ||
                 serviceName.contains(query) ||
                 (rule['platform_name'] ?? '').toLowerCase().contains(query);
        }).toList();
    } else {
      _filteredRules = _rulesService.rules;
    }
  }

  Future<void> _manualRefresh() async {
    // Clear cache to ensure fresh data
    clearRulesCache();
    await _loadRules(force: true);
  }

  
  String? _getAccountTitleFromCustomerCourierId(String? customerCourierId) {
    if (customerCourierId == null) {
      
      return null;
    }
    
    if (_cachedCourierAccounts == null) {
     
      return null;
    }
    
   
    
    Map<String, dynamic> account = {};
    try {
      account = _cachedCourierAccounts!.firstWhere(
        (account) => account['id']?.toString() == customerCourierId,
      );
    } catch (e) {
      return null;
    }
    
    if (account.isNotEmpty) {
      final accountTitle = account['account_title']?.toString();
     
      return accountTitle;
    }
    
    return null;
  }

  String _getServiceNameFromCode(String? serviceCode) {
    if (serviceCode == null || serviceCode.isEmpty) {
      return 'N/A';
    }
    
    if (_cachedServiceCodeNames == null) {
      return serviceCode; // Fallback to code if names not loaded
    }
    
    return _cachedServiceCodeNames![serviceCode] ?? serviceCode;
  }

  
  Future<void> _loadServiceCodeNames() async {
    if (_acno == null) {
      
      return;
    }
    
    if (_cachedServiceCodeNames != null && _cachedServiceCodeNamesAcno == _acno) {
      return;
    }
    
    try {
      final dio = Dio();
      final response = await dio.post(
        ApiConfig.getEndpointUrl(ApiConfig.orderGetServiceCodeEndpoint),
        data: {
          "acno": _acno,
          "courier_id": 1, // Default courier ID
          "customer_courier_id": 55, // Default customer courier ID
        },
        options: Options(headers: {'Content-Type': 'application/json'}),
      );
      
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        Map<String, String> serviceCodeNames = {};
        
        if (data is Map && data['service_code'] is List) {
          final rawList = data['service_code'];
          for (var item in rawList) {
            if (item is Map && item['service_code'] != null) {
              final code = item['service_code'].toString();
              final name = item['service_name']?.toString() ?? code;
              serviceCodeNames[code] = name;
            }
          }
        } else if (data is Map && data['payload'] is List) {
          final rawList = data['payload'];
          for (var item in rawList) {
            if (item is Map && item['service_code'] != null) {
              final code = item['service_code'].toString();
              final name = item['service_name']?.toString() ?? code;
              serviceCodeNames[code] = name;
            }
          }
        }
        
        _cachedServiceCodeNames = serviceCodeNames;
        _cachedServiceCodeNamesAcno = _acno;
        
      }
    } catch (e) {
      print('Error loading service code names: $e');
      _cachedServiceCodeNames = {};
    }
  }

  Future<void> _loadCourierAccounts() async {
    if (_acno == null) {
      
      return;
    }
    
    if (_cachedCourierAccounts != null && _cachedCourierAccountsAcno == _acno) {
      return; 
    }
    
    try {
      final courierService = CourierService();
      final accounts = await courierService.getCourierAccounts(_acno!);
      _cachedCourierAccounts = accounts.map((account) => {
        'id': account.id.toString(),
        'account_title': account.accountTitle,
        'courier_id': account.courierId,
        'courier_name': account.courierName,
      }).toList();
      _cachedCourierAccountsAcno = _acno;
     
    } catch (e) {
      print('Error loading courier accounts: $e');
      _cachedCourierAccounts = [];
    }
  }

  @override
  Widget build(BuildContext context) {
    // Check if we need to refresh when screen is built (comes into focus)
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkAndRefreshIfNeeded();
    });
    
    return ConnectivityWrapper(
      showOfflineUI: true,
      child: Scaffold(
        backgroundColor: Colors.white,
        resizeToAvoidBottomInset: false,
        appBar: AppBar(
          backgroundColor: Colors.white,
          
          foregroundColor: Colors.white,
          surfaceTintColor: Colors.white,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_rounded, color: Colors.black, size: 22),
            onPressed: () => Navigator.of(context).maybePop(),
          ),
          title: const Text(
            'Rules',
            style: TextStyle(
              fontFamily: 'SF Pro Display',
              fontWeight: FontWeight.w600,
              fontSize: 20,
              color: Colors.black,
            ),
          ),
          centerTitle: false,
          bottom: PreferredSize(
            preferredSize: Size.fromHeight(1),
            child: Container(
              height: 1,
              color: Colors.grey[300],
            ),
          ),
          actions: [
            if (_rulesService.rules.isNotEmpty)
              GestureDetector(
                onTap: () async {
                  final result = await Get.to(() => const CreateRuleScreen());
                  if (result == true) {
                    await _loadRules(force: true);
                    setState(() {});
                  }
                },
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: Text(
                    'Add Rule',
                    style: TextStyle(
                      fontFamily: 'SF Pro Display',
                      fontWeight: FontWeight.w500,
                      fontSize: 14,
                      color: Color(0xFF007AFF),
                    ),
                  ),
                ),
              ),
            if (_searchQuery != null && _searchQuery!.isNotEmpty)
              IconButton(
                icon: const Icon(Icons.clear_rounded, color: Colors.grey),
                onPressed: () {
                  setState(() {
                    _searchController.clear();
                    _searchQuery = null;
                    _applySearch();
                  });
                },
              ),
          ],
        ),
        body: isLoading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFF007AFF)))
          : GestureDetector(
              behavior: HitTestBehavior.translucent,
              onTap: () {
                FocusScope.of(context).unfocus();
              },
              child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 8),
                
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 4),
                  child: TextField(
                    controller: _searchController,
                    focusNode: _searchFocusNode,
                    decoration: InputDecoration(
                      hintText: 'Search',
                      suffixIcon: Icon(Icons.search_rounded),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                      ),
                      filled: true,
                      fillColor: const Color(0xFFF5F5F7),
                      contentPadding: EdgeInsets.symmetric(vertical: 0, horizontal: 14),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide(color: Color(0xFF007AFF), width: 2),
                      ),
                      enabledBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide.none,
                      ),
                    ),
                  ),
                ),
                
                const SizedBox(height: 8),
                
                Expanded(child: _buildBody()),
              ],
            ),
          ),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () {
            Get.to(() => CreateOrderScreen());
          },
          backgroundColor: const Color(0xFF0A253B),
          elevation: 4,
          shape: const CircleBorder(),
          child: SvgPicture.asset(
            'assets/Create Order.svg',
            width: 28,
            height: 28,
            color: Colors.white,
          ),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        bottomNavigationBar: AppBottomBar(
          selectedIndex: 3,
          onOrderListTap: () => Get.to(() => OrderListScreen(from: 'rules')),
          onReportsTap: () => Get.to(() => report.ReportsScreen(from: 'rules')),
        ),
      ),
    );
  }

  Widget _buildBody() {
    return Obx(() {
      if (_rulesService.errorMessage.value.isNotEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline_rounded, size: 64, color: Colors.grey),
              const SizedBox(height: 12),
              Text(
                'Failed to load rules',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey,
              ),
            ),
            const SizedBox(height: 8),
              Text(
                _rulesService.errorMessage.value,
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.grey,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 12),
              ElevatedButton(
                onPressed: () async {
                  _rulesService.clearError();
                  await _loadRules(force: true);
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  foregroundColor: Colors.white,
                ),
                child: const Text('Retry'),
              ),
            ],
          ),
        );
      }

      final list = (_searchQuery != null && _searchQuery!.isNotEmpty) ? _filteredRules : _rulesService.rules;
      
      if (list.isEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.rule_rounded, size: 120, color: Colors.grey[300]),
              const SizedBox(height: 24),
              Text(
                'No rules available',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Create your first rule to get started',
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.grey[500],
                ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () async {
                  final result = await Get.to(() => const CreateRuleScreen());
                  if (result == true) {
                    await _loadRules(force: true);
                    setState(() {});
                  }
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF007AFF),
                  foregroundColor: Colors.white,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                child: const Text('Create Rule'),
              ),
            ],
          ),
        );
      }

      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.start,
            children: [
              Text(
                'Total Rules: ${list.length.toString().padLeft(2, '0')}',
                style: const TextStyle(
                  fontFamily: 'SF Pro Display',
                  fontWeight: FontWeight.w500,
                  fontSize: 14,
                  color: Colors.black,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Expanded(
            child: RefreshIndicator(
              onRefresh: _manualRefresh,
              child: AnimatedListViewSeparated(
              itemCount: list.length,
              separatorBuilder: (context, i) => const SizedBox(height: 8),
              padding: const EdgeInsets.only(bottom: 80), 
              itemBuilder: (context, i) {
                final rule = list[i];
                return Container(
                    margin: const EdgeInsets.only(top: 4, bottom: 4),
                    decoration: BoxDecoration(
                    color: const Color(0xFFF3F3F3),
                    borderRadius: BorderRadius.circular(12),
                    ),
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        
                        Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Expanded(
                              child: Padding(
                                padding: const EdgeInsets.only(top: 4),
                                child: Text(
                                  'Rule ID: ${rule['id']?.toString() ?? 'N/A'}',
                                  style: GoogleFonts.inter(fontWeight: FontWeight.w400, fontSize: 15),
                                ),
                              ),
                            ),
                            Column(
                              children: [
                                SizedBox(height: 2),
                                Container(
                                  constraints: const BoxConstraints(minWidth: 60, maxWidth: 90),
                                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                                  decoration: BoxDecoration(
                                    color: rule['status'] == '1'
                                        ? const Color(0xFF28C76F).withOpacity(0.1)
                                        : const Color(0xFFFF0000).withOpacity(0.1),
                                    borderRadius: BorderRadius.circular(16),
                                  ),
                                  alignment: Alignment.center,
                                  child: Text(
                                    rule['status'] == '1' ? 'Active' : 'Inactive',
                                    style: GoogleFonts.inter(
                                      color: rule['status'] == '1'
                                          ? const Color(0xFF28C76F)
                                          : const Color(0xFFFF0000),
                                      fontWeight: FontWeight.w500,
                                      fontSize: 15
                                    ),
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        
                        
                        Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                            Expanded(
                              child: Row(
                                crossAxisAlignment: CrossAxisAlignment.center,
                                children: [
                                  SizedBox(
                                    width: 100,
                                    child: Text('Rule Title', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                  ),
                                  const SizedBox(width: 36),
                                  Expanded(
                                    child: Text(rule['rule_title'] ?? rule['rule_name'] ?? 'Unnamed Rule', style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        
                        
                        Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Expanded(
                              child: Row(
                                  crossAxisAlignment: CrossAxisAlignment.center,
                                  children: [
                                    SizedBox(
                                    width: rule['courier_name'] != null &&
                                           rule['courier_name'].toString().length > 10
                                         ? 113
                                         : 98,
                                    child: Text('Courier', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                    ),
                                  const SizedBox(width: 26), 
                                    if ((rule['courier_name'] ?? '').toString().isNotEmpty)
                                      CourierLogoWidget(
                                        pngUrl: rule['courier_name']?.toString() ?? '',
                                        courierId: rule['courier_id']?.toString(),
                                        accountTitle: _getAccountTitleFromCustomerCourierId(rule['customer_courier_id']?.toString()),
                                        width: 78,
                                        height: 36,
                                        fit: BoxFit.contain,
                                    )
                                  else
                                    const SizedBox(height: 24),
                                ],
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        
                        
                        Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Expanded(
                              child: Row(
                                crossAxisAlignment: CrossAxisAlignment.center,
                                children: [
                                  SizedBox(
                                    width: 100,
                                    child: Text('Service Code', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                  ),
                                  const SizedBox(width: 36),
                                  Expanded(
                                    child: Text(_getServiceNameFromCode(rule['service_code']?.toString()), style: GoogleFonts.inter(fontWeight: FontWeight.w300)),
                                  ),
                                ],
                              ),
                                      ),
                                  ],
                                ),
                        const SizedBox(height: 4),
                        
                        
                        Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Expanded(
                              child: Row(
                                crossAxisAlignment: CrossAxisAlignment.center,
                                children: [
                                  SizedBox(
                                    width: 100,
                                    child: Text('Actions', style: GoogleFonts.inter(fontWeight: FontWeight.w400)),
                                  ),
                                  const SizedBox(width: 36),
                                  Expanded(
                                    child: Row(
                                      children: [
                                        
                                        GestureDetector(
                                          onTap: () => _navigateToEditRule(rule),
                                          child: Row(
                                            children: [
                                              SvgPicture.asset(
                                                'assets/Edit.svg',
                                                width: 18,
                                                height: 18,
                                                color: const Color(0xFF007AFF),
                                              ),
                                              const SizedBox(width: 4),
                                              Text('Edit', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                            ],
                                          ),
                                        ),
                                        const SizedBox(width: 20),
                                        
                                        GestureDetector(
                                          onTap: () => _showDeleteConfirmation(rule),
                                          child: Row(
                                            children: [
                                              SvgPicture.asset(
                                                'assets/Delete.svg',
                                                width: 18,
                                                height: 18,
                                                color: const Color(0xFF007AFF),
                                              ),
                                              const SizedBox(width: 4),
                                              Text('Delete', style: GoogleFonts.inter(color: Colors.black, fontWeight: FontWeight.w500)),
                                            ],
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        
                        
                        GestureDetector(
                          onTap: () {
                            _showRuleDetailsBottomSheet(context, rule);
                          },
                          child: Text(
                            'View Details',
                            style: GoogleFonts.inter(
                              color: const Color(0xFF007AFF),
                              fontWeight: FontWeight.w500,
                              fontSize: 14,
                              decoration: TextDecoration.none,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ),
        ],
      );
    });
  }

  void _showRuleDetailsBottomSheet(BuildContext context, Map<String, dynamic> rule) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: AnimationLimiter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(20, 20, 20, 32),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: AnimationConfiguration.toStaggeredList(
                    duration: const Duration(milliseconds: 500),
                    childAnimationBuilder: (widget) => SlideAnimation(
                      verticalOffset: 30.0,
                      child: FadeInAnimation(
                        child: widget,
                      ),
                    ),
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            children: [
                              const Text(
                                'Rule Details',
                                style: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  fontSize: 18,
                                  fontFamily: 'SF Pro Display',
                                ),
                              ),
                              const SizedBox(width: 12),
                              Container(
                                constraints: const BoxConstraints(minWidth: 70, maxWidth: 100),
                                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                decoration: BoxDecoration(
                                  color: rule['status'] == '1'
                                      ? const Color(0xFF28C76F).withOpacity(0.1)
                                      : const Color(0xFFFF0000).withOpacity(0.1),
                                  borderRadius: BorderRadius.circular(16),
                                ),
                                alignment: Alignment.center,
                                child: Text(
                                  rule['status'] == '1' ? 'Active' : 'Inactive',
                                  style: GoogleFonts.inter(
                                    color: rule['status'] == '1'
                                        ? const Color(0xFF28C76F)
                                        : const Color(0xFFFF0000),
                                    fontWeight: FontWeight.w500,
                                    fontSize: 15
                                  ),
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                            ],
                          ),
                          IconButton(
                            icon: const Icon(Icons.close_rounded),
                            onPressed: () => Navigator.of(context).pop(),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      _ruleDetailRow('Rule ID', rule['id']?.toString() ?? ''),
                      SizedBox(height: 10),
                      _ruleDetailRow('Rule Name', rule['rule_name'] ?? ''),
                      SizedBox(height: 10),
                      _ruleDetailRow('Rule Title', rule['rule_title'] ?? ''),
                      SizedBox(height: 10),
                      _ruleDetailRow('Courier Name', rule['courier_name'] ?? ''),
                      SizedBox(height: 10),
                      _ruleDetailRow('Service Code', _getServiceNameFromCode(rule['service_code']?.toString())),
                      SizedBox(height: 10),
                      _ruleDetailRow('Platform', rule['platform_name'] ?? ''),
                      SizedBox(height: 10),
                      _ruleDetailRow('Order Value', '${rule['order_value_type'] ?? ''} ${rule['order_value'] ?? '0'}'),
                      SizedBox(height: 10),
                      _ruleDetailRow('Weight', '${rule['weight_type'] ?? ''} ${rule['weight_value'] ?? '0'} kg'),
                      SizedBox(height: 10),

                      if (rule['keywords_id'] != null) ...[
                        SizedBox(height: 10),
                        _ruleDetailRow('Keywords ID', rule['keywords_id']?.toString() ?? ''),
                      ],
                      if (rule['is_contain'] != null) ...[
                        SizedBox(height: 10),
                        _ruleDetailRow('Is Contain', (rule['is_contain']?.toString() ?? '') == '1' ? 'Yes' : 'No'),
                      ],
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _ruleDetailRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        SizedBox(
          width: 100,
          child: Text(
            label,
            style: GoogleFonts.inter(fontWeight: FontWeight.w500, fontSize: 14),
          ),
        ),
        const SizedBox(width: 36),
        Expanded(
          child: Text(
            value.isEmpty ? '-' : value,
            style: GoogleFonts.inter(fontWeight: FontWeight.w300, fontSize: 13),
            textAlign: TextAlign.left,
          ),
        ),
      ],
    );
  }

  void _navigateToEditRule(Map<String, dynamic> rule) {
    
    Get.to(() => EditRuleScreen(ruleData: rule))?.then((result) {
      
      if (result == true) {
        _loadRules(force: true);
        customSnackBar('Success', 'Rule updated successfully!');
      }
    });
  }

  void _showDeleteConfirmation(Map<String, dynamic> rule) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          width: double.infinity,
          padding: EdgeInsets.only(
            left: 0,
            right: 0,
            bottom: MediaQuery.of(context).viewInsets.bottom,
          ),
          decoration: const BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(32)),
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  decoration: const BoxDecoration(
                    color: Color(0xFFE6F0FF),
                    shape: BoxShape.circle,
                  ),
                  padding: const EdgeInsets.all(20),
                  child: SvgPicture.asset('assets/Delete.svg', width: 64, height: 64, color: const Color(0xFF007AFF)),
                ),
                const SizedBox(height: 24),
                const Text(
                  'Are you Sure?',
                  style: TextStyle(fontWeight: FontWeight.w700, fontSize: 22, color: Colors.black),
                ),
                const SizedBox(height: 8),
                Text(
                  'You want to delete "${rule['rule_name'] ?? 'this rule'}"',
                  style: const TextStyle(fontWeight: FontWeight.w400, fontSize: 15, color: Color(0xFF8E8E93)),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 28),
                Row(
                  children: [
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFF2F2F7),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 10),
                        ),
                        child: const Text('No', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.black)),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () async {
                          Navigator.of(context).pop();
                          
                         
                          
                          
                          String? acnoToUse = _acno ?? rule['acno']?.toString();
                          
                          if (acnoToUse != null && rule['id'] != null) {
                           
                            
                            final success = await _rulesService.deleteRule(
                              acno: acnoToUse,
                              ruleId: rule['id'].toString(),
                            );
                            
                            
                            
                            if (success) {
                              customSnackBar('Success', 'Rule deleted successfully');
                              // Clear cache and refresh data to show updated count
                              clearRulesCache();
                              _needsRefresh = true;
                              await _loadRules(force: true);
                            } else {
                              customSnackBar('Error', _rulesService.errorMessage.value);
                            }
                          } else {
                            
                            customSnackBar('Error', 'Missing required data for deletion');
                          }
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          elevation: 0,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.symmetric(vertical: 10),
                        ),
                        child: const Text('Yes', style: TextStyle(fontWeight: FontWeight.w500, fontSize: 15, color: Colors.white)),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_fonts/google_fonts.dart';
import '../controllers/sign_in_controller.dart';
import '../services/connectivity_service.dart';
import '../widgets/connectivity_wrapper.dart';
import 'create_account_screen.dart';
import 'forgot_password_screen.dart';

class SignInScreen extends StatelessWidget {
  SignInScreen({Key? key}) : super(key: key);
  final SignInController controller = Get.put(SignInController());

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    final width = size.width;
    final height = size.height;
    
    double blockH = height / 100;
    double blockW = width / 100;

    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: const SystemUiOverlayStyle(
        statusBarColor: Colors.white,
        statusBarIconBrightness: Brightness.dark,
        statusBarBrightness: Brightness.light,
        systemNavigationBarColor: Colors.white,
        systemNavigationBarIconBrightness: Brightness.dark,
      ),
      child: ConnectivityWrapper(
        showOfflineUI: true,
        child: Scaffold(
          backgroundColor: Colors.white,
          body: SafeArea(
            child: SingleChildScrollView(
              physics: const BouncingScrollPhysics(),
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: blockW * 6),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    SizedBox(height: blockH * 14), 
                    Text(
                      'Sign In',
                      style: GoogleFonts.poppins(
                        fontWeight: FontWeight.w700,
                        fontSize: blockW * 8.2, 
                        color: Colors.black,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    SizedBox(height: blockH * 1.2),
                    Text(
                      "and let's get those orders moving!",
                      style: GoogleFonts.manrope(
                        fontWeight: FontWeight.w400,
                        fontSize: blockW * 3.8,
                        color: Colors.black 
                      ),
                      textAlign: TextAlign.center,
                    ),
                    SizedBox(height: blockH * 2.5),
                    Obx(() => Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Container(
                          decoration: BoxDecoration(
                            color: const Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(blockW * 2), 
                            border: controller.emailError.value
                                ? Border.all(color: Colors.red, width: 1.5)
                                : null,
                          ),
                          child: TextField(
                            controller: controller.emailController,
                            autofillHints: null, 
                            style: GoogleFonts.inter(
                              fontWeight: FontWeight.w400,
                              fontSize: blockW * 3.5, 
                              color: Colors.black,
                            ),
                            decoration: InputDecoration(
                              hintText: 'Email',
                              hintStyle: GoogleFonts.inter(
                                fontWeight: FontWeight.w400,
                                fontSize: blockW * 3.5, 
                                color: Colors.black,
                              ),
                              border: InputBorder.none,
                              contentPadding: EdgeInsets.symmetric(horizontal: blockW * 4, vertical: blockH * 2.2),
                            ),
                            keyboardType: TextInputType.emailAddress,
                          ),
                        ),
                        if (controller.emailError.value)
                          Padding(
                            padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                            child: Obx(() => Text(
                              controller.emailErrorMessage.value.isEmpty ? 'Email is required' : controller.emailErrorMessage.value,
                              style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                            )),
                          ),
                      ],
                    )),
                    SizedBox(height: blockH * 2),
                    Obx(() => Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Container(
                          decoration: BoxDecoration(
                            color: const Color(0xFFF3F3F3),
                            borderRadius: BorderRadius.circular(blockW * 2), 
                            border: controller.passwordError.value
                                ? Border.all(color: Colors.red, width: 1.5)
                                : null,
                          ),
                          child: TextField(
                            controller: controller.passwordController,
                            obscureText: controller.obscurePassword.value,
                            autofillHints: null, 
                            style: GoogleFonts.inter(
                              fontWeight: FontWeight.w400,
                              fontSize: blockW * 3.5, 
                              color: Colors.black,
                            ),
                            decoration: InputDecoration(
                              hintText: 'Password',
                              hintStyle: GoogleFonts.inter(
                                fontWeight: FontWeight.w400,
                                fontSize: blockW * 3.5, 
                                color: Colors.black,
                              ),
                              border: InputBorder.none,
                              contentPadding: EdgeInsets.symmetric(horizontal: blockW * 4, vertical: blockH * 2.2),
                              suffixIcon: IconButton(
                                icon: Icon(
                                  controller.obscurePassword.value ? Icons.visibility_off_rounded : Icons.visibility_rounded,
                                  color: Colors.black,
                                  size: blockW * 6,
                                ),
                                onPressed: () => controller.obscurePassword.value = !controller.obscurePassword.value,
                              ),
                            ),
                          ),
                        ),
                        if (controller.passwordError.value)
                          Padding(
                            padding: EdgeInsets.only(left: blockW * 4, top: 2, bottom: 2),
                            child: Obx(() => Text(
                              controller.passwordErrorMessage.value.isEmpty ? 'Password is required' : controller.passwordErrorMessage.value,
                              style: TextStyle(color: Colors.red, fontSize: blockW * 3.2),
                            )),
                          ),
                      ],
                    )),
                    SizedBox(height: blockH * 1.1),
                    Obx(() => Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            Checkbox(
                              value: controller.rememberMe.value,
                              onChanged: (val) => controller.rememberMe.value = val ?? false,
                              activeColor: const Color(0xFF007AFF),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                              visualDensity: VisualDensity.compact,
                            ),
                            Text(
                              'Remember Me',
                              style: GoogleFonts.inter(
                                fontWeight: FontWeight.w500,
                                fontSize: blockW * 3.8,
                                color: Colors.black,
                              ),
                            ),
                          ],
                        ),
                        TextButton(
                          onPressed: () {
                            Get.to(() => const ForgotPasswordScreen());
                          },
                          style: TextButton.styleFrom(
                            padding: EdgeInsets.zero,
                            minimumSize: Size(0, 0),
                            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            alignment: Alignment.centerRight,
                          ),
                          child: Text(
                            'Forgot Password?',
                            style: GoogleFonts.inter(
                              fontWeight: FontWeight.w500,
                              fontSize: blockW * 3.8, 
                              color: Colors.black,
                            ),
                          ),
                        ),
                      ],
                    )),
                    SizedBox(height: blockH * 1.1),
                    Obx(() => SizedBox(
                      height: blockH * 6.2, 
                      child: ElevatedButton(
                        onPressed: controller.authService.isLoading.value ? null : controller.signIn,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF007AFF),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(blockW * 2),
                          ),
                          elevation: 0,
                        ),
                        child: controller.authService.isLoading.value
                            ? SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                ),
                              )
                            : Text(
                                'Sign in',
                                style: GoogleFonts.inter(
                                  fontWeight: FontWeight.w600,
                                  fontSize: blockW * 4.4, 
                                  color: Colors.white,
                                ),
                              ),
                      ),
                    )),


                  ],
                ),
              ),
            ),
          ),
        ),
      ), 
    ); 
  }
} 
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'sign_in_screen.dart';


class SplashScreen extends StatefulWidget {
  const SplashScreen({Key? key}) : super(key: key);

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    SystemChrome.setEnabledSystemUIMode(
      SystemUiMode.manual,
      overlays: [SystemUiOverlay.top],
    );
    Future.delayed(const Duration(milliseconds: 800), () {
      if (mounted) {
        Get.offAll(() => SignInScreen());
      }
    });
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.edgeToEdge);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: const SystemUiOverlayStyle(
        statusBarColor: Color(0xFF007AFF),
        statusBarIconBrightness: Brightness.light,
        statusBarBrightness: Brightness.dark, 
        systemNavigationBarColor: Color(0xFF007AFF),
        systemNavigationBarIconBrightness: Brightness.light,
      ),
      child: Scaffold(
        backgroundColor: const Color(0xFF007AFF),
        body: Center(
          child: SvgPicture.asset(
            'assets/Frame.svg',
            width: 60,
            height: 60,
            color: Colors.white,
          ),
        ),
      ),
    );
  }
}
ADD_B:
		; Prompt for ISBN
		INVOKE MSG_DISPLAY, ADDR ISBN_PROMPT
		mov edx, OFFSET BOOK_ISBN_BUF
		mov ecx, 20
		CALL READSTRING
		
		; Validate ISBN: must be in format ddd-d-dd-dddddd-d (17 chars, dashes at 4,6,9,16)
		mov esi, OFFSET BOOK_ISBN_BUF
		mov ecx, 0
		mov edi, OFFSET ISBN_SEARCH_BUF ; reuse as temp
	validate_isbn_strict_loop:
		mov al, [esi+ecx]
		cmp al, 0
		je validate_isbn_strict_end
		mov edx, ecx
		inc edx
		cmp ecx, 3
		je check_dash
		cmp ecx, 5
		je check_dash
		cmp ecx, 8
		je check_dash
		cmp ecx, 15
		je check_dash
		; All other positions must be digits
		cmp al, '0'
		jb validate_isbn_invalid
		cmp al, '9'
		ja validate_isbn_invalid
		mov [edi], al
		inc edi
		inc ecx
		jmp validate_isbn_strict_loop
	check_dash:
		cmp al, '-'
		jne validate_isbn_invalid
		inc ecx
		jmp validate_isbn_strict_loop
	validate_isbn_strict_end:
		cmp ecx, 17
		jne invalid_isbn
		mov byte ptr [edi], 0
		jmp after_isbn_validation
	validate_isbn_invalid:
		jmp invalid_isbn
	after_isbn_validation:
		
		; Prompt for book name
		INVOKE MSG_DISPLAY, ADDR BOOK_NAME_PROMPT
		mov edx, OFFSET BOOK_NAME_BUF
		mov ecx, BOOK_NAME_SIZE
		CALL READSTRING
		
		; Prompt for author name
		INVOKE MSG_DISPLAY, ADDR BOOK_AUTHOR_PROMPT
		mov edx, OFFSET BOOK_AUTHOR_BUF
		mov ecx, BOOK_AUTHOR_SIZE
		CALL READSTRING
		
		; Prompt for publisher name
		INVOKE MSG_DISPLAY, ADDR BOOK_PUBLISHER_PROMPT
		mov edx, OFFSET BOOK_PUBLISHER_BUF
		mov ecx, BOOK_PUBLISHER_SIZE
		CALL READSTRING
		
		
		; Prompt for genre
		INVOKE MSG_DISPLAY, ADDR BOOK_GENRE_PROMPT
		mov edx, OFFSET BOOK_GENRE_BUF
		mov ecx, BOOK_GENRE_SIZE
		CALL READSTRING
		
		; Prompt for publishing year
		INVOKE MSG_DISPLAY, ADDR BOOK_YEAR_PROMPT
		mov edx, OFFSET BOOK_YEAR_BUF
		mov ecx, 10
		CALL READSTRING
	
		INC NUM_BOOKS
		
		; Write book data to BOOKS.txt file
		INVOKE CreateFile,
			ADDR BOOKS_FILE,    ; lpFileName
			GENERIC_WRITE,       ; dwDesiredAccess
			DO_NOT_SHARE,        ; dwShareMode
			NULL,                ; lpSecurityAttributes
			OPEN_ALWAYS,         ; dwCreationDisposition
			FILE_ATTRIBUTE_NORMAL, ; dwFlagsAndAttributes
			0                    ; hTemplateFile
		mov filehandle, eax

		; Move file pointer to end for appending
		INVOKE SetFilePointer, filehandle, 0, 0, FILE_END

		; Write book name
		mov edx, OFFSET BOOK_NAME_BUF
		INVOKE Str_length, edx
		cmp eax, 0
		je skip_name_write
	    mov ecx, eax          ; length of book name (from Str_length) to write
		mov eax, filehandle
		call WriteToFile
	skip_name_write:
		; write comma separator
		mov eax, filehandle
		mov edx, OFFSET COMMA_BYTE
		mov ecx, 1
		call WriteToFile
		; write author
		mov edx, OFFSET BOOK_AUTHOR_BUF
		INVOKE Str_length, edx
		mov ecx, eax
		mov eax, filehandle
		call WriteToFile
		; write comma separator
		mov eax, filehandle
		mov edx, OFFSET COMMA_BYTE
		mov ecx, 1
		call WriteToFile
		; write publisher
		mov edx, OFFSET BOOK_PUBLISHER_BUF
		INVOKE Str_length, edx
		mov ecx, eax
		mov eax, filehandle
		call WriteToFile
		; write comma separator
		mov eax, filehandle
		mov edx, OFFSET COMMA_BYTE
		mov ecx, 1
		call WriteToFile
		; write genre
		mov edx, OFFSET BOOK_GENRE_BUF
		INVOKE Str_length, edx
		mov ecx, eax
		mov eax, filehandle
		call WriteToFile
		; write comma separator
		mov eax, filehandle
		mov edx, OFFSET COMMA_BYTE
		mov ecx, 1
		call WriteToFile
		; write year
		mov edx, OFFSET BOOK_YEAR_BUF
		INVOKE Str_length, edx
		mov ecx, eax
		mov eax, filehandle
		call WriteToFile
		; write comma separator
		mov eax, filehandle
		mov edx, OFFSET COMMA_BYTE
		mov ecx, 1
		call WriteToFile
		; write ISBN
		mov edx, OFFSET BOOK_ISBN_BUF
		INVOKE Str_length, edx
		mov ecx, eax
		mov eax, filehandle
		call WriteToFile
		; write CRLF after the entry
		mov eax, filehandle
		mov edx, OFFSET CRLF_BYTES
		mov ecx, 2
		call WriteToFile
		invoke CloseHandle, filehandle
		; Display success message
		INVOKE MSG_DISPLAY, ADDR BOOK_ADDED_MSG
		
		JMP SHOW_FULL_MENU
		
	invalid_isbn:
		INVOKE MSG_DISPLAY, ADDR INVALID_ISBN_MSG
		JMP SHOW_FULL_MENU

;------------------------------------
;-------VIEW BOOKS FROM FILE--------
;------------------------------------
VIEW_BFILE:
	INVOKE CreateFile,
		ADDR BOOKS_FILE,
		GENERIC_READ,
		DO_NOT_SHARE,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		0
	mov filehandle, eax
	CALL ReadAllBooks
	mov esi, OFFSET BUFFER_BOOK
	xor ebx, ebx
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je vb_done

vb_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge vb_done

	lea edi, [OFFSET BUFFER_BOOK + ebx]
	xor ecx, ecx
vb_find_eol:
	mov al, [edi + ecx]
	cmp al, 0
	je vb_proc_line
	cmp al, 0Dh
	je vb_proc_line
	cmp al, 0Ah
	je vb_proc_line
	inc ecx
	jmp vb_find_eol
vb_proc_line:
	cmp ecx, 0
	je vb_advance_only

	; Temporarily null-terminate the line
	mov al, [edi + ecx]
	push eax
	mov byte ptr [edi + ecx], 0
	mov edx, edi
	call DisplayBookLine
	pop eax
	mov [edi + ecx], al

	add ebx, ecx
	; skip CR/LF if present
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne vb_loop_continue
	inc ebx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne vb_loop_continue
	inc ebx
vb_loop_continue:
	jmp vb_loop

vb_advance_only:
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne vb_loop_continue
	inc ebx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne vb_loop_continue
	inc ebx
	jmp vb_loop

vb_done:
	JMP SHOW_FULL_MENU

.DATA

; --- Global variables for fines/overdue routines ---
CURRENT_DATE_DWORD DWORD 0
OVERDUE_COUNT DWORD 0
LINE_START_PTR DWORD 0

.DATA

topMsg BYTE 0AH
    BYTE    "--------------------------------------------",0dh,0ah
    BYTE    "--  WELCOME TO LIBRARY MANAGEMENT SYSTEM  --",0dh,0ah
    BYTE    "--------------------------------------------",0dh,0ah,0ah
    BYTE    "1-> Librarian",0dh,0ah
    BYTE    "2-> Member",0dh,0ah
    BYTE    "3-> Exit",0dh,0ah
    BYTE    "Choose Your Option : ",0

msg1     BYTE 0AH
    BYTE    "Librarian Menu:", 0dh, 0ah
    BYTE    "1. View Overdue Books", 0dh,0ah
    BYTE    "2. Calculate Fines", 0dh,0ah
    BYTE    "3. Add Book", 0dh,0ah
    BYTE    "4. Display All Books", 0dh,0ah
    BYTE    "5. Display All Users", 0dh,0ah
    BYTE    "6. View Issued Books", 0dh,0ah
    BYTE    "7. Logout", 0dh,0ah
    BYTE    "Choose Your Option : ",0
    LIB_LOGIN_MSG BYTE 0AH, "Enter librarian code: ",0
    INVALID_CODE_MSG BYTE 0AH, "Invalid code. Returning to top menu.",0dh,0ah,0
    LIB_SUCCESS_MSG BYTE 0AH, "Login successful! Welcome, Librarian.",0dh,0ah,0

MEMBER_MENU_MSG BYTE 0Ah, "1-> Sign In",0dh,0ah, "2-> Register",0dh,0ah, "Choose Your Option : ",0
MEMBER_SUCCESS_MSG BYTE 0AH, "Login successful! Welcome, ",0
MEMBER_SUCCESS_MSG2 BYTE ".",0dh,0ah,0
PASS_TOO_SHORT_MSG db "Password must be at least 8 characters long!",0


MEMBER_OPTIONS_MSG BYTE 0Ah
    BYTE    "Member Menu:",0dh,0ah
    BYTE    "1. Search a Book",0dh,0ah
    BYTE    "2. Issue Book",0dh,0ah
    BYTE    "3. Return Book",0dh,0ah
    BYTE    "4. View Sorted Books",0dh,0ah
    BYTE    "5. Logout",0dh,0ah
    BYTE    "Select an option: ",0

SEARCH_MENU_MSG BYTE 0Ah
    BYTE    "Search Menu:",0dh,0ah
    BYTE    "1. By Name",0dh,0ah
    BYTE    "2. By Author",0dh,0ah
    BYTE    "3. By Publisher",0dh,0ah
    BYTE    "4. By Year",0dh,0ah
    BYTE    "5. Back",0dh,0ah
    BYTE    "Select an option: ",0
 
SORT_MENU_MSG BYTE 0Ah
    BYTE    "Sort Menu:",0dh,0ah
    BYTE    "1. Name (Ascending)",0dh,0ah
    BYTE    "2. Name (Descending)",0dh,0ah
    BYTE    "3. Author (Ascending)",0dh,0ah
    BYTE    "4. Author (Descending)",0dh,0ah
    BYTE    "5. Publisher (Ascending)",0dh,0ah
    BYTE    "6. Publisher (Descending)",0dh,0ah
    BYTE    "7. Year (Ascending)",0dh,0ah
    BYTE    "8. Year (Descending)",0dh,0ah
    BYTE    "9. ISBN (Ascending)",0dh,0ah
    BYTE    "10. ISBN (Descending)",0dh,0ah
    BYTE    "11. Back",0dh,0ah
    BYTE    "Select an option: ",0

SIGNIN_USER_MSG BYTE "Enter username: ",0
SIGNIN_PASS_MSG BYTE "Enter password: ",0
INVALID_CRED_MSG BYTE 0Ah, "Invalid email or password.",0dh,0ah,0

NO_BOOKS_MSG BYTE 0Ah, "No books found.",0Dh,0Ah,0
OVERDUE_BOOKS_HEADER BYTE 0Ah, "========== OVERDUE BOOKS ==========" ,0dh,0ah,0
NO_OVERDUE_MSG BYTE 0Ah, "No overdue books found.",0dh,0ah,0
ISSUED_BOOKS_HEADER BYTE 0Ah, "========== ISSUED BOOKS ==========" ,0dh,0ah,0
NO_ISSUED_MSG BYTE 0Ah, "No books are currently issued.",0dh,0ah,0
OVERDUE_SEPARATOR BYTE "-----------------------------------",0dh,0ah,0
USERNAME_LABEL BYTE "Username: ",0
ISSUE_DATE_LABEL BYTE "Issue Date: ",0
RETURN_DATE_LABEL BYTE "Return Date: ",0
FINES_HEADER BYTE 0Ah, "========== CALCULATE FINES ==========" ,0dh,0ah,0
DAYS_OVERDUE_LABEL BYTE "Days Overdue: ",0
FINE_AMOUNT_LABEL BYTE "Fine Amount: Rs. ",0
TOTAL_FINE_LABEL BYTE 0Ah, "Total Fines: Rs. ",0
NO_FINES_MSG BYTE 0Ah, "No fine to collect for this book. Book not found or returned on time!",0dh,0ah,0
FINE_RATE_MSG BYTE "(Fine rate: Rs. 10 per day)",0dh,0ah,0

USERNAME_BUF BYTE 20 DUP(?)
PASSWORD_BUF BYTE 10 DUP(?)
COMMA_BYTE BYTE ',',0
LINE_USER_BUF BYTE 20 DUP(?)
LINE_PASS_BUF BYTE 10 DUP(?)
REG_MSG    BYTE "Enter Name: ",0
VIEW_MEMBERS_MSG BYTE 0Ah,"    Viewing Registered Members: ",0AH, 0DH, 0
ADD_MSG             BYTE "    Enter Book Name & Author Name to Add: ", 0dh, 0ah,
                 "    Separated By Comma:",0
VIEW_BOOKS_MSG BYTE 0Ah, "    Viewing Books in Library: ",  0dh, 0ah, 0
EXIT_MSG       BYTE 0AH,
                    " ------------------------------ ",0dh, 0ah,
                    "   Exiting Program",0dh, 0ah,
                    "    See you again ",0dh, 0ah,
                    " ------------------------------", 0
                    
    CRLF_BYTES BYTE 0Dh,0Ah,0
    NAME_LABEL BYTE "Name: ",0
    AUTHOR_LABEL BYTE "Author: ",0
    PUBLISHER_LABEL BYTE "Publisher: ",0
    GENRE_LABEL BYTE "Genre: ",0
    YEAR_LABEL BYTE "Year: ",0
    ISBN_LABEL BYTE "ISBN: ",0
                    


; Overdue file and related variables
OVERDUE_FILE BYTE "data\\overdue.csv",0
overduefile DWORD ?
bytesWritten DWORD ?


bool           DWORD ?
MEMBERS_FILE   BYTE "data\\MEMBERS.csv",0
BOOKS_FILE     BYTE "data\\BOOKS.csv",0
ISSUED_BOOKS_FILE BYTE "data\\ISSUED_BOOKS.csv",0
filehandle     DWORD ?
BUFFER_SIZE = 5000
buffer_mem   BYTE buffer_size DUP (?)
buffer_book  BYTE buffer_size DUP (?)
bytesRead dword 1 dup(0)
; Librarian menu options
VIEW_OVERDUE    DWORD 1
CALCULATE_FINES DWORD 2
ADD_BOOK     DWORD 3
DISPLAY_BOOKS     DWORD 4
DISPLAY_USERS     DWORD 5
VIEW_ISSUED_BOOKS DWORD 6
LIB_LOGOUT     DWORD 7

; Member menu options
SEARCH_BOOK     DWORD 1
ISSUE_BOOK     DWORD 2
RETURN_BOOK     DWORD 3
VIEW_SORTED     DWORD 4
MEMBER_LOGOUT DWORD 5

; Search menu options
SEARCH_BY_NAME     DWORD 1
SEARCH_BY_AUTHOR DWORD 2
SEARCH_BY_PUBLISHER DWORD 3
SEARCH_BY_YEAR     DWORD 4
SEARCH_BACK     DWORD 5    
MEMBER_SIZE = 20
MEMBER1 DB MEMBER_SIZE DUP (?)
MEMBER2 DB MEMBER_SIZE DUP (?)
MEMBER3 DB MEMBER_SIZE DUP (?)
MEMBER4 DB MEMBER_SIZE DUP (?)
MEMBER5 DB MEMBER_SIZE DUP (?)
MEMBER6 DB MEMBER_SIZE DUP (?)

NUM_MEMBERS DWORD 0
MEMBERS DD MEMBER1, MEMBER2, MEMBER3, MEMBER4, MEMBER5, MEMBER6, 0AH, 0DH, 0

BOOK_SIZE = 30
BOOK1 DB BOOK_SIZE DUP (?)
BOOK2 DB BOOK_SIZE DUP (?)
BOOK3 DB BOOK_SIZE DUP (?)
BOOK4 DB BOOK_SIZE DUP (?)
BOOK5 DB BOOK_SIZE DUP (?)
BOOK6 DB BOOK_SIZE DUP (?)
NUM_BOOKS DWORD 0
BOOKS DD BOOK1, BOOK2, BOOK3, BOOK4, BOOK5, BOOK6, 0AH, 0DH, 0

; Book structure variables
BOOK_STRUCT_SIZE = 200
CURRENT_BOOK DB BOOK_STRUCT_SIZE DUP (?)
BOOK_NAME_SIZE = 150
BOOK_AUTHOR_SIZE = 150
BOOK_PUBLISHER_SIZE = 150
BOOK_GENRE_SIZE = 100


; Book input buffers
BOOK_NAME_BUF DB BOOK_NAME_SIZE DUP (?)
BOOK_AUTHOR_BUF DB BOOK_AUTHOR_SIZE DUP (?)
BOOK_PUBLISHER_BUF DB BOOK_PUBLISHER_SIZE DUP (?)
BOOK_GENRE_BUF DB BOOK_GENRE_SIZE DUP (?)
BOOK_YEAR_BUF DB 10 DUP (?)
BOOK_ISBN_BUF DB 20 DUP (?)

; Temp buffers used by search routines
TEMP_FIELD DB 200 DUP(?)
TEMP_LINE  DB 512 DUP(?)

; Book input prompts
ISBN_PROMPT BYTE "Enter ISBN: ",0
BOOK_NAME_PROMPT BYTE "Enter book name: ",0
BOOK_AUTHOR_PROMPT BYTE "Enter author name: ",0
BOOK_PUBLISHER_PROMPT BYTE "Enter publisher name: ",0
BOOK_GENRE_PROMPT BYTE "Enter Genre: ",0
BOOK_YEAR_PROMPT BYTE "Enter publishing year: ",0
INVALID_ISBN_MSG BYTE "You must enter a valid 13 digit ISBN number.",0dh,0ah,0
DUPLICATE_ISBN_MSG BYTE "That book already exists. Please check the ISBN number again.",0dh,0ah,0
BOOK_ADDED_MSG BYTE "Book added successfully!",0dh,0ah,0

; Issue/Return book messages
ISSUE_BOOK_MSG BYTE 0Ah, "Issue Book",0dh,0ah, "Enter ISBN of book to issue: ",0
RETURN_BOOK_MSG BYTE 0Ah, "Return Book",0dh,0ah, "Enter ISBN of book to return: ",0
BOOK_NOT_FOUND_MSG BYTE "Book not found in library.",0dh,0ah,0
BOOK_ISSUED_SUCCESS_MSG BYTE "Book issued successfully!",0dh,0ah,0
BOOK_ALREADY_ISSUED_MSG BYTE "This book is already issued.",0dh,0ah,0
BOOK_RETURNED_SUCCESS_MSG BYTE "Book returned successfully!",0dh,0ah,0
BOOK_NOT_ISSUED_MSG BYTE "This book was not issued to any member.",0dh,0ah,0
BOOK_LIMIT_REACHED_MSG BYTE "You have reached the maximum limit of 5 issued books.",0dh,0ah, "Please return a book before issuing a new one.",0dh,0ah,0

; ISBN search buffer
ISBN_SEARCH_BUF DB 20 DUP(?)

; Date buffer for issue/return
DATE_BUF DB 20 DUP(?)
RETURN_DATE_BUF DB 20 DUP(?)
ISSUED_BOOK_NAME_BUF DB 150 DUP(?)
CURRENT_DATE_BUF DB 20 DUP(?)
PARSED_RETURN_DATE_BUF DB 20 DUP(?)
OVERDUE_USERNAME_BUF DB 20 DUP(?)
OVERDUE_BOOKNAME_BUF DB 150 DUP(?)
OVERDUE_ISBN_BUF DB 20 DUP(?)
OVERDUE_ISSUE_DATE_BUF DB 20 DUP(?)
DAYS_OVERDUE_BUF DB 10 DUP(?)
FINE_AMOUNT_BUF DB 20 DUP(?)
FINE_RATE DWORD 10  ; Rs. 10 per day fine

; ISBN validation constants
ISBN_CHECK QWORD 1000000000000
VALID_ISBN_MIN QWORD 1000000000000
VALID_ISBN_MAX QWORD 9999999999999

; Sorting structures
MAX_BOOKS = 100
LINE_POINTERS DD MAX_BOOKS DUP(?)
LINE_LENGTHS DD MAX_BOOKS DUP(?)
NUM_LINES DWORD 0
SORT_TEMP_LINE DB 512 DUP(?)
VIEW_OVERDUE_FUNC:
	; Display overdue books header
	INVOKE MSG_DISPLAY, ADDR OVERDUE_BOOKS_HEADER

	; Reset overdue count for this view
	mov DWORD PTR [OVERDUE_COUNT], 0

	; Get current date
	push eax
	push ebx
	push ecx
	push edx

	sub esp, 16
	mov esi, esp
	INVOKE GetLocalTime, esi

	; Extract day, month, year
	movzx eax, WORD PTR [esi+2]  ; wMonth
	movzx ebx, WORD PTR [esi+6]  ; wDay
	movzx ecx, WORD PTR [esi]    ; wYear
	add esp, 16

	; Store current date values for comparison
	; Convert to comparable format: YYYYMMDD
	; Current date = year*10000 + month*100 + day
	push eax  ; save month
	mov eax, ecx  ; year
	mov edx, 10000
	mul edx
	mov ecx, eax  ; ecx = year * 10000
	pop eax       ; restore month
	push ebx      ; save day
	mov edx, 100
	mul edx
	add ecx, eax  ; ecx += month * 100
	pop eax       ; get day
	add ecx, eax  ; ecx += day
	; Now ecx contains current date as YYYYMMDD
	mov DWORD PTR [CURRENT_DATE_DWORD], ecx ; store globally instead of on stack

	; Read ISSUED_BOOKS.txt
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	jne overdue_file_ok
	; File could not be opened, show no-overdue message
	JMP overdue_no_books
overdue_file_ok:
	
	mov filehandle, eax
	INVOKE ReadFile, filehandle, ADDR buffer_mem, BUFFER_SIZE, ADDR bytesRead, 0
	INVOKE CloseHandle, filehandle

	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	jne overdue_buffer_ok
	; Empty file, treat as no overdue books
	JMP overdue_no_books_cleanup
overdue_buffer_ok:
	
	; Null-terminate buffer
	mov edi, OFFSET buffer_mem
	mov ecx, DWORD PTR bytesRead
	mov byte ptr [edi + ecx], 0

	xor ebx, ebx  ; offset in buffer
	
overdue_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge overdue_check_count
	
	lea edi, [OFFSET buffer_mem + ebx]
	
	; Find line length
	xor ecx, ecx
overdue_find_eol:
	mov al, [edi + ecx]
	cmp al, 0
	je overdue_process_line
	cmp al, 0Dh
	je overdue_process_line
	inc ecx
	jmp overdue_find_eol
	
overdue_process_line:
overdue_line_done:
overdue_advance:
	cmp ecx, 0
	je overdue_pop_and_advance

	push ecx
	push edi

	; Parse line: username,bookname,ISBN,issuedate,returndate
	; Extract return date (5th field)
	mov esi, edi
	xor edx, edx  ; comma counter

overdue_skip_to_return_date:
	mov al, [esi]
	cmp al, 0
	je overdue_pop_and_advance
	cmp al, 0Dh
	je overdue_pop_and_advance
	cmp al, ','
	jne overdue_skip_char
	inc edx
	cmp edx, 4
	je overdue_found_return_date
overdue_skip_char:
	inc esi
	jmp overdue_skip_to_return_date

overdue_found_return_date:
	; Skip comma
	inc esi

	; Copy return date to PARSED_RETURN_DATE_BUF
	push edi
	mov edi, OFFSET PARSED_RETURN_DATE_BUF
overdue_copy_date:
	mov al, [esi]
	cmp al, 0
	je overdue_date_copied
	cmp al, 0Dh
	je overdue_date_copied
	cmp al, 0Ah
	je overdue_date_copied
	mov [edi], al
	inc esi
	inc edi
	jmp overdue_copy_date

overdue_date_copied:
	mov byte ptr [edi], 0
	pop edi
    
	; Parse return date DD/MM/YYYY and convert to YYYYMMDD
	push edi
	mov esi, OFFSET PARSED_RETURN_DATE_BUF
    
	; Extract day (first 2 chars)
	movzx eax, byte ptr [esi]
	sub al, '0'
	mov bl, 10
	mul bl
	movzx edx, byte ptr [esi+1]
	sub dl, '0'
	add al, dl
	movzx eax, al
	push eax  ; save day
    
	; Extract month (chars 3-4, after '/')
	movzx eax, byte ptr [esi+3]
	sub al, '0'
	mov bl, 10
	mul bl
	movzx edx, byte ptr [esi+4]
	sub dl, '0'
	add al, dl
	movzx eax, al
	push eax  ; save month
    
	; Extract year (chars 6-9, after second '/')
	movzx eax, byte ptr [esi+6]
	sub al, '0'
	mov dx, 1000
	mul dx
	movzx ecx, ax
    
	movzx eax, byte ptr [esi+7]
	sub al, '0'
	mov dx, 100
	mul dx
	add ecx, eax
    
	movzx eax, byte ptr [esi+8]
	sub al, '0'
	mov dx, 10
	mul dx
	add ecx, eax
    
	movzx eax, byte ptr [esi+9]
	sub al, '0'
	add ecx, eax
    
	; Now ecx = year, calculate YYYYMMDD
	mov eax, ecx
	mov edx, 10000
	mul edx
	mov ecx, eax  ; ecx = year * 10000
    
	pop eax  ; get month
	mov edx, 100
	mul edx
	add ecx, eax  ; ecx += month * 100
    
	pop eax  ; get day
	add ecx, eax  ; ecx += day
    
	pop edi
    
	; Compare with current date
	mov eax, DWORD PTR [CURRENT_DATE_DWORD]  ; get current date (YYYYMMDD)
	cmp ecx, eax
	jge overdue_pop_and_advance  ; return date >= current date, not overdue
    
	; Book is overdue! Extract and display details
	; Extract all fields from line
	mov esi, edi
    
	; Field 1: Username
	mov edi, OFFSET OVERDUE_USERNAME_BUF
overdue_extract_user:
	mov al, [esi]
	cmp al, ','
	je overdue_user_done
	mov [edi], al
	inc esi
	inc edi
	jmp overdue_extract_user
overdue_user_done:
	mov byte ptr [edi], 0
	inc esi
    
	; Field 2: Book name
	mov edi, OFFSET OVERDUE_BOOKNAME_BUF
overdue_extract_book:
	mov al, [esi]
	cmp al, ','
	je overdue_book_done
	mov [edi], al
	inc esi
	inc edi
	jmp overdue_extract_book
overdue_book_done:
	mov byte ptr [edi], 0
	inc esi
    
	; Field 3: ISBN
	mov edi, OFFSET OVERDUE_ISBN_BUF
overdue_extract_isbn:
	mov al, [esi]
	cmp al, ','
	je overdue_isbn_done
	mov [edi], al
	inc esi
	inc edi
	jmp overdue_extract_isbn
overdue_isbn_done:
	mov byte ptr [edi], 0
	inc esi
    
	; Field 4: Issue date
	mov edi, OFFSET OVERDUE_ISSUE_DATE_BUF
overdue_extract_issue:
	mov al, [esi]
	cmp al, ','
	je overdue_issue_done
	mov [edi], al
	inc esi
	inc edi
	jmp overdue_extract_issue
overdue_issue_done:
	mov byte ptr [edi], 0
    
	; Display overdue book details
	INVOKE MSG_DISPLAY, ADDR USERNAME_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_USERNAME_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES

	INVOKE MSG_DISPLAY, ADDR NAME_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_BOOKNAME_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES

	INVOKE MSG_DISPLAY, ADDR ISBN_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_ISBN_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES

	INVOKE MSG_DISPLAY, ADDR ISSUE_DATE_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_ISSUE_DATE_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES

	INVOKE MSG_DISPLAY, ADDR RETURN_DATE_LABEL
	INVOKE MSG_DISPLAY, ADDR PARSED_RETURN_DATE_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES

	INVOKE MSG_DISPLAY, ADDR OVERDUE_SEPARATOR

	; Increment overdue count
	inc DWORD PTR [OVERDUE_COUNT]

overdue_pop_and_advance:
	pop edi
	pop ecx

	add ebx, ecx
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Dh
	jne overdue_skip_lf
	inc ebx
overdue_skip_lf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Ah
	jne overdue_next_line
	inc ebx
overdue_next_line:
	jmp overdue_loop
	
overdue_check_count:
	; Check if any overdue books found
	mov eax, DWORD PTR [OVERDUE_COUNT]
	cmp eax, 0
	jne overdue_done

overdue_no_books:
	INVOKE MSG_DISPLAY, ADDR NO_OVERDUE_MSG

overdue_no_books_cleanup:

overdue_done:
	; Ensure stack is balanced before returning
	pop edx
	pop ecx
	pop ebx
	pop eax
	JMP SHOW_FULL_MENU
CALCULATE_FINES_FUNC:
	; Ask user to enter ISBN
	INVOKE MSG_DISPLAY, ADDR ISBN_PROMPT
	mov edx, OFFSET ISBN_SEARCH_BUF
	mov ecx, 20
	CALL READSTRING
	
	; Display fines header
	INVOKE MSG_DISPLAY, ADDR FINES_HEADER
	INVOKE MSG_DISPLAY, ADDR FINE_RATE_MSG
	
	; Get current date
	push eax
	push ebx
	push ecx
	push edx
	
	sub esp, 16
	mov esi, esp
	INVOKE GetLocalTime, esi
	
	; Extract day, month, year
	movzx eax, WORD PTR [esi+2]  ; wMonth
	movzx ebx, WORD PTR [esi+6]  ; wDay
	movzx ecx, WORD PTR [esi]    ; wYear
	add esp, 16
	
	; Store current date values for comparison
	; Convert to comparable format: YYYYMMDD
	push eax  ; save month
	mov eax, ecx  ; year
	mov edx, 10000
	mul edx
	mov ecx, eax  ; ecx = year * 10000
	pop eax       ; restore month
	push ebx      ; save day
	mov edx, 100
	mul edx
	add ecx, eax  ; ecx += month * 100
	pop eax       ; get day
	add ecx, eax  ; ecx += day
	; Now ecx contains current date as YYYYMMDD
	push ecx      ; save current date
	
	; Store individual date components for day calculation
	sub esp, 16
	mov esi, esp
	INVOKE GetLocalTime, esi
	movzx eax, WORD PTR [esi+2]  ; wMonth
	movzx ebx, WORD PTR [esi+6]  ; wDay
	movzx ecx, WORD PTR [esi]    ; wYear
	add esp, 16
	
	push ecx  ; current year
	push eax  ; current month
	push ebx  ; current day
	
	; Read ISSUED_BOOKS.txt
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je fines_no_books_early
	
	mov filehandle, eax
	INVOKE ReadFile, filehandle, ADDR buffer_mem, BUFFER_SIZE, ADDR bytesRead, 0
	INVOKE CloseHandle, filehandle
	
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je fines_no_books_early
	
	; Null-terminate buffer
	mov edi, OFFSET buffer_mem
	mov ecx, DWORD PTR bytesRead
	mov byte ptr [edi + ecx], 0
	
	xor ebx, ebx  ; offset in buffer
	xor esi, esi  ; total fine amount
	
fines_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge fines_check_total
	
	lea edi, [OFFSET buffer_mem + ebx]
	
	; Find line length
	xor ecx, ecx
fines_find_eol:
	mov al, [edi + ecx]
	cmp al, 0
	je fines_process_line
	cmp al, 0Dh
	je fines_process_line
	inc ecx
	jmp fines_find_eol
	
fines_process_line:
	cmp ecx, 0
	je fines_advance
	
	push ecx
	push edi
	
	; Parse line: username,bookname,ISBN,issuedate,returndate
	; First check if ISBN matches the searched ISBN
	mov esi, edi
	xor edx, edx  ; comma counter
	
fines_skip_to_isbn:
	mov al, [esi]
	cmp al, 0
	je fines_line_done
	cmp al, 0Dh
	je fines_line_done
	cmp al, ','
	jne fines_skip_isbn_char
	inc edx
	cmp edx, 2
	je fines_found_isbn_field
fines_skip_isbn_char:
	inc esi
	jmp fines_skip_to_isbn
	
fines_found_isbn_field:
	; Skip comma
	inc esi
	
	; Compare ISBN with search buffer
	push edi
	mov edi, OFFSET ISBN_SEARCH_BUF
fines_compare_isbn:
	mov al, [esi]
	mov bl, [edi]
	cmp bl, 0
	je fines_check_isbn_end
	cmp al, bl
	jne fines_isbn_no_match
	inc esi
	inc edi
	jmp fines_compare_isbn
	
fines_check_isbn_end:
	mov al, [esi]
	cmp al, ','
	je fines_isbn_match
	
fines_isbn_no_match:
	pop edi
	jmp fines_line_done
	
fines_isbn_match:
	pop edi
	
	; Now extract return date (5th field)
	mov esi, edi
	xor edx, edx  ; comma counter
	
fines_skip_to_return_date:
	mov al, [esi]
	cmp al, 0
	je fines_line_done
	cmp al, 0Dh
	je fines_line_done
	cmp al, ','
	jne fines_skip_char
	inc edx
	cmp edx, 4
	je fines_found_return_date
fines_skip_char:
	inc esi
	jmp fines_skip_to_return_date
	
fines_found_return_date:
	; Skip comma
	inc esi
	
	; Copy return date to PARSED_RETURN_DATE_BUF
	push edi
	mov edi, OFFSET PARSED_RETURN_DATE_BUF
fines_copy_date:
	mov al, [esi]
	cmp al, 0
	je fines_date_copied
	cmp al, 0Dh
	je fines_date_copied
	cmp al, 0Ah
	je fines_date_copied
	mov [edi], al
	inc esi
	inc edi
	jmp fines_copy_date
	
fines_date_copied:
	mov byte ptr [edi], 0
	pop edi
	
	; Parse return date DD/MM/YYYY and convert to YYYYMMDD
	push edi
	mov esi, OFFSET PARSED_RETURN_DATE_BUF
	
	; Extract day
	movzx eax, byte ptr [esi]
	sub al, '0'
	mov bl, 10
	mul bl
	movzx edx, byte ptr [esi+1]
	sub dl, '0'
	add al, dl
	movzx eax, al
	push eax  ; save return day
	
	; Extract month
	movzx eax, byte ptr [esi+3]
	sub al, '0'
	mov bl, 10
	mul bl
	movzx edx, byte ptr [esi+4]
	sub dl, '0'
	add al, dl
	movzx eax, al
	push eax  ; save return month
	
	; Extract year
	movzx eax, byte ptr [esi+6]
	sub al, '0'
	mov dx, 1000
	mul dx
	movzx ecx, ax
	
	movzx eax, byte ptr [esi+7]
	sub al, '0'
	mov dx, 100
	mul dx
	add ecx, eax
	
	movzx eax, byte ptr [esi+8]
	sub al, '0'
	mov dx, 10
	mul dx
	add ecx, eax
	
	movzx eax, byte ptr [esi+9]
	sub al, '0'
	add ecx, eax
	
	; Now ecx = year, calculate YYYYMMDD
	mov eax, ecx
	mov edx, 10000
	mul edx
	mov ecx, eax  ; ecx = year * 10000
	
	pop eax  ; get return month
	mov edx, 100
	mul edx
	add ecx, eax  ; ecx += month * 100
	
	pop eax  ; get return day
	add ecx, eax  ; ecx += day
	
	pop edi
	
	; Compare with current date
	mov eax, [esp+8+12]  ; get current date from stack (accounting for 3 date component pushes)
	cmp ecx, eax
	jge fines_line_done  ; return date >= current date, not overdue
	
	; Book is overdue! Calculate days overdue and fine
	; Simple calculation: currentDate - returnDate (approximation)
	mov eax, [esp+8+12]  ; current date YYYYMMDD
	sub eax, ecx         ; subtract return date
	; Approximate days (this is simplified - actual would need proper date arithmetic)
	; For simplicity: assume difference in dates gives rough day count
	; Better approach: use individual components
	
	; Get return date components back from string
	mov esi, OFFSET PARSED_RETURN_DATE_BUF
	movzx ebx, byte ptr [esi]
	sub bl, '0'
	mov al, 10
	mul bl
	movzx edx, byte ptr [esi+1]
	sub dl, '0'
	add al, dl
	movzx ebx, al  ; ebx = return day
	
	movzx eax, byte ptr [esi+3]
	sub al, '0'
	mov dl, 10
	mul dl
	movzx ecx, byte ptr [esi+4]
	sub cl, '0'
	add al, cl
	movzx ecx, al  ; ecx = return month
	
	; Get current date components from stack
	mov eax, [esp+8]    ; current day
	mov edx, [esp+8+4]  ; current month
	
	; Simple day calculation (assuming same month for simplicity)
	; In reality, need complex date arithmetic
	; For demo: if same month, days = current_day - return_day
	cmp edx, ecx
	jne fines_diff_month
	
	sub eax, ebx  ; days overdue = current_day - return_day
	jmp fines_calc_fine
	
fines_diff_month:
	; Simplified: add 30 days for month difference
	mov eax, 30
	sub eax, ebx  ; days left in return month
	add eax, [esp+8]  ; add days in current month
	
fines_calc_fine:
	; eax now has days overdue
	cmp eax, 0
	jle fines_line_done  ; skip if not actually overdue
	
	; Calculate fine: days * rate
	mov edx, FINE_RATE
	mul edx  ; eax = days * rate
	
	; Save fine for this book
	push eax  ; save fine amount
	
	; Extract book details
	pop edx  ; get fine back
	pop edi
	pop ecx
	push ecx
	push edi
	push edx  ; save fine again
	
	mov esi, edi
	
	; Field 1: Username
	mov edi, OFFSET OVERDUE_USERNAME_BUF
fines_extract_user:
	mov al, [esi]
	cmp al, ','
	je fines_user_done
	mov [edi], al
	inc esi
	inc edi
	jmp fines_extract_user
fines_user_done:
	mov byte ptr [edi], 0
	inc esi
	
	; Field 2: Book name
	mov edi, OFFSET OVERDUE_BOOKNAME_BUF
fines_extract_book:
	mov al, [esi]
	cmp al, ','
	je fines_book_done
	mov [edi], al
	inc esi
	inc edi
	jmp fines_extract_book
fines_book_done:
	mov byte ptr [edi], 0
	
	; Display details with fine
	INVOKE MSG_DISPLAY, ADDR USERNAME_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_USERNAME_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR NAME_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_BOOKNAME_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR RETURN_DATE_LABEL
	INVOKE MSG_DISPLAY, ADDR PARSED_RETURN_DATE_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR FINE_AMOUNT_LABEL
	pop eax  ; get fine amount
	call WriteDec
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR OVERDUE_SEPARATOR
	
	; Book found and fine calculated, exit
	pop edi
	pop ecx
	
	; Clean up stack (current day, month, year, current date)
	pop ebx  ; day
	pop ecx  ; month
	pop edx  ; year
	pop eax  ; current date
	
	jmp fines_done
	
fines_line_done:
	pop edi
	pop ecx
	
fines_advance:
	add ebx, ecx
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Dh
	jne fines_skip_lf
	inc ebx
fines_skip_lf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Ah
	jne fines_next_line
	inc ebx
fines_next_line:
	jmp fines_loop
	
fines_check_total:
	; Clean up stack (current day, month, year, current date)
	pop ebx  ; day
	pop ecx  ; month
	pop edx  ; year
	pop eax  ; current date
	
	; Check if any fines calculated
	cmp esi, 0
	je fines_no_books
	
	; No total display needed
	jmp fines_done
	
fines_no_books_early:
	; Clean up stack if we jumped here before popping date values
	add esp, 16  ; clean up date components and current date
	jmp fines_no_books
	
fines_no_books:
	INVOKE MSG_DISPLAY, ADDR NO_FINES_MSG
	
fines_done:
	pop edx
	pop ecx
	pop ebx
	pop eax
	JMP SHOW_FULL_MENU
IntToStr PROC
    push ebx
    push ecx
    push edx
    mov ebx, 10
    mov ecx, 0
    cmp eax, 0
    jne its_convert
    mov byte ptr [edx], '0'
    inc edx
    mov byte ptr [edx], 0
    pop edx
    pop ecx
    pop ebx
    ret
its_convert:
    ; store digits in reverse order
    mov esi, edx
its_loop:
    xor edx, edx
    div ebx
    add edx, '0'
    push edx
    inc ecx
    test eax, eax
    jnz its_loop
    ; pop digits in correct order
its_pop:
    pop eax
    mov [esi], al
    inc esi
    loop its_pop
    mov byte ptr [esi], 0
    pop edx
    pop ecx
    pop ebx
    ret
IntToStr ENDP
MSG_DISPLAY PROC USES EDX, VAR: ptr dword
    MOV EDX, VAR
    CALL WRITESTRING
    RET
    MSG_DISPLAY ENDP

STRING_INPUT PROC USES EDX ECX, var: ptr dword
        
    MOV EDX, VAR
    MOV ECX, 5000
    CALL READSTRING
    RET
    STRING_INPUT ENDP

; ReadAllBooks - helper to read entire BOOKS.txt into BUFFER_BOOK
; Expects: filehandle contains an open handle to BOOKS.txt
; Returns: bytesRead (dword variable) updated; buffer null-terminated
ReadAllBooks PROC
    ; preserve registers
    pushad

    ; get file size (low dword)
    INVOKE SetFilePointer, filehandle, 0, 0, FILE_END
    mov esi, eax            ; esi = file size low

    ; move file pointer back to beginning
    INVOKE SetFilePointer, filehandle, 0, 0, FILE_BEGIN

    ; limit to BUFFER_SIZE-1 to leave space for terminating NUL
    mov eax, BUFFER_SIZE
    dec eax
    cmp esi, eax
    jle size_ok
    mov esi, eax
size_ok:

    ; Read file (esi bytes) into BUFFER_BOOK
    INVOKE ReadFile, filehandle, ADDR BUFFER_BOOK, esi, ADDR bytesRead, 0

    ; close handle
    invoke CloseHandle, filehandle

    ; null-terminate buffer at bytesRead
    mov eax, DWORD PTR bytesRead
    lea edi, [OFFSET BUFFER_BOOK]
    add edi, eax
    mov byte ptr [edi], 0

    popad
    ret
ReadAllBooks ENDP

; DisplayBookLine - helper to parse and display a CSV book line with labels
; Expects: EDX = pointer to null-terminated CSV line
; Modifies: book buffers and displays formatted output
DisplayBookLine PROC
    push eax
    push ebx
    push ecx
    push edx
    push esi
    push edi

    ; Clear all book buffers first
    mov edi, OFFSET BOOK_NAME_BUF
    mov ecx, BOOK_NAME_SIZE
    xor al, al
dbl_clear_name:
    mov [edi], al
    inc edi
    loop dbl_clear_name
    
    mov edi, OFFSET BOOK_AUTHOR_BUF
    mov ecx, BOOK_AUTHOR_SIZE
dbl_clear_author:
    mov [edi], al
    inc edi
    loop dbl_clear_author
    
    mov edi, OFFSET BOOK_PUBLISHER_BUF
    mov ecx, BOOK_PUBLISHER_SIZE
dbl_clear_pub:
    mov [edi], al
    inc edi
    loop dbl_clear_pub
    
    mov edi, OFFSET BOOK_GENRE_BUF
    mov ecx, BOOK_GENRE_SIZE
dbl_clear_genre:
    mov [edi], al
    inc edi
    loop dbl_clear_genre
    
    mov edi, OFFSET BOOK_YEAR_BUF
    mov ecx, 10
dbl_clear_year:
    mov [edi], al
    inc edi
    loop dbl_clear_year
    
    mov edi, OFFSET BOOK_ISBN_BUF
    mov ecx, 20
dbl_clear_isbn:
    mov [edi], al
    inc edi
    loop dbl_clear_isbn

    ; Parse CSV line (EDX points to line)
    mov esi, edx
    
    ; Field 1 -> BOOK_NAME_BUF
    mov edi, OFFSET BOOK_NAME_BUF
dbl_copy_name:
    mov al, [esi]
    cmp al, ','
    je dbl_name_done
    cmp al, 0
    je dbl_name_done
    mov [edi], al
    inc edi
    inc esi
    jmp dbl_copy_name
dbl_name_done:
    mov byte ptr [edi], 0
    cmp byte ptr [esi], ','
    jne dbl_after_name
    inc esi
dbl_after_name:

    ; Field 2 -> BOOK_AUTHOR_BUF
    mov edi, OFFSET BOOK_AUTHOR_BUF
dbl_copy_author:
    mov al, [esi]
    cmp al, ','
    je dbl_author_done
    cmp al, 0
    je dbl_author_done
    mov [edi], al
    inc edi
    inc esi
    jmp dbl_copy_author
dbl_author_done:
    mov byte ptr [edi], 0
    cmp byte ptr [esi], ','
    jne dbl_after_author
    inc esi
dbl_after_author:

    ; Field 3 -> BOOK_PUBLISHER_BUF
    mov edi, OFFSET BOOK_PUBLISHER_BUF
dbl_copy_publisher:
    mov al, [esi]
    cmp al, ','
    je dbl_publisher_done
    cmp al, 0
    je dbl_publisher_done
    mov [edi], al
    inc edi
    inc esi
    jmp dbl_copy_publisher
dbl_publisher_done:
    mov byte ptr [edi], 0
    cmp byte ptr [esi], ','
    jne dbl_after_publisher
    inc esi
dbl_after_publisher:

    ; Field 4 -> BOOK_GENRE_BUF
    mov edi, OFFSET BOOK_GENRE_BUF
dbl_copy_genre:
    mov al, [esi]
    cmp al, ','
    je dbl_genre_done
    cmp al, 0
    je dbl_genre_done
    mov [edi], al
    inc edi
    inc esi
    jmp dbl_copy_genre
dbl_genre_done:
    mov byte ptr [edi], 0
    cmp byte ptr [esi], ','
    jne dbl_after_genre
    inc esi
dbl_after_genre:

    ; Field 5 -> BOOK_YEAR_BUF
    mov edi, OFFSET BOOK_YEAR_BUF
dbl_copy_year:
    mov al, [esi]
    cmp al, ','
    je dbl_year_done
    cmp al, 0
    je dbl_year_done
    mov [edi], al
    inc edi
    inc esi
    jmp dbl_copy_year
dbl_year_done:
    mov byte ptr [edi], 0
    cmp byte ptr [esi], ','
    jne dbl_after_year
    inc esi
dbl_after_year:

    ; Field 6 -> BOOK_ISBN_BUF
    mov edi, OFFSET BOOK_ISBN_BUF
dbl_copy_isbn:
    mov al, [esi]
    cmp al, 0
    je dbl_isbn_done
    mov [edi], al
    inc edi
    inc esi
    jmp dbl_copy_isbn
dbl_isbn_done:
    mov byte ptr [edi], 0

    ; Display with labels
    INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
    
    INVOKE MSG_DISPLAY, ADDR NAME_LABEL
    mov edx, OFFSET BOOK_NAME_BUF
    call WriteString
    call CRLF

    INVOKE MSG_DISPLAY, ADDR AUTHOR_LABEL
    mov edx, OFFSET BOOK_AUTHOR_BUF
    call WriteString
    call CRLF

    INVOKE MSG_DISPLAY, ADDR PUBLISHER_LABEL
    mov edx, OFFSET BOOK_PUBLISHER_BUF
    call WriteString
    call CRLF

    INVOKE MSG_DISPLAY, ADDR GENRE_LABEL
    mov edx, OFFSET BOOK_GENRE_BUF
    call WriteString
    call CRLF

    INVOKE MSG_DISPLAY, ADDR YEAR_LABEL
    mov edx, OFFSET BOOK_YEAR_BUF
    call WriteString
    call CRLF

    INVOKE MSG_DISPLAY, ADDR ISBN_LABEL
    mov edx, OFFSET BOOK_ISBN_BUF
    call WriteString
    call CRLF

    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
DisplayBookLine ENDP

VIEW_ISSUED_BOOKS_FUNC:
	; Display issued books header
	INVOKE MSG_DISPLAY, ADDR ISSUED_BOOKS_HEADER
	
	; Read ISSUED_BOOKS.txt
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je view_issued_no_books
	
	mov filehandle, eax
	INVOKE ReadFile, filehandle, ADDR buffer_mem, BUFFER_SIZE, ADDR bytesRead, 0
	INVOKE CloseHandle, filehandle
	
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je view_issued_no_books
	
	; Null-terminate buffer
	mov edi, OFFSET buffer_mem
	mov ecx, DWORD PTR bytesRead
	mov byte ptr [edi + ecx], 0
	
	xor ebx, ebx  ; offset in buffer
	xor esi, esi  ; counter for issued books
	
view_issued_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge view_issued_check_count
	
	lea edi, [OFFSET buffer_mem + ebx]
	
	; Find line length
	xor ecx, ecx
view_issued_find_eol:
	mov al, [edi + ecx]
	cmp al, 0
	je view_issued_process_line
	cmp al, 0Dh
	je view_issued_process_line
	inc ecx
	jmp view_issued_find_eol
	
view_issued_process_line:
	cmp ecx, 0
	je view_issued_advance
	
	push ecx
	push edi
	
	; Parse line: username,bookname,ISBN,issuedate,returndate
	mov esi, edi
	
	; Field 1: Username
	mov edi, OFFSET OVERDUE_USERNAME_BUF
view_issued_extract_user:
	mov al, [esi]
	cmp al, ','
	je view_issued_user_done
	mov [edi], al
	inc esi
	inc edi
	jmp view_issued_extract_user
view_issued_user_done:
	mov byte ptr [edi], 0
	inc esi
	
	; Field 2: Book name
	mov edi, OFFSET OVERDUE_BOOKNAME_BUF
view_issued_extract_book:
	mov al, [esi]
	cmp al, ','
	je view_issued_book_done
	mov [edi], al
	inc esi
	inc edi
	jmp view_issued_extract_book
view_issued_book_done:
	mov byte ptr [edi], 0
	inc esi
	
	; Field 3: ISBN
	mov edi, OFFSET OVERDUE_ISBN_BUF
view_issued_extract_isbn:
	mov al, [esi]
	cmp al, ','
	je view_issued_isbn_done
	mov [edi], al
	inc esi
	inc edi
	jmp view_issued_extract_isbn
view_issued_isbn_done:
	mov byte ptr [edi], 0
	inc esi
	
	; Field 4: Issue date
	mov edi, OFFSET OVERDUE_ISSUE_DATE_BUF
view_issued_extract_issue:
	mov al, [esi]
	cmp al, ','
	je view_issued_issue_done
	mov [edi], al
	inc esi
	inc edi
	jmp view_issued_extract_issue
view_issued_issue_done:
	mov byte ptr [edi], 0
	inc esi
	
	; Field 5: Return date
	mov edi, OFFSET PARSED_RETURN_DATE_BUF
view_issued_extract_return:
	mov al, [esi]
	cmp al, 0
	je view_issued_return_done
	cmp al, 0Dh
	je view_issued_return_done
	cmp al, 0Ah
	je view_issued_return_done
	mov [edi], al
	inc esi
	inc edi
	jmp view_issued_extract_return
view_issued_return_done:
	mov byte ptr [edi], 0
	
	; Display issued book details
	INVOKE MSG_DISPLAY, ADDR USERNAME_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_USERNAME_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR NAME_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_BOOKNAME_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR ISBN_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_ISBN_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR ISSUE_DATE_LABEL
	INVOKE MSG_DISPLAY, ADDR OVERDUE_ISSUE_DATE_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR RETURN_DATE_LABEL
	INVOKE MSG_DISPLAY, ADDR PARSED_RETURN_DATE_BUF
	INVOKE MSG_DISPLAY, ADDR CRLF_BYTES
	
	INVOKE MSG_DISPLAY, ADDR OVERDUE_SEPARATOR
	
	inc esi  ; increment issued books counter
	
	pop edi
	pop ecx
	
view_issued_advance:
	add ebx, ecx
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Dh
	jne view_issued_skip_lf
	inc ebx
view_issued_skip_lf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Ah
	jne view_issued_next_line
	inc ebx
view_issued_next_line:
	jmp view_issued_loop
	
view_issued_check_count:
	; Check if any issued books found
	cmp esi, 0
	jne view_issued_done
	
view_issued_no_books:
	INVOKE MSG_DISPLAY, ADDR NO_ISSUED_MSG
	
view_issued_done:
	JMP SHOW_FULL_MENU

issue_book_found:
	pop edi
	pop ecx

	; First, extract book name from the matched line (edi points to start of line)
	; Save edi (line start) for later use
	push edi

	; Copy book name (first field) to ISSUED_BOOK_NAME_BUF
	mov esi, edi
	mov edi, OFFSET ISSUED_BOOK_NAME_BUF
issue_extract_name:
	mov al, [esi]
	cmp al, ','
	je issue_name_done
	cmp al, 0
	je issue_name_done
	cmp al, 0Dh
	je issue_name_done
	mov [edi], al
	inc esi
	inc edi
	jmp issue_extract_name
issue_name_done:
	mov byte ptr [edi], 0

	; Restore edi
	pop edi

	; Check if already issued by reading ISSUED_BOOKS.txt
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je issue_not_yet_issued ; File doesn't exist, so no books issued yet

	mov filehandle, eax

	; Read issued books into buffer_mem
	INVOKE ReadFile, filehandle, ADDR buffer_mem, BUFFER_SIZE, ADDR bytesRead, 0
	INVOKE CloseHandle, filehandle

	; Search for ISBN in issued books
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je issue_not_yet_issued

	; Null-terminate buffer
	mov edi, OFFSET buffer_mem
	mov ecx, DWORD PTR bytesRead
	mov byte ptr [edi + ecx], 0

	xor ebx, ebx
issue_check_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge issue_not_yet_issued

	lea esi, [OFFSET buffer_mem + ebx]

	; Find line length
	xor ecx, ecx
issue_check_eol:
	mov al, [esi + ecx]
	cmp al, 0
	je issue_check_isbn
	cmp al, 0Dh
	je issue_check_isbn
	inc ecx
	jmp issue_check_eol

issue_check_isbn:
	cmp ecx, 0
	je issue_check_advance

	; Extract ISBN (3rd field) from issued books line: username,bookname,ISBN,issuedate,returndate
	push ecx
	push esi

	; Skip first two fields (username, bookname)
	xor edx, edx ; comma counter
issue_skip_to_isbn:
	mov al, [esi]
	cmp al, 0
	je issue_check_no_match
	cmp al, 0Dh
	je issue_check_no_match
	cmp al, ','
	jne issue_skip_next_char
	inc edx
	cmp edx, 2
	je issue_found_isbn_field
issue_skip_next_char:
	inc esi
	jmp issue_skip_to_isbn

issue_found_isbn_field:
	; Skip the comma
	inc esi

	; Copy ISBN to TEMP_FIELD
	mov edi, OFFSET TEMP_FIELD
issue_copy_issued_isbn:
	mov al, [esi]
	cmp al, 0
	je issue_check_compare
	cmp al, 0Dh
	je issue_check_compare
	cmp al, ','
	je issue_check_compare
	mov [edi], al
	inc esi
	inc edi
	jmp issue_copy_issued_isbn

issue_check_compare:
	mov byte ptr [edi], 0

	; Check if ISBN matches
	INVOKE Str_compare, ADDR ISBN_SEARCH_BUF, ADDR TEMP_FIELD
	je issue_already_issued_pop

issue_check_no_match:
	pop esi
	pop ecx

issue_check_advance:
	add ebx, ecx
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Dh
	jne issue_check_lf
	inc ebx
issue_check_lf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Ah
	jne issue_check_next
	inc ebx
issue_check_next:
	jmp issue_check_loop

issue_already_issued_pop:
	pop esi
	pop ecx
	INVOKE MSG_DISPLAY, ADDR BOOK_ALREADY_ISSUED_MSG
	JMP SHOW_MEMBER_MENU

issue_not_yet_issued:
	; Book exists and not issued - add to ISSUED_BOOKS.txt
	; Format: username,bookname,ISBN,date

	; Get current date using GetLocalTime
	push eax
	push ebx
	push ecx
	push edx

	; Allocate SYSTEMTIME structure on stack (16 bytes)
	sub esp, 16
	mov esi, esp

	INVOKE GetLocalTime, esi

	; Extract day, month, year from SYSTEMTIME structure
	; SYSTEMTIME: wYear(2), wMonth(2), wDayOfWeek(2), wDay(2), wHour(2), wMinute(2), wSecond(2), wMilliseconds(2)
	movzx eax, WORD PTR [esi+2]  ; wMonth (offset 2)
	movzx ebx, WORD PTR [esi+6]  ; wDay (offset 6)
	movzx ecx, WORD PTR [esi]    ; wYear (offset 0)

	; Clean up stack
	add esp, 16

	; Save the values we need
	push ecx  ; save year
	push eax  ; save month
	push ebx  ; save day

	; Format date as "DD/MM/YYYY" in DATE_BUF
	mov edi, OFFSET DATE_BUF

	; Day (2 digits)
	pop eax   ; get day
	push eax  ; save it again
	xor edx, edx
	push ecx  ; save ecx
	mov ecx, 10
	div ecx
	add al, '0'
	mov [edi], al
	inc edi
	mov al, dl
	add al, '0'
	mov [edi], al
	inc edi
	pop ecx   ; restore ecx

	; Separator
	mov byte ptr [edi], '/'
	inc edi

	; Month (2 digits)
	mov eax, [esp+4]  ; get month (skip day on stack)
	xor edx, edx
	push ecx  ; save ecx
	mov ecx, 10
	div ecx
	add al, '0'
	mov [edi], al
	inc edi
	mov al, dl
	add al, '0'
	mov [edi], al
	inc edi
	pop ecx   ; restore ecx

	; Separator
	mov byte ptr [edi], '/'
	inc edi

	; Year (4 digits)
	mov eax, [esp+8]  ; get year from stack
	push ebx
	mov ebx, 1000
	xor edx, edx
	div ebx
	add al, '0'
	mov [edi], al
	inc edi

	mov eax, edx
	mov ebx, 100
	xor edx, edx
	div ebx
	add al, '0'
	mov [edi], al
	inc edi

	mov eax, edx
	mov ebx, 10
	xor edx, edx
	div ebx
	add al, '0'
	mov [edi], al
	inc edi

	mov al, dl
	add al, '0'
	mov [edi], al
	inc edi

	mov byte ptr [edi], 0
	pop ebx

	; Clean up stack but save day, month, year for return date calculation
	; Stack has: day, month, year
	pop eax  ; day
	pop ebx  ; month
	pop ecx  ; year

	; Calculate return date (10 days later)
	; Add 10 to the day
	add eax, 10

	; Save registers
	push edx

	; Check if day exceeds month's max days
	; Simple logic: assume 30 days per month for simplicity
	cmp eax, 30
	jle return_date_ok

	; Day exceeds 30, move to next month
	sub eax, 30
	inc ebx

	; Check if month exceeds 12
	cmp ebx, 12
	jle return_date_ok

	; Month exceeds 12, move to next year
	sub ebx, 12
	inc ecx

return_date_ok:
	; Now eax=day, ebx=month, ecx=year for return date
	; Format return date as "DD/MM/YYYY" in RETURN_DATE_BUF
	
	mov edi, OFFSET RETURN_DATE_BUF

	; Day (2 digits) - eax has day
	push eax
	push ebx
	push ecx
	xor edx, edx
	mov ecx, 10
	div ecx
	add al, '0'
	mov [edi], al
	inc edi
	mov al, dl
	add al, '0'
	mov [edi], al
	inc edi
	pop ecx
	pop ebx
	pop eax

	; Separator
	mov byte ptr [edi], '/'
	inc edi

	; Month (2 digits) - ebx has month
	push eax
	push ebx
	push ecx
	mov eax, ebx
	xor edx, edx
	mov ecx, 10
	div ecx
	add al, '0'
	mov [edi], al
	inc edi
	mov al, dl
	add al, '0'
	mov [edi], al
	inc edi
	pop ecx
	pop ebx
	pop eax

	; Separator
	mov byte ptr [edi], '/'
	inc edi

	; Year (4 digits) - ecx has year
	push eax
	push ebx
	mov eax, ecx
	push ebx
	mov ebx, 1000
	xor edx, edx
	div ebx
	add al, '0'
	mov [edi], al
	inc edi

	mov eax, edx
	mov ebx, 100
	xor edx, edx
	div ebx
	add al, '0'
	mov [edi], al
	inc edi

	mov eax, edx
	mov ebx, 10
	xor edx, edx
	div ebx
	add al, '0'
	mov [edi], al
	inc edi

	mov al, dl
	add al, '0'
	mov [edi], al
	inc edi

	mov byte ptr [edi], 0
	pop ebx
	pop ebx
	pop eax

	pop edx

	pop edx
	pop ecx
	pop ebx
	pop eax

	; Now write to file: username,bookname,ISBN,issuedate,returndate
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_WRITE, DO_NOT_SHARE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
	mov filehandle, eax
	
	; Move to end of file
	INVOKE SetFilePointer, filehandle, 0, 0, FILE_END
	
	; Write username
	mov edx, OFFSET USERNAME_BUF
	INVOKE Str_length, edx
	mov ecx, eax
	mov eax, filehandle
	call WriteToFile
	
	; Write comma
	mov eax, filehandle
	mov edx, OFFSET COMMA_BYTE
	mov ecx, 1
	call WriteToFile
	
	; Write book name
	mov edx, OFFSET ISSUED_BOOK_NAME_BUF
	INVOKE Str_length, edx
	mov ecx, eax
	mov eax, filehandle
	call WriteToFile
	
	; Write comma
	mov eax, filehandle
	mov edx, OFFSET COMMA_BYTE
	mov ecx, 1
	call WriteToFile
	
	; Write ISBN
	mov edx, OFFSET ISBN_SEARCH_BUF
	INVOKE Str_length, edx
	mov ecx, eax
	mov eax, filehandle
	call WriteToFile
	
	; Write comma
	mov eax, filehandle
	mov edx, OFFSET COMMA_BYTE
	mov ecx, 1
	call WriteToFile
	
	; Write issue date
	mov edx, OFFSET DATE_BUF
	INVOKE Str_length, edx
	mov ecx, eax
	mov eax, filehandle
	call WriteToFile
	
	; Write comma
	mov eax, filehandle
	mov edx, OFFSET COMMA_BYTE
	mov ecx, 1
	call WriteToFile
	
	; Write return date
	mov edx, OFFSET RETURN_DATE_BUF
	INVOKE Str_length, edx
	mov ecx, eax
	mov eax, filehandle
	call WriteToFile
	
	; Write newline
	mov eax, filehandle
	mov edx, OFFSET CRLF_BYTES
	mov ecx, 2
	call WriteToFile
	
	INVOKE CloseHandle, filehandle
	
	INVOKE MSG_DISPLAY, ADDR BOOK_ISSUED_SUCCESS_MSG
	JMP SHOW_MEMBER_MENU
	
issue_limit_reached:
	INVOKE MSG_DISPLAY, ADDR BOOK_LIMIT_REACHED_MSG
	JMP SHOW_MEMBER_MENU

issue_book_not_found:
	INVOKE MSG_DISPLAY, ADDR BOOK_NOT_FOUND_MSG
	JMP SHOW_MEMBER_MENU

RETURN_BOOK_FUNC:
	; Prompt for ISBN
	INVOKE MSG_DISPLAY, ADDR RETURN_BOOK_MSG
	mov edx, OFFSET ISBN_SEARCH_BUF
	mov ecx, 20
	CALL READSTRING
	
	; Open ISSUED_BOOKS.txt for reading
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je return_book_not_issued           ; File doesn't exist or can't be opened
	
	mov filehandle, eax
	
	; Read all issued books
	INVOKE ReadFile, filehandle, ADDR buffer_mem, BUFFER_SIZE, ADDR bytesRead, 0
	INVOKE CloseHandle, filehandle
	
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je return_book_not_issued           ; Empty file -> nothing issued
	
	; Null-terminate buffer
	mov edi, OFFSET buffer_mem
	mov ecx, DWORD PTR bytesRead
	mov byte ptr [edi + ecx], 0
	
	; Reopen ISSUED_BOOKS.txt for rewrite (truncate)
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_WRITE, DO_NOT_SHARE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je return_book_not_issued
	mov filehandle, eax
	
	; Initialize scan state
	xor ebx, ebx                        ; EBX = offset into buffer_mem
	mov byte ptr [TEMP_LINE], 0        ; use TEMP_LINE[0] as "found" flag

return_search_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge return_check_found              ; reached end of buffer
	
	; ESI = start of current line
	lea esi, [OFFSET buffer_mem + ebx]
	
	; Find line length into ECX (stop at 0 or CR)
	xor ecx, ecx
return_find_eol:
	mov al, [esi + ecx]
	cmp al, 0
	je return_process_line
	cmp al, 0Dh
	je return_process_line
	inc ecx
	jmp return_find_eol

return_process_line:
	cmp ecx, 0
	je return_advance_only              ; empty line
	
	; Extract ISBN (3rd field) from line: username,bookname,ISBN,issuedate,returndate
	; Use EDI as scanning pointer within the line
	mov edi, esi                        ; EDI = current position in line
	xor edx, edx                        ; EDX = comma counter

return_skip_to_isbn:
	mov al, [edi]
	cmp al, 0
	je return_write_line                ; malformed line, keep as-is
	cmp al, 0Dh
	je return_write_line                ; end-of-line without 3 fields
	cmp al, ','
	jne return_skip_next
	inc edx
	cmp edx, 2                          ; after 2 commas we are at ISBN field
	je return_isbn_field_found
return_skip_next:
	inc edi
	jmp return_skip_to_isbn

return_isbn_field_found:
	; Skip the comma to reach start of ISBN text
	inc edi
	
	; Copy ISBN characters into TEMP_FIELD
	mov esi, OFFSET TEMP_FIELD          ; ESI now used as destination buffer
return_copy_isbn_field:
	mov al, [edi]
	cmp al, 0
	je return_compare_isbn
	cmp al, 0Dh
	je return_compare_isbn
	cmp al, ','
	je return_compare_isbn
	mov [esi], al
	inc edi
	inc esi
	jmp return_copy_isbn_field

return_compare_isbn:
	mov byte ptr [esi], 0               ; null-terminate TEMP_FIELD
	INVOKE Str_compare, ADDR ISBN_SEARCH_BUF, ADDR TEMP_FIELD
	je return_mark_found_and_skip       ; matched -> skip writing this line

	; No match -> fall through and write line back

return_write_line:
	; Write the original line back to ISSUED_BOOKS.txt
	; ECX currently holds the line length. WriteToFile may destroy ECX,
	; so save it across both write calls.
	push ecx                      ; save line length
	mov eax, filehandle
	lea edx, [OFFSET buffer_mem + ebx]  ; line start pointer
	call WriteToFile                    ; may clobber ECX
	
	; Write CRLF
	mov eax, filehandle
	mov edx, OFFSET CRLF_BYTES
	mov ecx, 2
	call WriteToFile
	
	pop ecx                       ; restore original line length

return_advance_only:
	; Advance EBX by line length and skip CR/LF if present
	cmp ecx, 0
	jne return_advance_by_ecx
	; If ecx is 0 (empty line), advance by 1 to avoid infinite loop
	inc ebx
	jmp return_check_crlf
return_advance_by_ecx:
	add ebx, ecx
return_check_crlf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Dh
	jne return_skip_lf
	inc ebx
return_skip_lf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Ah
	jne return_next_line
	inc ebx
return_next_line:
	; Safety: if ebx did not advance, break to avoid infinite loop
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge return_check_found
	jmp return_search_loop

return_mark_found_and_skip:
	; Mark that we found and removed the ISBN line, but do not write it back
	mov byte ptr [TEMP_LINE], 1
	jmp return_advance_only

return_check_found:
	INVOKE CloseHandle, filehandle
	
	; Check if we found and removed the ISBN entry
	cmp byte ptr [TEMP_LINE], 1
	jne return_book_not_issued
	
	INVOKE MSG_DISPLAY, ADDR BOOK_RETURNED_SUCCESS_MSG
	JMP SHOW_MEMBER_MENU
	
return_book_not_issued:
	INVOKE MSG_DISPLAY, ADDR BOOK_NOT_ISSUED_MSG
	JMP SHOW_MEMBER_MENU

ISSUE_BOOK_FUNC:
	; First, check if user has already issued 5 books
	; Read ISSUED_BOOKS.txt and count books issued by current user
	INVOKE CreateFile, ADDR ISSUED_BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je issue_check_done ; File doesn't exist, no books issued yet
	
	mov filehandle, eax
	
	; Read all issued books into buffer_mem
	INVOKE ReadFile, filehandle, ADDR buffer_mem, BUFFER_SIZE, ADDR bytesRead, 0
	INVOKE CloseHandle, filehandle
	
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je issue_check_done ; No books issued yet
	
	; Null-terminate buffer
	mov edi, OFFSET buffer_mem
	mov ecx, DWORD PTR bytesRead
	mov byte ptr [edi + ecx], 0
	
	; Count books issued by current user
	xor ebx, ebx ; offset in buffer
	xor esi, esi ; counter for user's books
	
issue_count_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge issue_check_limit
	
	lea edi, [OFFSET buffer_mem + ebx]
	
push esi            ; line start pointer
	xor ecx, ecx
issue_count_eol:
	mov al, [edi + ecx]
	cmp al, 0
	je issue_count_process
	cmp al, 0Dh
	je issue_count_process
	inc ecx
	jmp issue_count_eol
	
issue_count_process:
	cmp ecx, 0
	je issue_count_advance
	
	; Extract username (first field) and compare with USERNAME_BUF
	push ecx
	push edi
	push esi
	
	; Copy username from line to TEMP_FIELD
	mov esi, edi
	mov edi, OFFSET TEMP_FIELD
issue_count_copy_user:
	mov al, [esi]
	cmp al, ','
	je issue_count_compare_user
	cmp al, 0
	je issue_count_compare_user
	cmp al, 0Dh
	je issue_count_compare_user
	mov [edi], al
	inc esi
	inc edi
	jmp issue_count_copy_user
	
issue_count_compare_user:
	mov byte ptr [edi], 0
	
	; Compare with USERNAME_BUF
	INVOKE Str_compare, ADDR USERNAME_BUF, ADDR TEMP_FIELD
	pop esi
	pop edi
	pop ecx
	jne issue_count_advance
	
	; Username matches, increment counter
	inc esi
	
issue_count_advance:
	add ebx, ecx
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Dh
	jne issue_count_lf
	inc ebx
issue_count_lf:
	cmp byte ptr [OFFSET buffer_mem + ebx], 0Ah
	jne issue_count_next
	inc ebx
issue_count_next:
	jmp issue_count_loop
	
issue_check_limit:
	; Check if user has 5 or more books
	cmp esi, 5
	jge issue_limit_reached
	
issue_check_done:
	; User has less than 5 books, proceed with issuing
	
	; Prompt for ISBN
	INVOKE MSG_DISPLAY, ADDR ISSUE_BOOK_MSG
	mov edx, OFFSET ISBN_SEARCH_BUF
	mov ecx, 20
	CALL READSTRING
	
	; First check if book exists in BOOKS.txt
	INVOKE CreateFile, ADDR BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	mov filehandle, eax
	cmp eax, INVALID_HANDLE_VALUE
	je issue_book_not_found
	
	CALL ReadAllBooks
	INVOKE CloseHandle, filehandle
	
	; Search for ISBN in BUFFER_BOOK (field 6)
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je issue_book_not_found
	
	xor ebx, ebx ; offset in buffer
	mov edi, OFFSET TEMP_FIELD
	mov byte ptr [edi], 0 ; flag for found
	
issue_search_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge issue_book_not_found
	
	lea edi, [OFFSET BUFFER_BOOK + ebx]
	
	; Find line length
	xor ecx, ecx
issue_find_eol:
	mov al, [edi + ecx]
	cmp al, 0
	je issue_process_line
	cmp al, 0Dh
	je issue_process_line
	inc ecx
	jmp issue_find_eol
	
issue_process_line:
	cmp ecx, 0
	je issue_advance_empty
	
	; Extract ISBN (6th field) - skip 5 commas
	push ecx
	push edi
	
	mov esi, edi
	xor edx, edx ; field counter
	xor ecx, ecx ; position in line
	
issue_find_isbn_field:
	mov al, [esi]
	cmp al, 0
	je issue_extract_isbn
	cmp al, 0Dh
	je issue_extract_isbn
	cmp al, ','
	jne issue_skip_char
	inc edx
	cmp edx, 5
	je issue_extract_isbn
issue_skip_char:
	inc esi
	jmp issue_find_isbn_field
	
issue_extract_isbn:
	; Skip the last comma if we found 5
	cmp edx, 5
	jne issue_line_done
	cmp byte ptr [esi], ','
	jne issue_start_copy
	inc esi
	
issue_start_copy:
	; Copy ISBN to TEMP_FIELD
	mov edi, OFFSET TEMP_FIELD
issue_copy_isbn:
	mov al, [esi]
	cmp al, 0
	je issue_compare
	cmp al, 0Dh
	je issue_compare
	cmp al, 0Ah
	je issue_compare
	mov [edi], al
	inc esi
	inc edi
	jmp issue_copy_isbn
	
issue_compare:
	mov byte ptr [edi], 0
	
	; Compare with ISBN_SEARCH_BUF
	INVOKE Str_compare, ADDR ISBN_SEARCH_BUF, ADDR TEMP_FIELD
	je issue_book_found
	
issue_line_done:
	pop edi
	pop ecx
	
issue_advance:
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne issue_skip_lf
	inc ebx
issue_skip_lf:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne issue_next_line
	inc ebx
issue_next_line:
	jmp issue_search_loop

issue_advance_empty:
	xor ecx, ecx
	jmp issue_advance
MEMBER_SIGNIN:
    ; Prompt for username
    INVOKE MSG_DISPLAY, ADDR SIGNIN_USER_MSG
    mov edx, OFFSET USERNAME_BUF
    mov ecx, 20
    CALL READSTRING

    ; Prompt for password
    INVOKE MSG_DISPLAY, ADDR SIGNIN_PASS_MSG
    mov edx, OFFSET PASSWORD_BUF
    mov ecx, 10
    CALL READSTRING

    ; Open MEMBERS.txt for reading
    INVOKE CreateFile, ADDR MEMBERS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
    mov filehandle, eax
    ; check handle
    cmp eax, INVALID_HANDLE_VALUE
    je signin_file_error

    ; Read file into buffer
    invoke ReadFile, filehandle, ADDR BUFFER_MEM, BUFFER_SIZE, ADDR bytesRead, 0
    ; store bytesRead in a temp if you want; using bytesRead directly is fine
    invoke CloseHandle, filehandle

    ; if file empty -> invalid
    mov eax, DWORD PTR bytesRead
    cmp eax, 0
    je invalid

    ; Parse buffer line by line
    xor ebx, ebx            ; ebx = offset into BUFFER_MEM

search_loop:
    mov eax, DWORD PTR bytesRead
    cmp ebx, eax
    jge notfound     ; reached end without match

    ; Calculate line start pointer
    lea edi, [OFFSET BUFFER_MEM + ebx]

    ; Find line length
    xor ecx, ecx
find_eol:
    mov al, [edi + ecx]
    cmp al, 0
    je process_line
    cmp al, 0Dh
    je process_line
    cmp al, 0Ah
    je process_line
    inc ecx
    jmp find_eol

process_line:
    ; Store line length on stack
    push ecx
    
    cmp ecx, 0
    je advance_offset   ; empty line, skip

    ; Find comma position in edx (0..ecx-1)
    xor edx, edx
find_comma:
    cmp edx, ecx
    jge advance_offset
    cmp byte ptr [edi + edx], ','
    je got_comma
    inc edx
    jmp find_comma

got_comma:
    ; Save comma position and line start
    push edx
    push edi
    
    ; Copy username (length = edx) to LINE_USER_BUF
    mov esi, edi
    mov edi, OFFSET LINE_USER_BUF
    mov ecx, edx
copy_user:
    cmp ecx, 0
    je term_user
    mov al, [esi]
    mov [edi], al
    inc esi
    inc edi
    dec ecx
    jmp copy_user
term_user:
    mov byte ptr [edi], 0

    ; Restore registers
    pop edi  ; line start
    pop edx  ; comma position
    
    ; Calculate password length = lineLen - commaIndex - 1
    mov eax, [esp]  ; get line length from stack (don't pop yet)
    sub eax, edx
    dec eax
    cmp eax, 0
    jle term_pass2

    ; Copy password to LINE_PASS_BUF
    push edi
    lea esi, [edi + edx + 1]  ; start after comma
    mov edi, OFFSET LINE_PASS_BUF
    mov ecx, eax  ; password length
copy_pass:
    cmp ecx, 0
    je term_pass2
    mov al, [esi]
    mov [edi], al
    inc esi
    inc edi
    dec ecx
    jmp copy_pass
term_pass2:
    mov byte ptr [edi], 0
    pop edi

    ; Compare username
    INVOKE Str_compare, ADDR USERNAME_BUF, ADDR LINE_USER_BUF
    jne restore_and_continue
    
    ; Compare password
    INVOKE Str_compare, ADDR PASSWORD_BUF, ADDR LINE_PASS_BUF
    jne restore_and_continue

    ; Found match -> clean up stack, show success message with username and member menu
    pop ecx  ; remove line length from stack
    
    ; Display "Login successful! Welcome, "
    INVOKE MSG_DISPLAY, ADDR MEMBER_SUCCESS_MSG
    
    ; Display the username
    mov edx, OFFSET LINE_USER_BUF
    call WriteString
    
    ; Display "."
    INVOKE MSG_DISPLAY, ADDR MEMBER_SUCCESS_MSG2
    
    JMP SHOW_MEMBER_MENU

restore_and_continue:
    ; Get line length from stack
    pop ecx
    
    ; Advance offset by line length
    add ebx, ecx

    ; Skip CR/LF
    cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Dh
    jne skip_lf_member
    inc ebx
skip_lf_member:
    cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Ah
    jne cont_loop
    inc ebx
cont_loop:
    jmp search_loop

advance_offset:
    ; Pop line length
    pop ecx
    
    ; Skip this line
    add ebx, ecx
    
    ; Skip CR/LF
    cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Dh
    jne skip_lf_member2
    inc ebx
skip_lf_member2:
    cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Ah
    jne after_cr
    inc ebx
after_cr:
    jmp search_loop

notfound:
    ; no matching entry
    jmp invalid

signin_file_error:
    ; could not open file; treat as invalid login
    INVOKE MSG_DISPLAY, ADDR INVALID_CRED_MSG
    JMP START

invalid:
    INVOKE MSG_DISPLAY, ADDR INVALID_CRED_MSG
    JMP START

LIB_LOGIN:
		; Prompt for librarian code and validate
		INVOKE MSG_DISPLAY, ADDR LIB_LOGIN_MSG
		CALL READINT
		CMP EAX, 987102
		JE LIB_LOGIN_SUCCESS
		INVOKE MSG_DISPLAY, ADDR INVALID_CODE_MSG
		JMP START

LIB_LOGIN_SUCCESS:
		INVOKE MSG_DISPLAY, ADDR LIB_SUCCESS_MSG
		JMP SHOW_FULL_MENU

;----------------------------------------
;------------REGISTER MEMBERS------------
;----------------------------------------
REG_M:
	INVOKE MSG_DISPLAY, ADDR REG_MSG
	;INVOKE STRING_INPUT, ADDR INPUT_STRING

	MOV ESI, OFFSET MEMBERS
	MOV EAX, MEMBER_SIZE
	MUL NUM_MEMBERS
	ADD ESI, EAX
	MOV EDX, ESI
	MOV ECX, MEMBER_SIZE
	CALL READSTRING
	INC NUM_MEMBERS

	; Append the newly registered member to MEMBERS.txt
	INVOKE CreateFile,
		ADDR MEMBERS_FILE,    ; lpFileName
		GENERIC_WRITE,       ; dwDesiredAccess
		DO_NOT_SHARE,        ; dwShareMode
		NULL,                ; lpSecurityAttributes
		OPEN_ALWAYS,         ; dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL, ; dwFlagsAndAttributes
		0                    ; hTemplateFile
	mov filehandle, eax

	; Move file pointer to end for appending
	INVOKE SetFilePointer, filehandle, 0, 0, FILE_END

	; Prompt for a password for this member
	; Prompt for a password for this member
GET_PASSWORD:
    INVOKE MSG_DISPLAY, ADDR SIGNIN_PASS_MSG
    mov edx, OFFSET PASSWORD_BUF
    mov ecx, 20                ; allow user to type up to 20 chars
    CALL READSTRING

    ; Check password length >= 8
    mov edx, OFFSET PASSWORD_BUF
    INVOKE Str_length, edx     ; result in EAX
    cmp eax, 8
    jl PASS_TOO_SHORT          ; if < 8, show error and re-enter

    jmp PASS_OK

PASS_TOO_SHORT:
    INVOKE MSG_DISPLAY, ADDR PASS_TOO_SHORT_MSG
	call Crlf
    jmp GET_PASSWORD

PASS_OK:


	; ESI already points to the member buffer; write name to file
	mov edx, esi          ; pointer to name buffer
	INVOKE Str_length, edx
	mov ecx, eax          ; length returned in EAX
	mov eax, filehandle
	call WriteToFile

	; write comma separator
	mov eax, filehandle
	mov edx, OFFSET COMMA_BYTE
	mov ecx, 1
	call WriteToFile

	; write password
	mov edx, OFFSET PASSWORD_BUF
	INVOKE Str_length, edx
	mov ecx, eax
	mov eax, filehandle
	call WriteToFile

	; write CRLF after the entry
	mov eax, filehandle
	mov edx, OFFSET CRLF_BYTES
	mov ecx, 2
	call WriteToFile

	invoke CloseHandle, filehandle


		JMP START

; VIEW MEMBERS FROM FILE
VIEW_MFILE:
	INVOKE CreateFile,
	ADDR MEMBERS_FILE, ; ptr to filename
	GENERIC_READ, ; mode = Can read
	DO_NOT_SHARE, ; share mode
	NULL, ; ptr to security attributes
	OPEN_ALWAYS, ; open an existing file
	FILE_ATTRIBUTE_NORMAL, ; normal file attribute
	0 ; not used
	mov filehandle, eax ; Copy handle to variable
	invoke ReadFile,
	filehandle, ; file handle
	addr BUFFER_MEM, ; where to read
	BUFFER_SIZE, ; num bytes to read
	addr bytesRead, ; bytes actually read
	0
	invoke CloseHandle,
	filehandle
	; null-terminate buffer at bytesRead
	mov eax, DWORD PTR bytesRead
	lea edi, [OFFSET BUFFER_MEM]
	add edi, eax
	mov byte ptr [edi], 0

	; Parse BUFFER_MEM line by line and print only the first CSV field (name)
	mov esi, OFFSET BUFFER_MEM
	xor ebx, ebx            ; offset into buffer

vm_loop_file:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge vm_done_file

	; line start = BUFFER_MEM + ebx
	lea edi, [OFFSET BUFFER_MEM + ebx]
	xor ecx, ecx
vm_find_eol_file:
	mov al, [edi + ecx]
	cmp al, 0
	je vm_proc_line_file
	cmp al, 0Dh
	je vm_proc_line_file
	cmp al, 0Ah
	je vm_proc_line_file
	inc ecx
	jmp vm_find_eol_file

vm_proc_line_file:
	cmp ecx, 0
	je vm_advance_only_file

	; copy up to first comma (or end) into TEMP_FIELD
	lea esi, [OFFSET BUFFER_MEM + ebx]
	mov edi, OFFSET TEMP_FIELD
	xor edx, edx
vm_copy_name_file:
	mov al, [esi + edx]
	cmp al, ','
	je vm_name_done_file
	cmp al, 0Dh
	je vm_name_done_file
	cmp al, 0Ah
	je vm_name_done_file
	mov [edi], al
	inc edi
	inc edx
	cmp edx, ecx
	jl vm_copy_name_file
vm_name_done_file:
	mov byte ptr [edi], 0

	; print the name
	mov edx, OFFSET TEMP_FIELD
	call WriteString
	call CRLF

	; advance offset by this line length (ecx)
	add ebx, ecx
	; skip CR/LF if present
	cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Dh
	jne vm_loop_continue_file
	inc ebx
	cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Ah
	jne vm_loop_continue_file
	inc ebx
vm_loop_continue_file:
	jmp vm_loop_file

vm_advance_only_file:
	; empty line - skip one char and continue
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Dh
	jne vm_loop_after_advance_file
	inc ebx
	cmp byte ptr [OFFSET BUFFER_MEM + ebx], 0Ah
	jne vm_loop_after_advance_file
	inc ebx
vm_loop_after_advance_file:
	jmp vm_loop_file

vm_done_file:
	JMP SHOW_FULL_MENU
; Search module: search.inc
; Contains member search menu and search-by-field routines

SEARCH_BOOK_FUNC:
	; Display search menu and read option
	INVOKE MSG_DISPLAY, ADDR SEARCH_MENU_MSG
	CALL READINT ; input for options

	CMP EAX, SEARCH_BY_NAME
	JE SEARCH_BY_NAME_FUNC	; jump to Search By Name section
	CMP EAX, SEARCH_BY_AUTHOR
	JE SEARCH_BY_AUTHOR_FUNC	; jump to Search By Author section
	CMP EAX, SEARCH_BY_PUBLISHER
	JE SEARCH_BY_PUBLISHER_FUNC	; jump to Search By Publisher section
	CMP EAX, SEARCH_BY_YEAR
	JE SEARCH_BY_YEAR_FUNC	; jump to Search By Year section
	CMP EAX, SEARCH_BACK
	JE SHOW_MEMBER_MENU	; back -> return to member menu
	JMP SEARCH_BOOK_FUNC	; invalid option -> show search menu again


; Search menu functions (placeholders)
SEARCH_BY_NAME_FUNC:
	; Prompt for book name to search
	INVOKE MSG_DISPLAY, ADDR BOOK_NAME_PROMPT
	mov edx, OFFSET BOOK_NAME_BUF
	mov ecx, BOOK_NAME_SIZE
	CALL READSTRING

	; Open BOOKS.txt for reading
	INVOKE CreateFile, ADDR BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	mov filehandle, eax
	cmp eax, INVALID_HANDLE_VALUE
	je search_books_notfound

	; Read the whole file into BUFFER_BOOK
	CALL ReadAllBooks

	; check bytesRead
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je search_books_notfound

	; Scan buffer line by line and match book name (first CSV field)
	xor ebx, ebx ; offset in buffer

search_name_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge search_name_done

	; Calculate line start pointer (don't use ESI here, keep it safe)
	lea edi, [OFFSET BUFFER_BOOK + ebx]
	
	; Find line length
	xor ecx, ecx
find_eol_name:
	mov al, [edi + ecx]
	cmp al, 0
	je process_name_line
	cmp al, 0Dh
	je process_name_line
	cmp al, 0Ah
	je process_name_line
	inc ecx
	jmp find_eol_name

process_name_line:
	; Store line length on stack for later use
	push ecx
	
	cmp ecx, 0
	je advance_name_offset_pop

	; find comma index in edx (0..ecx-1)
	xor edx, edx
find_comma_name:
	cmp edx, ecx
	jge advance_name_offset_pop
	cmp byte ptr [edi + edx], ','
	je got_comma_name
	inc edx
	jmp find_comma_name

got_comma_name:
	; Save edx (field length) and copy first field into TEMP_FIELD
	push edx
	push edi
	
	; Source: current line start (edi)
	; Dest: TEMP_FIELD
	; Length: edx
	mov esi, edi
	mov edi, OFFSET TEMP_FIELD
	mov ecx, edx
copy_field_name:
	cmp ecx, 0
	je term_field_name
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_field_name
term_field_name:
	mov byte ptr [edi], 0

	; Restore edi (line start pointer)
	pop edi
	pop edx
	
	; compare user input BOOK_NAME_BUF with TEMP_FIELD
	INVOKE Str_compare, ADDR BOOK_NAME_BUF, ADDR TEMP_FIELD
	jne continue_name

	; match -> parse and display with labels
	; Get line length from stack (don't pop yet)
	mov ecx, [esp]
	
	; Copy full line to TEMP_LINE
	push edi
	mov esi, edi
	mov edi, OFFSET TEMP_LINE
copy_line_to_temp:
	cmp ecx, 0
	je term_temp_line
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_line_to_temp
term_temp_line:
	mov byte ptr [edi], 0
	pop edi
	
	; Display formatted output with labels
	mov edx, OFFSET TEMP_LINE
	call DisplayBookLine

continue_name:
	; Get line length from stack
	pop ecx
	
	; advance offset by lineLen and skip CR/LF
	add ebx, ecx
	
	; skip CR then LF if present
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_name
	inc ebx
skip_lf_name:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne cont_loop_name
	inc ebx
cont_loop_name:
	jmp search_name_loop

advance_name_offset_pop:
	; Pop the line length we pushed earlier
	pop ecx
	
	; Skip this line
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_name2
	inc ebx
skip_lf_name2:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_name
	inc ebx
after_cr_name:
	jmp search_name_loop

search_name_done:
	JMP SEARCH_BOOK_FUNC

search_books_notfound:
	INVOKE MSG_DISPLAY, ADDR NO_BOOKS_MSG
	JMP SEARCH_BOOK_FUNC



SEARCH_BY_AUTHOR_FUNC:
	; Prompt for author name to search
	INVOKE MSG_DISPLAY, ADDR BOOK_AUTHOR_PROMPT
	mov edx, OFFSET BOOK_AUTHOR_BUF
	mov ecx, BOOK_AUTHOR_SIZE
	CALL READSTRING

	; Open BOOKS.txt
	INVOKE CreateFile, ADDR BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
	mov filehandle, eax
	cmp eax, INVALID_HANDLE_VALUE
	je search_books_notfound_author

	; Read the whole file into BUFFER_BOOK
	CALL ReadAllBooks

	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je search_books_notfound_author

	; Scan lines and compare second CSV field (author)
	xor ebx, ebx ; offset

search_author_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge search_author_done

	; Calculate line start pointer
	lea edi, [OFFSET BUFFER_BOOK + ebx]
	
	; Find line length
	xor ecx, ecx
find_eol_author:
	mov al, [edi + ecx]
	cmp al, 0
	je process_author_line
	cmp al, 0Dh
	je process_author_line
	cmp al, 0Ah
	je process_author_line
	inc ecx
	jmp find_eol_author

process_author_line:
	; Store line length on stack
	push ecx
	
	cmp ecx, 0
	je advance_author_offset
	
	; Find first comma (end of book name field)
	xor edx, edx
find_first_comma_author:
	mov al, [edi + edx]
	cmp al, ','
	je got_first_comma_author
	cmp al, 0
	je no_author_field
	cmp al, 0Dh
	je no_author_field
	cmp al, 0Ah
	je no_author_field
	inc edx
	cmp edx, ecx
	jge no_author_field
	jmp find_first_comma_author
	
got_first_comma_author:
	inc edx ; edx now points to start of author field
	push edx ; save author field start position
	
	; Find end of author field (next comma or EOL)
	mov ebp, edx
find_end_author2:
	mov al, [edi + ebp]
	cmp al, 0
	je got_end_author2
	cmp al, 0Dh
	je got_end_author2
	cmp al, 0Ah
	je got_end_author2
	cmp al, ','
	je got_end_author2
	inc ebp
	jmp find_end_author2
	
got_end_author2:
	; Calculate author field length (ebp - edx)
	mov eax, ebp
	sub eax, edx
	cmp eax, 0
	jle restore_author_and_continue
	
	; Copy author field to TEMP_FIELD
	push edi
	push ebp
	
	lea esi, [edi + edx]  ; source = line start + author field offset
	mov edi, OFFSET TEMP_FIELD
	mov ecx, eax  ; length
copy_author_to_temp:
	cmp ecx, 0
	je term_author_temp
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_author_to_temp
term_author_temp:
	mov byte ptr [edi], 0
	
	pop ebp
	pop edi
	
	; Compare with user input
	INVOKE Str_compare, ADDR BOOK_AUTHOR_BUF, ADDR TEMP_FIELD
	jne restore_author_and_continue
	
	; Match found - copy and display with labels
	mov ecx, [esp + 4]  ; get line length from stack (skip author field start)
	
	push edi
	lea esi, [OFFSET BUFFER_BOOK + ebx]
	mov edi, OFFSET TEMP_LINE
copy_line_author:
	cmp ecx, 0
	je term_temp_line_author
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_line_author
term_temp_line_author:
	mov byte ptr [edi], 0
	pop edi
	
	mov edx, OFFSET TEMP_LINE
	call DisplayBookLine

restore_author_and_continue:
	; Clean up stack (author field start)
	pop edx
	; Get line length
	pop ecx
	
	; Advance offset by line length
	add ebx, ecx
	
	; Skip CR/LF
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_author
	inc ebx
skip_lf_author:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_author
	inc ebx
after_cr_author:
	jmp search_author_loop

advance_author_offset:
	; Pop line length
	pop ecx
	
	; Skip this line
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_author2
	inc ebx
skip_lf_author2:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_author2
	inc ebx
after_cr_author2:
	jmp search_author_loop

no_author_field:
	; Pop line length and skip line
	pop ecx
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_author3
	inc ebx
skip_lf_author3:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_author3
	inc ebx
after_cr_author3:
	jmp search_author_loop

search_author_done:
	JMP SEARCH_BOOK_FUNC

search_books_notfound_author:
	INVOKE MSG_DISPLAY, ADDR NO_BOOKS_MSG
	JMP SEARCH_BOOK_FUNC

SEARCH_BY_PUBLISHER_FUNC:
	; Prompt for publisher name to search
	INVOKE MSG_DISPLAY, ADDR BOOK_PUBLISHER_PROMPT
	mov edx, OFFSET BOOK_PUBLISHER_BUF
	mov ecx, BOOK_PUBLISHER_SIZE
	CALL READSTRING

	; Open BOOKS.txt
	INVOKE CreateFile, ADDR BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
	mov filehandle, eax
	cmp eax, INVALID_HANDLE_VALUE
	je search_books_notfound_publisher

	; Read the whole file into BUFFER_BOOK
	CALL ReadAllBooks

	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je search_books_notfound_publisher

	; Parse lines and match publisher (third CSV field)
	xor ebx, ebx

search_publisher_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge search_publisher_done

	; Calculate line start
	lea edi, [OFFSET BUFFER_BOOK + ebx]
	
	; Find line length
	xor ecx, ecx
find_eol_publisher:
	mov al, [edi + ecx]
	cmp al, 0
	je process_publisher_line
	cmp al, 0Dh
	je process_publisher_line
	cmp al, 0Ah
	je process_publisher_line
	inc ecx
	jmp find_eol_publisher

process_publisher_line:
	; Store line length
	push ecx
	
	cmp ecx, 0
	je advance_publisher_offset

	; Find first comma (skip book name)
	xor edx, edx
find_first_comma_pub:
	mov al, [edi + edx]
	cmp al, ','
	je found_first_comma_pub
	cmp al, 0
	je no_publisher_field
	cmp al, 0Dh
	je no_publisher_field
	cmp al, 0Ah
	je no_publisher_field
	inc edx
	cmp edx, ecx
	jge no_publisher_field
	jmp find_first_comma_pub
	
found_first_comma_pub:
	inc edx
	
	; Find second comma (skip author)
find_second_comma_pub:
	mov al, [edi + edx]
	cmp al, ','
	je found_second_comma_pub
	cmp al, 0
	je no_publisher_field
	cmp al, 0Dh
	je no_publisher_field
	cmp al, 0Ah
	je no_publisher_field
	inc edx
	cmp edx, ecx
	jge no_publisher_field
	jmp find_second_comma_pub
	
found_second_comma_pub:
	inc edx ; edx now points to start of publisher field
	push edx
	
	; Find end of publisher field
	mov ebp, edx
find_end_publisher2:
	mov al, [edi + ebp]
	cmp al, 0
	je got_end_publisher2
	cmp al, 0Dh
	je got_end_publisher2
	cmp al, 0Ah
	je got_end_publisher2
	cmp al, ','
	je got_end_publisher2
	inc ebp
	jmp find_end_publisher2
	
got_end_publisher2:
	; Calculate publisher field length
	mov eax, ebp
	sub eax, edx
	cmp eax, 0
	jle restore_publisher_and_continue
	
	; Copy publisher to TEMP_FIELD
	push edi
	push ebp
	
	lea esi, [edi + edx]
	mov edi, OFFSET TEMP_FIELD
	mov ecx, eax
copy_publisher_to_temp:
	cmp ecx, 0
	je term_publisher_temp
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_publisher_to_temp
term_publisher_temp:
	mov byte ptr [edi], 0
	
	pop ebp
	pop edi
	
	; Compare
	INVOKE Str_compare, ADDR BOOK_PUBLISHER_BUF, ADDR TEMP_FIELD
	jne restore_publisher_and_continue
	
	; Match - copy and display with labels
	mov ecx, [esp + 4]
	
	push edi
	lea esi, [OFFSET BUFFER_BOOK + ebx]
	mov edi, OFFSET TEMP_LINE
copy_line_pub:
	cmp ecx, 0
	je term_temp_line_pub
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_line_pub
term_temp_line_pub:
	mov byte ptr [edi], 0
	pop edi
	
	mov edx, OFFSET TEMP_LINE
	call DisplayBookLine

restore_publisher_and_continue:
	pop edx
	pop ecx
	
	; Advance offset
	add ebx, ecx
	
	; Skip CR/LF
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_publisher
	inc ebx
skip_lf_publisher:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_publisher
	inc ebx
after_cr_publisher:
	jmp search_publisher_loop

advance_publisher_offset:
	pop ecx
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_publisher2
	inc ebx
skip_lf_publisher2:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_publisher2
	inc ebx
after_cr_publisher2:
	jmp search_publisher_loop

no_publisher_field:
	pop ecx
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_publisher3
	inc ebx
skip_lf_publisher3:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_publisher3
	inc ebx
after_cr_publisher3:
	jmp search_publisher_loop

search_publisher_done:
	JMP SEARCH_BOOK_FUNC

search_books_notfound_publisher:
	INVOKE MSG_DISPLAY, ADDR NO_BOOKS_MSG
	JMP SEARCH_BOOK_FUNC

SEARCH_BY_YEAR_FUNC:
	; Prompt for year to search
	INVOKE MSG_DISPLAY, ADDR BOOK_YEAR_PROMPT
	mov edx, OFFSET BOOK_YEAR_BUF
	mov ecx, 10
	CALL READSTRING

	; Open BOOKS.txt
	INVOKE CreateFile, ADDR BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
	mov filehandle, eax
	cmp eax, INVALID_HANDLE_VALUE
	je search_books_notfound_year

	; Read the whole file into BUFFER_BOOK
	CALL ReadAllBooks

	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je search_books_notfound_year

	; Parse lines and match year (fifth CSV field; name,author,publisher,genre,year,isbn)
	xor ebx, ebx

search_year_loop:
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge search_year_done

	; Calculate line start
	lea edi, [OFFSET BUFFER_BOOK + ebx]
	
	; Find line length
	xor ecx, ecx
find_eol_year:
	mov al, [edi + ecx]
	cmp al, 0
	je process_year_line
	cmp al, 0Dh
	je process_year_line
	cmp al, 0Ah
	je process_year_line
	inc ecx
	jmp find_eol_year

process_year_line:
	; Store line length
	push ecx
	
	cmp ecx, 0
	je advance_year_offset

	; Find the start of 5th field (year) by counting 4 commas
	xor edx, edx  ; index
	xor ebp, ebp  ; comma count

find_year_field:
	mov al, [edi + edx]
	cmp al, 0
	je no_year_field
	cmp al, 0Dh
	je no_year_field
	cmp al, 0Ah
	je no_year_field
	cmp al, ','
	jne skip_comma_year
	inc ebp
	cmp ebp, 4
	je year_field_start
skip_comma_year:
	inc edx
	cmp edx, ecx
	jge no_year_field
	jmp find_year_field

year_field_start:
	inc edx  ; move past the 4th comma
	push edx
	
	; Find end of year field
	mov ebp, edx
find_end_year2:
	mov al, [edi + ebp]
	cmp al, 0
	je got_end_year2
	cmp al, 0Dh
	je got_end_year2
	cmp al, 0Ah
	je got_end_year2
	cmp al, ','
	je got_end_year2
	inc ebp
	jmp find_end_year2
	
got_end_year2:
	; Calculate year field length
	mov eax, ebp
	sub eax, edx
	cmp eax, 0
	jle restore_year_and_continue
	
	; Copy year to TEMP_FIELD
	push edi
	push ebp
	
	lea esi, [edi + edx]
	mov edi, OFFSET TEMP_FIELD
	mov ecx, eax
copy_year_to_temp:
	cmp ecx, 0
	je term_year_temp
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_year_to_temp
term_year_temp:
	mov byte ptr [edi], 0
	
	pop ebp
	pop edi
	
	; Compare
	INVOKE Str_compare, ADDR BOOK_YEAR_BUF, ADDR TEMP_FIELD
	jne restore_year_and_continue
	
	; Match - copy and display with labels
	mov ecx, [esp + 4]
	
	push edi
	lea esi, [OFFSET BUFFER_BOOK + ebx]
	mov edi, OFFSET TEMP_LINE
copy_line_year:
	cmp ecx, 0
	je term_temp_line_year
	mov al, [esi]
	mov [edi], al
	inc esi
	inc edi
	dec ecx
	jmp copy_line_year
term_temp_line_year:
	mov byte ptr [edi], 0
	pop edi
	
	mov edx, OFFSET TEMP_LINE
	call DisplayBookLine

restore_year_and_continue:
	pop edx
	pop ecx
	
	; Advance offset
	add ebx, ecx
	
	; Skip CR/LF
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_year
	inc ebx
skip_lf_year:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_year
	inc ebx
after_cr_year:
	jmp search_year_loop

advance_year_offset:
	pop ecx
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_year2
	inc ebx
skip_lf_year2:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_year2
	inc ebx
after_cr_year2:
	jmp search_year_loop

no_year_field:
	pop ecx
	add ebx, ecx
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne skip_lf_year3
	inc ebx
skip_lf_year3:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne after_cr_year3
	inc ebx
after_cr_year3:
	jmp search_year_loop

search_year_done:
	JMP SEARCH_BOOK_FUNC

search_books_notfound_year:
	INVOKE MSG_DISPLAY, ADDR NO_BOOKS_MSG
	JMP SEARCH_BOOK_FUNC
EXIT_MENU:
		INVOKE MSG_DISPLAY, ADDR EXIT_MSG
	
	invoke ExitProcess,0

	
VIEW_SORTED_FUNC:
	; Display sort menu and handle selection
	INVOKE MSG_DISPLAY, ADDR SORT_MENU_MSG
	CALL READINT

	CMP EAX, 1
	JE SORT_NAME_ASC
	CMP EAX, 2
	JE SORT_NAME_DESC
	CMP EAX, 3
	JE SORT_AUTHOR_ASC
	CMP EAX, 4
	JE SORT_AUTHOR_DESC
	CMP EAX, 5
	JE SORT_PUB_ASC
	CMP EAX, 6
	JE SORT_PUB_DESC
	CMP EAX, 7
	JE SORT_YEAR_ASC
	CMP EAX, 8
	JE SORT_YEAR_DESC
	CMP EAX, 9
	JE SORT_ISBN_ASC
	CMP EAX, 10
	JE SORT_ISBN_DESC
	CMP EAX, 11
	JE SHOW_MEMBER_MENU

	; invalid option -> show sort menu again
	JMP VIEW_SORTED_FUNC

; Sort option handlers
SORT_NAME_ASC:
    mov eax, 0  ; field index 0 = name
    mov ebx, 0  ; ascending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_NAME_DESC:
    mov eax, 0  ; field index 0 = name
    mov ebx, 1  ; descending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_AUTHOR_ASC:
    mov eax, 1  ; field index 1 = author
    mov ebx, 0  ; ascending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_AUTHOR_DESC:
    mov eax, 1  ; field index 1 = author
    mov ebx, 1  ; descending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_PUB_ASC:
    mov eax, 2  ; field index 2 = publisher
    mov ebx, 0  ; ascending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_PUB_DESC:
    mov eax, 2  ; field index 2 = publisher
    mov ebx, 1  ; descending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_YEAR_ASC:
    mov eax, 4  ; field index 4 = year
    mov ebx, 0  ; ascending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_YEAR_DESC:
    mov eax, 4  ; field index 4 = year
    mov ebx, 1  ; descending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_ISBN_ASC:
    mov eax, 5  ; field index 5 = ISBN
    mov ebx, 0  ; ascending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU

SORT_ISBN_DESC:
    mov eax, 5  ; field index 5 = ISBN
    mov ebx, 1  ; descending order
    call SortAndDisplayBooks
    JMP SHOW_MEMBER_MENU
SortAndDisplayBooks PROC
	push eax
	push ebx
	push ecx
	push edx
	push esi
	push edi
	
	; Save sort parameters
	push eax  ; field index
	push ebx  ; order
	
	; Open BOOKS.txt
	INVOKE CreateFile, ADDR BOOKS_FILE, GENERIC_READ, DO_NOT_SHARE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
	cmp eax, INVALID_HANDLE_VALUE
	je sort_no_books
	
	mov filehandle, eax
	call ReadAllBooks
	
	; Check if file has data
	mov eax, DWORD PTR bytesRead
	cmp eax, 0
	je sort_no_books
	
	; Parse buffer into line pointers
	call ParseLinesIntoArray
	
	; Check if we have books
	mov eax, NUM_LINES
	cmp eax, 0
	je sort_no_books
	
	; Pop sort parameters
	pop ebx  ; order
	pop eax  ; field index
	
	; Sort the lines
	push eax
	push ebx
	call SortLines
	pop ebx
	pop eax
	
	; Display sorted books
	call DisplaySortedBooks
	
	jmp sort_done
	
sort_no_books:
	; Clean up stack
	pop ebx
	pop eax
	INVOKE MSG_DISPLAY, ADDR NO_BOOKS_MSG
	
sort_done:
	pop edi
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
SortAndDisplayBooks ENDP

; ============================================================================
; ParseLinesIntoArray - Parse BUFFER_BOOK into line pointers
; ============================================================================
ParseLinesIntoArray PROC
	pushad
	
	xor ebx, ebx  ; offset in BUFFER_BOOK
	xor ecx, ecx  ; line counter
	
parse_lines_loop:
	; Check if we reached end of buffer
	mov eax, DWORD PTR bytesRead
	cmp ebx, eax
	jge parse_lines_done
	
	; Check if we reached max books
	cmp ecx, MAX_BOOKS
	jge parse_lines_done
	
	; Store pointer to start of line
	lea esi, [OFFSET BUFFER_BOOK + ebx]
	mov edi, OFFSET LINE_POINTERS
	mov eax, ecx
	shl eax, 2  ; multiply by 4 (size of pointer)
	add edi, eax
	mov [edi], esi
	
	; Find end of line
	xor edx, edx  ; line length
parse_find_eol:
	mov al, [esi + edx]
	cmp al, 0
	je parse_line_end
	cmp al, 0Dh
	je parse_line_end
	cmp al, 0Ah
	je parse_line_end
	inc edx
	jmp parse_find_eol
	
parse_line_end:
	; Store line length
	mov edi, OFFSET LINE_LENGTHS
	mov eax, ecx
	shl eax, 2
	add edi, eax
	mov [edi], edx
	
	; Move to next line
	add ebx, edx
	
	; Skip CR/LF
parse_skip_crlf:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Dh
	jne parse_skip_lf
	inc ebx
parse_skip_lf:
	cmp byte ptr [OFFSET BUFFER_BOOK + ebx], 0Ah
	jne parse_next_line
	inc ebx
	
parse_next_line:
	inc ecx
	jmp parse_lines_loop
	
parse_lines_done:
	mov NUM_LINES, ecx
	popad
	ret
ParseLinesIntoArray ENDP

; ============================================================================
; SortLines - Bubble sort lines by specified field
; Input: EAX = field index, EBX = order (0=asc, 1=desc)
; Uses LINE_POINTERS array
; ============================================================================
SortLines PROC
	; Preserve caller-saved registers
	push eax
	push ebx
	push ecx
	push edx
	push esi
	push edi

	; Allocate locals and store params
	; [esp+0]  = swappedFlag (DWORD)
	; [esp+4]  = passCount  (DWORD)
	; [esp+8]  = fieldIndex (DWORD)
	; [esp+12] = order      (DWORD)
	sub esp, 16
	mov [esp+8], eax     ; save field index
	mov [esp+12], ebx    ; save order

	; Get number of lines
	mov ecx, NUM_LINES
	cmp ecx, 2
	jl sort_lines_done   ; need at least 2 lines to sort

	; Bubble sort outer loop (ecx = n-1 passes)
	dec ecx
	mov [esp+4], ecx     ; passCount

sort_outer_loop:
	mov DWORD PTR [esp], 0  ; swappedFlag = 0

	; Inner loop - compare adjacent elements
	mov edx, 0              ; current index
sort_inner_loop:
	mov eax, edx
	inc eax                 ; next index
	cmp eax, NUM_LINES
	jge sort_check_swapped

	; Get pointers to current and next lines
	mov esi, OFFSET LINE_POINTERS
	mov edi, edx
	shl edi, 2
	add esi, edi
	mov esi, [esi]          ; ESI = current line pointer

	mov edi, OFFSET LINE_POINTERS
	mov ebx, eax
	shl ebx, 2
	add edi, ebx
	mov edi, [edi]          ; EDI = next line pointer

	; Load comparison parameters
	mov eax, [esp+8]        ; field index
	mov ebx, [esp+12]       ; order
	call CompareFields      ; EAX = cmp result (-1,0,1)

	; Check if swap needed
	mov ebx, [esp+12]       ; order
	cmp ebx, 0
	je sort_check_asc

	; Descending order: swap if current < next
	cmp eax, 0
	jge sort_no_swap
	jmp sort_do_swap

sort_check_asc:
	; Ascending order: swap if current > next
	cmp eax, 0
	jle sort_no_swap

sort_do_swap:
	; Swap pointers in LINE_POINTERS
	mov esi, OFFSET LINE_POINTERS
	mov edi, edx
	shl edi, 2
	add esi, edi
	mov edi, [esi]          ; temp = LINE_POINTERS[edx]

	mov ebx, OFFSET LINE_POINTERS
	mov eax, edx
	inc eax
	shl eax, 2
	add ebx, eax
	mov eax, [ebx]
	mov [esi], eax          ; LINE_POINTERS[edx] = LINE_POINTERS[edx+1]
	mov [ebx], edi          ; LINE_POINTERS[edx+1] = temp

	; Set swapped flag
	mov DWORD PTR [esp], 1

sort_no_swap:
	inc edx
	jmp sort_inner_loop

sort_check_swapped:
	; If no swaps were made, we're done
	cmp DWORD PTR [esp], 0
	je sort_lines_done

	dec DWORD PTR [esp+4]   ; passCount--
	cmp DWORD PTR [esp+4], 0
	jg sort_outer_loop

sort_lines_done:
	; Free locals and restore registers
	add esp, 16

	pop edi
	pop esi
	pop edx
	pop ecx
	pop ebx
	pop eax
	ret
SortLines ENDP

; ============================================================================
; CompareFields - Compare specified field from two CSV lines
; Input: ESI = pointer to line 1, EDI = pointer to line 2
;        EAX = field index (0=name, 1=author, etc.)
; Output: EAX = 0 if equal, <0 if line1<line2, >0 if line1>line2
; ============================================================================
CompareFields PROC
	push ebx
	push ecx
	push edx
	push esi
	push edi
	
	; Save field index
	push eax
	
	; Extract field from line 1 into TEMP_FIELD
	call ExtractField
	
	; Copy TEMP_FIELD to SORT_TEMP_LINE for later comparison
	push esi
	push edi
	mov esi, OFFSET TEMP_FIELD
	mov edi, OFFSET SORT_TEMP_LINE
	mov ecx, 200
cmp_copy_loop:
	mov al, [esi]
	mov [edi], al
	cmp al, 0
	je cmp_copy_done
	inc esi
	inc edi
	loop cmp_copy_loop
cmp_copy_done:
	pop edi
	pop esi
	
	; Convert SORT_TEMP_LINE to uppercase for case-insensitive comparison
	push eax
	INVOKE Str_ucase, ADDR SORT_TEMP_LINE
	pop eax
	
	; Extract field from line 2 into TEMP_FIELD
	mov esi, edi
	pop eax
	push eax
	call ExtractField
	
	; Convert TEMP_FIELD to uppercase for case-insensitive comparison
	push eax
	INVOKE Str_ucase, ADDR TEMP_FIELD
	pop eax
	
	; Compare SORT_TEMP_LINE with TEMP_FIELD (both now uppercase)
	; Do lexicographic comparison manually using unsigned comparison
	push esi
	push edi
	mov esi, OFFSET SORT_TEMP_LINE
	mov edi, OFFSET TEMP_FIELD
	xor eax, eax
cmp_strcmp_loop:
	mov al, [esi]
	mov bl, [edi]
	cmp al, bl
	jb cmp_less_than    ; Use unsigned comparison (jb instead of jl)
	ja cmp_greater_than ; Use unsigned comparison (ja instead of jg)
	cmp al, 0
	je cmp_equal
	inc esi
	inc edi
	jmp cmp_strcmp_loop
cmp_less_than:
	mov eax, -1
	jmp cmp_strcmp_done
cmp_greater_than:
	mov eax, 1
	jmp cmp_strcmp_done
cmp_equal:
	xor eax, eax
cmp_strcmp_done:
	pop edi
	pop esi
	; EAX now contains comparison result (-1, 0, or 1)
	
	pop ebx  ; clean up field index from stack
	
	pop edi
	pop esi
	pop edx
	pop ecx
	pop ebx
	ret
CompareFields ENDP

; ============================================================================
; ExtractField - Extract specified field from CSV line
; Input: ESI = pointer to CSV line, EAX = field index
; Output: TEMP_FIELD contains extracted field
; ============================================================================
ExtractField PROC
	push ebx
	push ecx
	push edx
	push esi
	push edi
	
	; Clear TEMP_FIELD
	push eax
	mov edi, OFFSET TEMP_FIELD
	mov ecx, 200
	xor al, al
extract_clear:
	mov [edi], al
	inc edi
	loop extract_clear
	pop eax
	
	; EAX = field index, ESI = line pointer
	mov ecx, eax  ; ecx = fields to skip
	mov edx, 0    ; comma counter
	
	; Skip to the desired field
extract_skip_fields:
	cmp ecx, 0
	je extract_copy_field
	
	mov al, [esi]
	cmp al, 0
	je extract_field_done
	cmp al, 0Dh
	je extract_field_done
	cmp al, 0Ah
	je extract_field_done
	cmp al, ','
	jne extract_next_char
	dec ecx
	
extract_next_char:
	inc esi
	jmp extract_skip_fields
	
extract_copy_field:
	; Copy field to TEMP_FIELD
	mov edi, OFFSET TEMP_FIELD
extract_copy_loop:
	mov al, [esi]
	cmp al, 0
	je extract_field_done
	cmp al, 0Dh
	je extract_field_done
	cmp al, 0Ah
	je extract_field_done
	cmp al, ','
	je extract_field_done
	mov [edi], al
	inc esi
	inc edi
	jmp extract_copy_loop
	
extract_field_done:
	mov byte ptr [edi], 0
	
	pop edi
	pop esi
	pop edx
	pop ecx
	pop ebx
	ret
ExtractField ENDP

; ============================================================================
; DisplaySortedBooks - Display all sorted books from LINE_POINTERS array
; ============================================================================
DisplaySortedBooks PROC
	pushad

	; Display header
	INVOKE MSG_DISPLAY, ADDR VIEW_BOOKS_MSG

	; Loop through sorted line pointers
	xor ecx, ecx
display_sorted_loop:
	cmp ecx, NUM_LINES
	jge display_sorted_done

	; Get pointer to line
	mov esi, OFFSET LINE_POINTERS
	mov eax, ecx
	shl eax, 2
	add esi, eax
	mov esi, [esi]

	; Copy line to TEMP_LINE with proper null termination
	push ecx
	mov edi, OFFSET TEMP_LINE
	mov ecx, 0
display_copy_line:
	mov al, [esi]
	cmp al, 0
	je display_line_copied
	cmp al, 0Dh
	je display_line_copied
	cmp al, 0Ah
	je display_line_copied
	mov [edi], al
	inc esi
	inc edi
	inc ecx
	cmp ecx, 512
	jl display_copy_line
display_line_copied:
	mov byte ptr [edi], 0
	pop ecx

	; Display the line using DisplayBookLine helper
	push ecx
	mov edx, OFFSET TEMP_LINE
	call DisplayBookLine
	pop ecx

	inc ecx
	jmp display_sorted_loop

display_sorted_done:
	popad
	ret
DisplaySortedBooks ENDP
import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:dio/dio.dart';

import '../network/api_client.dart';
import '../config/api_config.dart';

import '../models/profile.dart';
import '../services/match_service.dart';
import '../services/follow_service.dart';
import '../services/auth_service.dart';
import 'profile_detail_screen.dart';
import '../utils/custom_snackbar.dart';

class BrowseScreen extends StatefulWidget {
  final String currentUserId;
  final String searchQuery;
  const BrowseScreen({Key? key, required this.currentUserId, this.searchQuery = ''}) : super(key: key);

  @override
  State<BrowseScreen> createState() => _BrowseScreenState();
}

class _BrowseScreenState extends State<BrowseScreen> with TickerProviderStateMixin {
  List<Profile> _candidates = [];
  bool _loading = true;
  String? _error;
  // Track whether we've ever had candidates in this session. Used to avoid
  // showing a spinner after the very last card is swiped when there are no
  // more profiles to fetch.
  bool _everHadCandidates = false;
  // last horizontal drag velocity recorded on the top card (px/sec). +ve = right
  double _lastDragVelocityX = 0.0;
  // accumulate horizontal drag delta for the current gesture; +ve = right
  double _dragAccum =0.0;
  // Pointer tracking for raw events (used so we don't steal gestures from Dismissible)
  double _pointerStartTime = 0.0;
  double _pointerStartX = 0.0;
  double _lastPointerX = 0.0;
  // (Overlay on drag removed; transient overlay used on successful like)
  // When true, suppress the in-card overlay (used briefly after a swipe)
  
  // per-gesture interpreted direction; true = dragged toward right (notification icon)
  bool? _lastDragWasRight;
  
  // Track if we're currently dismissing to prevent duplicate animations
  bool _isDismissing = false;
  // Track ids swiped programmatically via high-velocity fling so Dismissible
  // doesn't duplicate the action in onDismissed.
  // (legacy) programmatic swipes removed in favor of letting Dismissible
  // animate all flings so the UX feels natural.
  final Set<String> _programmaticSwiped = {};
  // Pagination state for /users
  int _page = 1;
  int _limit = 20;
  int _totalPages = 1;
  // true while we're fetching more profiles to top up the deck
  bool _toppingUp = false;
  
  // Track ids the user swiped away (liked or skipped) during this session so
  // we don't re-add them when fetching more candidates from the server.
  final Set<String> _swipedIds = {};
  // track follow requests sent locally so UI can show 'Requested'
  final Set<String> _followRequestsSent = {};
  // track incoming follow requests (relationship_status == 'request_received')
  // map of target profile id -> follow_request_id
  final Map<String, String?> _incomingFollowRequests = {};
  // loading state for incoming request actions (accept/reject)
  final Map<String, bool> _incomingActionLoading = {};
  // per-profile loading indicator when sending follow
  final Map<String, bool> _followLoading = {};
  // cached like counts for profiles shown in the deck
  final Map<String, int> _likeCounts = {};
  
  // Static cache for candidates to avoid reloading when navigating back
  static List<Profile>? _candidatesCache;
  static int? _pageCache;
  static int? _totalPagesCache;
  // Programmatic card animation state used when user taps like/unlike
  String? _animatingProfileId;
  bool _animatingRight = false;
  AnimationController? _animController;
  
  // Cache for search results to speed up filtering
  final Map<String, List<Profile>> _searchCache = {};

  @override
  void initState() {
    super.initState();
    // If another part of the app (for example ProfileScreen after an upload)
    // has populated the in-memory MatchService profiles cache, use that to
    // seed the browse deck immediately to reflect recent changes.
    final seeded = MatchService.allProfiles();
    if (seeded.isNotEmpty) {
      _candidates = seeded.where((p) => p.id != widget.currentUserId).toList();
      _loading = false;
      _everHadCandidates = _candidates.isNotEmpty;
      // Refresh in background to reconcile pagination/state without showing
      // a loading spinner to the user.
      WidgetsBinding.instance.addPostFrameCallback((_) => _loadCandidates(showLoading: false));
      return;
    }
    // If cache exists, show it immediately and refresh in background
    if (_candidatesCache != null && _candidatesCache!.isNotEmpty) {
      _candidates = List<Profile>.from(_candidatesCache!);
      _page = _pageCache ?? 1;
      _totalPages = _totalPagesCache ?? 1;
      _loading = false;
      _everHadCandidates = true;
      // Still refresh in background
      WidgetsBinding.instance.addPostFrameCallback((_) => _loadCandidates(showLoading: false));
    } else {
      _loadCandidates();
    }
  }

  @override
  void didUpdateWidget(BrowseScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    // When search query changes, trigger rebuild to show filtered results
    // No need for postFrameCallback since filtering is cached and fast
    if (oldWidget.searchQuery != widget.searchQuery) {
      if (mounted) setState(() {});
    }
  }

  Future<void> _loadCandidates({bool showLoading = true}) async {
    if (showLoading) {
      setState(() {
        _loading = true;
        _error = null;
      });
    }
    try {
      // Call the backend /users endpoint via AuthService.paginated. We start at
      // page 1 and fill the deck with returned items.
      final resp = await AuthService().fetchUsersPaginated({'page': _page, 'limit': _limit});
      final List<Map<String, dynamic>> users = (resp['items'] as List).cast<Map<String, dynamic>>();
      final pagination = resp['pagination'] as Map<String, dynamic>?;
      if (pagination != null) {
        _page = (pagination['page'] is int) ? pagination['page'] as int : int.tryParse('${pagination['page'] ?? ''}') ?? _page;
        _limit = (pagination['limit'] is int) ? pagination['limit'] as int : int.tryParse('${pagination['limit'] ?? ''}') ?? _limit;
        _totalPages = (pagination['total_pages'] is int) ? pagination['total_pages'] as int : int.tryParse('${pagination['total_pages'] ?? ''}') ?? _totalPages;
      }
    // Filter out profiles where relationship_status == 'friends' or 'request_received' as the
    // server may return relationships; those users should not appear in the browse deck.
    final List<Profile> profiles = users
    .where((m) => (m['relationship_status'] ?? '').toString() != 'friends'
           && (m['relationship_status'] ?? '').toString() != 'request_received')

      .map((m) => Profile.fromJson(m))
      .toList();
      // If the server returned relationship_status for items, respect it so
      // the UI can show 'Requested' instead of Follow for those users.
      for (final m in users) {
        try {
          final status = m['relationship_status'];
          final id = (m['id'] ?? m['user_id'] ?? m['uid'])?.toString();
          if (status == 'request_sent' && id != null) {
            _followRequestsSent.add(id);
          }
          if (status == 'request_received' && id != null) {
            // server may include follow_request_id for pending incoming requests
            _incomingFollowRequests[id] = (m['follow_request_id'] ?? m['follow_request'] ?? m['follow_request_id'])?.toString();
          }
        } catch (_) {
          // ignore unexpected shapes
        }
      }
      setState(() {
        _candidates = profiles.where((p) => p.id != widget.currentUserId && !_swipedIds.contains(p.id)).toList();
        if (_candidates.isNotEmpty) _everHadCandidates = true;
        // Clear search cache when candidates are refreshed
        _searchCache.clear();
      });
      // Update cache with new candidates
      _candidatesCache = List<Profile>.from(_candidates);
      _pageCache = _page;
      _totalPagesCache = _totalPages;
      
      // kick off async like-count fetches for visible candidates
      // kick off async like-count fetches for visible candidates
      for (final pr in _candidates) {
        _ensureLikeCount(pr.id);
      }
    } catch (e) {
      final msg = e is Exception ? e.toString() : '$e';
      setState(() {
        _error = msg;
        _candidates = [];
      });
    } finally {
      if (showLoading) {
        setState(() => _loading = false);
      }
    }
  }

  void _onFollow(Profile p) async {
    setState(() => _followLoading[p.id] = true);
    try {
      await followService.follow(p.id);
      MatchService.sendFollowRequest(widget.currentUserId, p.id);
      setState(() => _followRequestsSent.add(p.id));
      customSnackBar('Success', 'Follow request sent to ${p.name}');
    } catch (e) {
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to send follow request');
    } finally {
      if (mounted) setState(() => _followLoading[p.id] = false);
    }
  }

  Future<void> _acceptFollow(Profile p) async {
    final reqId = _incomingFollowRequests[p.id];
    if (reqId == null || reqId.isEmpty) return;
    _incomingActionLoading[p.id] = true;
    if (mounted) setState(() {});
    try {
      await followService.acceptRequest(reqId);
      // After accepting, remove incoming request and mark as followed/mutual
      _incomingFollowRequests.remove(p.id);
      MatchService.sendFollowRequest(widget.currentUserId, p.id); // optimistic
      customSnackBar('Success', 'Accepted follow request from ${p.name}');
    } catch (e) {
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to accept request');
    } finally {
      _incomingActionLoading[p.id] = false;
      if (mounted) setState(() {});
    }
  }

  Future<void> _rejectFollow(Profile p) async {
    final reqId = _incomingFollowRequests[p.id];
    if (reqId == null || reqId.isEmpty) return;
    _incomingActionLoading[p.id] = true;
    if (mounted) setState(() {});
    try {
      await followService.deleteRequest(reqId);
      _incomingFollowRequests.remove(p.id);
      customSnackBar('Success', 'Rejected follow request from ${p.name}');
    } catch (e) {
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to reject request');
    } finally {
      _incomingActionLoading[p.id] = false;
      if (mounted) setState(() {});
    }
  }

  Future<void> _like(Profile p) async {
  // like called for id=${p.id}
    try {
  // sending POST /likes/${p.id}
      final options = Options(headers: ApiConfig.jsonHeaders);
      await apiClient.post('/likes/${p.id}', data: jsonEncode({}), options: options);
      MatchService.like(widget.currentUserId, p.id);
      // Suppress success UI feedback for swipe/like to keep UX seamless.
    } catch (e) {
      // Log failure; do not show a snackbar to avoid interrupting the swipe flow.
  // like() error for id=${p.id}
    }
  }

  Future<void> _unlike(Profile p) async {
  // unlike called for id=${p.id}
    try {
  // sending DELETE /likes/${p.id}
      final options = Options(headers: ApiConfig.jsonHeaders);
      await apiClient.delete('/likes/${p.id}', options: options);
      MatchService.unlike(widget.currentUserId, p.id);
    } catch (e) {
  // unlike() error for id=${p.id}
    }
  }

  // Note: explicit _skip helper removed; Dismissible removal and top-up
  // are handled directly inside onDismissed to keep the UX seamless.

  // Called after any swipe (like or skip) to ensure the deck is topped up
  // so the user always sees another card. This fetches additional users
  // when the remaining candidate count is low and merges non-duplicates.
  Future<bool> _onSwiped() async {
    // If there are still enough cards, do nothing.
    const minThreshold = 3;
    if (_candidates.length >= minThreshold) return true;

    try {
      // If we have more pages advance to the next page, else wrap to page 1
      int nextPage = _page;
      if (_candidates.length <= 0) {
        // deck empty: try next page
        nextPage = (_page < _totalPages) ? (_page + 1) : 1;
      } else {
        // When the 15th card is reached (i.e. when remaining count == 15), prefetch next page
        const prefetchThreshold = 15;
        if (_candidates.length <= prefetchThreshold && _page < _totalPages) {
          nextPage = _page + 1;
        }
      }

      // If nextPage equals current and there are pages remaining, still allow
      // a fetch for more items (server may rotate results). Query uses same limit.
  final resp = await AuthService().fetchUsersPaginated({'page': nextPage, 'limit': _limit});
  final items = (resp['items'] as List).cast<Map<String, dynamic>>();
      try {
  // fetched item ids: ${items.map((e) => (e['id'] ?? e['user_id'] ?? e['uid'])?.toString()).toList()}
      } catch (_) {}
      final pagination = resp['pagination'] as Map<String, dynamic>?;
      if (pagination != null) {
        _page = (pagination['page'] is int) ? pagination['page'] as int : int.tryParse('${pagination['page'] ?? ''}') ?? _page;
        _limit = (pagination['limit'] is int) ? pagination['limit'] as int : int.tryParse('${pagination['limit'] ?? ''}') ?? _limit;
        _totalPages = (pagination['total_pages'] is int) ? pagination['total_pages'] as int : int.tryParse('${pagination['total_pages'] ?? ''}') ?? _totalPages;
      }

      // If server returned no items and we requested beyond last page, wrap to first page
      if (items.isEmpty) {
  // fetch returned no items for page=$nextPage (page=$_page totalPages=$_totalPages)
        if (_page >= _totalPages) {
          // wrapping to page 1
      final wrap = await AuthService().fetchUsersPaginated({'page': 1, 'limit': _limit});
          // wrapped raw resp received
      final wrappedItems = (wrap['items'] as List).cast<Map<String, dynamic>>();
  // wrapped fetch returned count=${wrappedItems.length}
      // Do not include users whose relationship_status == 'friends'
      // in the browse deck.
      final List<Profile> wrappedProfiles = wrappedItems
  .where((m) => (m['relationship_status'] ?? '') != 'friends' && (m['relationship_status'] ?? '') != 'request_received')
        .map((m) => Profile.fromJson(m))
        .where((p) => p.id != widget.currentUserId)
        .toList();
          // parsed wrappedProfiles ids=${wrappedProfiles.map((e) => e.id).toList()}
          // Make the first returned profile the visible card by reversing
          // the list so wrappedProfiles[0] becomes the last/top element.
          final display = wrappedProfiles.reversed.toList();
          if (display.isNotEmpty) {
            // Allow the deck to show these users again
            _swipedIds.clear();
                setState(() {
                  _candidates = display;
                  _searchCache.clear(); // Clear search cache when candidates change
                });
                if (_candidates.isNotEmpty) _everHadCandidates = true;
                // replaced candidates with wrapped display length=${display.length}
                for (final pr in display) _ensureLikeCount(pr.id);
          }
          return true;
        }
        return true;
      }

    // Filter out relationship_status == 'friends' from paginated results
    // as well so such profiles never appear in the deck.
    final List<Profile> profiles = items
  .where((m) => (m['relationship_status'] ?? '') != 'friends' && (m['relationship_status'] ?? '') != 'request_received')
      .map((m) => Profile.fromJson(m))
      .where((p) => p.id != widget.currentUserId && !_swipedIds.contains(p.id))
      .toList();
      final existing = _candidates.map((e) => e.id).toSet();
      final toAdd = <Profile>[];
      for (final pr in profiles) if (!existing.contains(pr.id)) toAdd.add(pr);
      if (toAdd.isNotEmpty) {
        setState(() {
          _candidates = [..._candidates, ...toAdd];
          _searchCache.clear(); // Clear search cache when candidates change
        });
        if (_candidates.isNotEmpty) _everHadCandidates = true;
        for (final pr in toAdd) _ensureLikeCount(pr.id);
        return true;
      }
      // Edge case: server returned profiles but they were filtered out by
      // _swipedIds and our deck is empty. In that case, allow cycling by
      // clearing _swipedIds and using the fetched profiles.
      if (_candidates.isEmpty && profiles.isNotEmpty) {
  // all fetched profiles were previously swiped; clearing _swipedIds and replacing candidates
        _swipedIds.clear();
        setState(() {
          _candidates = profiles.reversed.toList();
          _searchCache.clear(); // Clear search cache when candidates change
        });
        if (_candidates.isNotEmpty) _everHadCandidates = true;
        for (final pr in _candidates) _ensureLikeCount(pr.id);
        return true;
      }
      return _candidates.isNotEmpty;
    } catch (_) {
      // ignore errors here; the deck will just remain smaller
      return _candidates.isNotEmpty;
    }
  }

  Future<void> _openProfile(Profile p) async {
    // If user is cached we can navigate immediately without showing a loading dialog.
    final cached = AuthService().getCachedUser(p.id);
    if (cached != null) {
      final raw = Profile.fromJson(cached);
      final fetched = Profile(
        id: raw.id.isNotEmpty ? raw.id : p.id,
        name: raw.name.isNotEmpty ? raw.name : p.name,
        age: raw.age != 0 ? raw.age : p.age,
        bio: raw.bio.isNotEmpty ? raw.bio : p.bio,
        imageUrl: raw.imageUrl.isNotEmpty ? raw.imageUrl : p.imageUrl,
        gender: raw.gender,
        location: raw.location,
        interests: raw.interests,
        hobbies: raw.hobbies,
        relationshipGoals: raw.relationshipGoals,
        partnerQualities: raw.partnerQualities,
      );
  Navigator.of(context).push(MaterialPageRoute(builder: (_) => ProfileDetailScreen(profile: fetched, requested: _followRequestsSent.contains(p.id), onFollow: (id) {
        if (mounted) setState(() => _followRequestsSent.add(id));
      })));
      return;
    }

    // show loading while fetching full profile
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );
    try {
      final Map<String, dynamic> userMap = await AuthService().getUserById(p.id);
      final raw = Profile.fromJson(userMap);
      final fetched = Profile(
        id: raw.id.isNotEmpty ? raw.id : p.id,
        name: raw.name.isNotEmpty ? raw.name : p.name,
        age: raw.age != 0 ? raw.age : p.age,
        bio: raw.bio.isNotEmpty ? raw.bio : p.bio,
        imageUrl: raw.imageUrl.isNotEmpty ? raw.imageUrl : p.imageUrl,
        gender: raw.gender,
        location: raw.location,
        interests: raw.interests,
        hobbies: raw.hobbies,
        relationshipGoals: raw.relationshipGoals,
        partnerQualities: raw.partnerQualities,
      );
  Navigator.of(context).pop();
  Navigator.of(context).push(MaterialPageRoute(builder: (_) => ProfileDetailScreen(profile: fetched, requested: _followRequestsSent.contains(p.id), onFollow: (id) {
        if (mounted) setState(() => _followRequestsSent.add(id));
      })));
    } catch (e) {
      Navigator.of(context).pop();
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to load profile');
    }
  }

  // When user taps "Revisit" after reaching the end of the deck, clear
  // locally tracked swipes and reload page 1 so we call /users again.
  void _revisit() {
    if (mounted) {
      setState(() {
        _error = null;
        _page = 1;
        _swipedIds.clear();
      });
    }
    _loadCandidates();
  }

  // Ensure we have a cached like count for a profile id. This is fire-and-
  // forget and won't block the UI. It normalizes possible response shapes.
  void _ensureLikeCount(String profileId) {
    if (profileId.isEmpty) return;
    if (_likeCounts.containsKey(profileId)) return;
    // fire-and-forget async fetch
    () async {
      try {
        final options = Options(headers: ApiConfig.jsonHeaders);
        final resp = await apiClient.get('/likes/$profileId/count', options: options);
        // server may return { count: 12 } or just 12
        int count = 0;
        if (resp.data is Map && resp.data['count'] != null) {
          count = (resp.data['count'] is int) ? resp.data['count'] as int : int.tryParse('${resp.data['count']}') ?? 0;
        } else if (resp.data is int) {
          count = resp.data == null ? 0 : (resp.data as int);
        } else if (resp.data is String) {
          count = int.tryParse(resp.data as String) ?? 0;
        } else {
          // try to decode generic body
          try {
            final decoded = resp.data is String ? jsonDecode(resp.data as String) : resp.data;
            if (decoded is Map && decoded['count'] != null) {
              count = (decoded['count'] is int) ? decoded['count'] as int : int.tryParse('${decoded['count']}') ?? 0;
            }
          } catch (_) {
            // ignore parse errors
          }
        }
        if (mounted) setState(() => _likeCounts[profileId] = count);
      } catch (e) {
        debugPrint('BrowseScreen: failed to fetch like count for $profileId -> $e');
      }
    }();
  }

  List<Profile> _getFilteredCandidates() {
    if (widget.searchQuery.isEmpty) {
      return _candidates;
    }
    
    // Check if we have cached results for this query
    if (_searchCache.containsKey(widget.searchQuery)) {
      return _searchCache[widget.searchQuery]!;
    }
    
    // Perform the search and cache it
    final query = widget.searchQuery.toLowerCase().trim();
    if (query.isEmpty) {
      return _candidates;
    }
    
    // Optimize filtering by checking shorter strings first and using early returns
    final filtered = <Profile>[];
    for (final p in _candidates) {
      // Check name first (most common match)
      if (p.name.toLowerCase().contains(query)) {
        filtered.add(p);
        continue;
      }
      // Then bio (less common but more expensive)
      if (p.bio.toLowerCase().contains(query)) {
        filtered.add(p);
        continue;
      }
      // Also check location if available
      if (p.location.isNotEmpty && p.location.toLowerCase().contains(query)) {
        filtered.add(p);
        continue;
      }
      // Check interests as well
      if (p.interests.any((interest) => interest.toLowerCase().contains(query))) {
        filtered.add(p);
      }
    }
    
    // Cache the results
    _searchCache[widget.searchQuery] = filtered;
    return filtered;
  }

  List<Widget> _buildCardStack() {
    final filtered = _getFilteredCandidates();
    if (filtered.isEmpty) return [];
  // show up to 4 cards stacked, top is last in list
  final int maxCards = 4;
  final int start = filtered.length - (maxCards > filtered.length ? filtered.length : maxCards);
  final visible = filtered.sublist(start);

    final List<Widget> cards = [];
    for (int i = 0; i < visible.length; i++) {
      final p = visible[i];
      try {
      final isTop = i == visible.length - 1;

      // Position all non-top cards exactly the same as the top card so
      // they are completely hidden behind it. The top card remains
      // interactive and is drawn last to remain on top.
      const double baseTop = 16.0;
      const double baseHorizontal = 16.0;

  final inner = Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(24),
          gradient: LinearGradient(
            colors: [
              Colors.white,
              Colors.grey.shade50,
            ],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
          boxShadow: [
            // Soft colored shadow for depth
            BoxShadow(
              color: Colors.red.shade100.withOpacity(0.3),
              blurRadius: 30,
              spreadRadius: 0,
              offset: const Offset(0, 10),
            ),
            // Sharp shadow for definition
            BoxShadow(
              color: Colors.black.withOpacity(0.08),
              blurRadius: 15,
              spreadRadius: -2,
              offset: const Offset(0, 8),
            ),
            // Subtle top highlight
            BoxShadow(
              color: Colors.white.withOpacity(0.8),
              blurRadius: 1,
              spreadRadius: 0,
              offset: const Offset(0, -1),
            ),
          ],
          // Add a subtle border for definition
          border: Border.all(
            color: Colors.white.withOpacity(0.8),
            width: 1.5,
          ),
        ),
        child: RepaintBoundary(
          child: Material(
            elevation: 0,
            borderRadius: BorderRadius.circular(24),
            color: Colors.transparent,
            child: ClipRRect(
              borderRadius: BorderRadius.circular(24),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                // Top image with a subtle bottom gradient for better text contrast
                GestureDetector(
                  onTap: () => _openProfile(p),
                  child: Container(
                    height: 340,
                    width: double.infinity,
                    decoration: BoxDecoration(
                      color: Colors.grey.shade100,
                      borderRadius: const BorderRadius.only(
                        topLeft: Radius.circular(24),
                        topRight: Radius.circular(24),
                      ),
                    ),
                    child: Stack(
                      fit: StackFit.expand,
                      children: [
                        if (p.imageUrl.isNotEmpty && p.imageUrl != 'null')
                          ClipRRect(
                            borderRadius: const BorderRadius.only(
                              topLeft: Radius.circular(24),
                              topRight: Radius.circular(24),
                            ),
                            child: Image.network(
                              p.imageUrl,
                              fit: BoxFit.cover,
                              width: double.infinity,
                            ),
                          )
                        else
                          Container(
                            decoration: BoxDecoration(
                              gradient: LinearGradient(
                                colors: [Colors.red.shade50, Colors.yellow.shade50],
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                              ),
                            ),
                            child: Center(
                              child: Container(
                                padding: const EdgeInsets.all(20),
                                decoration: BoxDecoration(
                                  color: Colors.white.withOpacity(0.9),
                                  shape: BoxShape.circle,
                                  boxShadow: [
                                    BoxShadow(
                                      color: Colors.black.withOpacity(0.1),
                                      blurRadius: 20,
                                      spreadRadius: 2,
                                    ),
                                  ],
                                ),
                                child: const Icon(Icons.person, size: 64, color: Colors.grey),
                              ),
                            ),
                          ),
                        // Enhanced gradient overlay with multiple layers
                        Positioned(
                          left: 0,
                          right: 0,
                          bottom: 0,
                          height: 150,
                          child: Container(
                            decoration: BoxDecoration(
                              gradient: LinearGradient(
                                begin: Alignment.topCenter,
                                end: Alignment.bottomCenter,
                                colors: [
                                  Colors.transparent,
                                  Colors.black.withOpacity(0.1),
                                  Colors.black.withOpacity(0.4),
                                ],
                                stops: const [0.0, 0.5, 1.0],
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                Container(
                  // Enhanced card content with subtle gradient background
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        Colors.white,
                        Colors.grey.shade50,
                      ],
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                    ),
                    borderRadius: const BorderRadius.only(
                      bottomLeft: Radius.circular(24),
                      bottomRight: Radius.circular(24),
                    ),
                  ),
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      // Show name with age (styled: name bold, age lighter)
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 8.0),
                        child: RichText(
                          textAlign: TextAlign.center,
                          text: TextSpan(
                            children: [
                              TextSpan(
                                text: p.name,
                                style: TextStyle(
                                  fontSize: 22,
                                  fontWeight: FontWeight.w900,
                                  color: Colors.black87,
                                  letterSpacing: 0.3,
                                  height: 1.2,
                                ),
                              ),
                              if (p.age > 0)
                                TextSpan(
                                  text: ', ${p.age}',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.w600,
                                    color: Colors.black54,
                                  ),
                                ),
                            ],
                          ),
                        ),
                      ),
                      const SizedBox(height: 12),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          // Like count pill with enhanced styling
                          Container(
                            height: 44,
                            padding: const EdgeInsets.symmetric(horizontal: 16),
                            decoration: BoxDecoration(
                              gradient: const LinearGradient(
                                colors: [Color(0xFFFFF59D), Color(0xFFE53935)],
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                              ),
                              borderRadius: BorderRadius.circular(22),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.red.shade200.withOpacity(0.4),
                                  blurRadius: 12,
                                  offset: const Offset(0, 4),
                                ),
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.08),
                                  blurRadius: 8,
                                  offset: const Offset(0, 2),
                                ),
                              ],
                              border: Border.all(color: Colors.white.withOpacity(0.3), width: 1),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                // Enhanced heart icon container
                                Container(
                                  width: 32,
                                  height: 32,
                                  decoration: BoxDecoration(
                                    color: Colors.white,
                                    shape: BoxShape.circle,
                                    boxShadow: [
                                      BoxShadow(
                                        color: Colors.black.withOpacity(0.1),
                                        blurRadius: 6,
                                        offset: const Offset(0, 2),
                                      ),
                                    ],
                                  ),
                                  alignment: Alignment.center,
                                  child: const Icon(Icons.favorite, size: 18, color: Color(0xFFE53935)),
                                ),
                                const SizedBox(width: 12),
                                Text(
                                  // defensive: prefer server totalLikes if >0, else fallback to cached count
                                  ((p.totalLikes) > 0 ? p.totalLikes : (_likeCounts[p.id] ?? 0)).toString(),
                                  style: const TextStyle(
                                    fontSize: 15,
                                    fontWeight: FontWeight.w900,
                                    color: Colors.white,
                                    letterSpacing: 0.5,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 14),
                          // If this user has sent us a follow request, show Accept/Reject
                          // buttons on the card. Otherwise show 'Requested' or 'Follow'.
                          _incomingFollowRequests.containsKey(p.id)
                              ? Row(
                                  children: [
                                    ElevatedButton(
                                      onPressed: _incomingActionLoading[p.id] == true ? null : () => _acceptFollow(p),
                                      child: _incomingActionLoading[p.id] == true ? const SizedBox(height: 18, width: 18, child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2)) : const Text('Accept'),
                                      style: ElevatedButton.styleFrom(backgroundColor: Colors.green, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
                                    ),
                                    const SizedBox(width: 8),
                                    OutlinedButton(
                                      onPressed: _incomingActionLoading[p.id] == true ? null : () => _rejectFollow(p),
                                      child: _incomingActionLoading[p.id] == true ? const SizedBox(height: 18, width: 18, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.red)) : const Text('Reject', style: TextStyle(color: Colors.red)),
                                      style: OutlinedButton.styleFrom(side: const BorderSide(color: Colors.red), shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8))),
                                    ),
                                  ],
                                )
                              : (_followRequestsSent.contains(p.id)
                                  ? Container(
                                      height: 44,
                                      padding: const EdgeInsets.symmetric(horizontal: 20),
                                      decoration: BoxDecoration(
                                        color: Colors.grey.shade100,
                                        borderRadius: BorderRadius.circular(22),
                                        border: Border.all(color: Colors.grey.shade300, width: 1.5),
                                      ),
                                      child: Row(
                                        mainAxisSize: MainAxisSize.min,
                                        children: const [
                                          Icon(Icons.check_circle, color: Colors.green, size: 20),
                                          SizedBox(width: 8),
                                          Text(
                                            'Requested',
                                            style: TextStyle(
                                              color: Colors.black87,
                                              fontWeight: FontWeight.w700,
                                              fontSize: 14,
                                            ),
                                          ),
                                        ],
                                      ),
                                    )
                                  : Container(
                                      height: 44,
                                      decoration: BoxDecoration(
                                        gradient: const LinearGradient(
                                          colors: [Color(0xFFE53935), Color(0xFFD32F2F)],
                                          begin: Alignment.topCenter,
                                          end: Alignment.bottomCenter,
                                        ),
                                        borderRadius: BorderRadius.circular(22),
                                        boxShadow: [
                                          BoxShadow(
                                            color: Colors.red.shade300.withOpacity(0.5),
                                            blurRadius: 12,
                                            offset: const Offset(0, 4),
                                          ),
                                          BoxShadow(
                                            color: Colors.black.withOpacity(0.1),
                                            blurRadius: 8,
                                            offset: const Offset(0, 2),
                                          ),
                                        ],
                                      ),
                                      child: ElevatedButton.icon(
                                        onPressed: _followLoading[p.id] == true ? null : () => _onFollow(p),
                                        icon: _followLoading[p.id] == true
                                            ? const SizedBox(
                                                height: 18,
                                                width: 18,
                                                child: CircularProgressIndicator(
                                                  color: Colors.white,
                                                  strokeWidth: 2,
                                                ),
                                              )
                                            : const Icon(Icons.person_add, color: Colors.white, size: 20),
                                        label: Text(
                                          _followLoading[p.id] == true ? 'Sending...' : 'Follow',
                                          style: const TextStyle(
                                            fontSize: 14,
                                            fontWeight: FontWeight.w700,
                                            letterSpacing: 0.5,
                                          ),
                                        ),
                                        style: ButtonStyle(
                                          backgroundColor: MaterialStateProperty.all<Color>(Colors.transparent),
                                          foregroundColor: MaterialStateProperty.all<Color>(Colors.white),
                                          elevation: MaterialStateProperty.all<double>(0),
                                          padding: MaterialStateProperty.all<EdgeInsets>(
                                            const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                                          ),
                                          shape: MaterialStateProperty.all<RoundedRectangleBorder>(
                                            RoundedRectangleBorder(borderRadius: BorderRadius.circular(22)),
                                          ),
                                        ),
                                      ),
                                    )),
                        ],
                      ),
                      const SizedBox(height: 12),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
        ),
      );

      // Wrap top card with a GestureDetector to capture the final fling
      // velocity. Dismissible only reports a DismissDirection which can be
      // ambiguous when TextDirection or other transforms differ; the
      // velocity gives us a robust physical direction (dx > 0 => right).
      Widget childForDismissible = inner;
      if (isTop) {
        // Use raw pointer events instead of GestureDetector so we do NOT
        // win the horizontal gesture arena. Dismissible needs to receive
        // the horizontal drag gestures; Listener lets us observe pointer
        // motion and compute velocity without blocking Dismissible.
        childForDismissible = Listener(
          behavior: HitTestBehavior.opaque,
          onPointerDown: (PointerDownEvent e) {
            _pointerStartTime = e.timeStamp.inMilliseconds.toDouble();
            _pointerStartX = e.position.dx;
            _lastPointerX = e.position.dx;
            _dragAccum = 0.0;
            _lastDragWasRight = null;
          },
          onPointerMove: (PointerMoveEvent e) {
            final delta = e.position.dx - _lastPointerX;
            _lastPointerX = e.position.dx;
            _dragAccum += delta;
            // Removed setState during drag to prevent frame drops and lag
            // The Dismissible widget handles the visual feedback smoothly
          },
          onPointerUp: (PointerUpEvent e) {
            final endTime = e.timeStamp.inMilliseconds.toDouble();
            final durationMs = endTime - _pointerStartTime;
            double v = 0.0;
            if (durationMs > 0) {
              v = (e.position.dx - _pointerStartX) / (durationMs / 1000.0);
            }
            if (mounted) setState(() => _lastDragVelocityX = v);
            debugPrint('BrowseScreen: onPointerUp id=${p.id} velocityX=$v dragAccum=$_dragAccum');

            // Interpret gesture direction primarily from accumulated delta
            // (which reflects the user's motion toward one side), with a
            // velocity fallback for very short drags.
            const accumThreshold = 20; // pixels
            bool isRight;
            if (_dragAccum.abs() >= accumThreshold) {
              // Flip interpretation: on this device left->right swipes produce
              // negative _dragAccum, so treat negative as rightward.
              isRight = _dragAccum < 0;
            } else {
              isRight = v > 0;
            }
            _lastDragWasRight = isRight;
            // Don't trigger setState here - let Dismissible handle the animation
          },
          child: inner,
        );
      }

      // Create the Positioned card; the child is either a Dismissible (top)
      // or an Offstage inner (non-top). This keeps Positioned as direct
      // child of the Stack to avoid ParentDataWidget errors.
      final positionedCard = Positioned(
        key: ValueKey('pos_${p.id}'),
        top: baseTop,
        left: baseHorizontal,
        right: baseHorizontal,
        child: RepaintBoundary(
          // Wrap in RepaintBoundary to optimize rendering during animations
          child: isTop
              ? Dismissible(
                // Faster, smoother animation for responsive feel
                movementDuration: const Duration(milliseconds: 250),
                resizeDuration: const Duration(milliseconds: 150),
                key: ValueKey(p.id),
                direction: DismissDirection.horizontal,
                dismissThresholds: {
                  DismissDirection.startToEnd: 0.18,
                  DismissDirection.endToStart: 0.18,
                },
                confirmDismiss: (direction) async {
                  // Prevent duplicate dismissals
                  if (_isDismissing) return false;
                  _isDismissing = true;
                  
                  // Decide whether the physical swipe was toward the right
                  // (like) using the same heuristic as before.
                  bool isPhysicalRightSwipe = false;
                  if (_lastDragWasRight != null) {
                    isPhysicalRightSwipe = _lastDragWasRight!;
                  } else {
                    if (_lastDragVelocityX.abs() > 40) {
                      isPhysicalRightSwipe = _lastDragVelocityX > 0;
                    } else {
                      final td = Directionality.of(context);
                      isPhysicalRightSwipe = (direction == DismissDirection.startToEnd && td == TextDirection.ltr) ||
                          (direction == DismissDirection.endToStart && td == TextDirection.rtl);
                    }
                  }

                  // If this was a programmatic swipe triggered by tapping a
                  // button, let that handler proceed and avoid double-handling.
                  if (_programmaticSwiped.contains(p.id)) {
                    _programmaticSwiped.remove(p.id);
                    _lastDragVelocityX = 0.0;
                    _dragAccum = 0.0;
                    _lastDragWasRight = null;
                    _isDismissing = false;
                    return false;
                  }

                  // Allow Dismissible to handle animation, then process action
                  final liked = isPhysicalRightSwipe;
                  
                  // Schedule post-dismiss actions without blocking the animation
                  Future.microtask(() async {
                    // Remove from candidates
                    if (mounted) {
                      setState(() {
                        _candidates.removeWhere((x) => x.id == p.id);
                        _swipedIds.add(p.id);
                      });
                    }
                    
                    // Perform network action
                    if (liked) {
                      _like(p);
                      _showTransientLike();
                    } else {
                      _unlike(p);
                    }
                    
                    // Top up candidates
                    if (mounted) setState(() => _toppingUp = true);
                    await _onSwiped();
                    if (mounted) setState(() => _toppingUp = false);
                    
                    // Reset state
                    _lastDragVelocityX = 0.0;
                    _dragAccum = 0.0;
                    _lastDragWasRight = null;
                    _isDismissing = false;
                  });
                  
                  return true; // Allow Dismissible to animate
                },
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    // If we're animating this card programmatically, wrap the
                    // card content in an AnimatedBuilder that translates it off
                    // screen to match the swipe animation. Otherwise render the
                    // normal childForDismissible.
                    if (_animatingProfileId == p.id && _animController != null)
                      AnimatedBuilder(
                        animation: _animController!,
                        builder: (ctx, child) {
                          final width = MediaQuery.of(context).size.width;
                          final dx = (_animatingRight ? 1 : -1) * _animController!.value * (width + 200);
                          final rot = (_animController!.value * 0.12 * (_animatingRight ? 1 : -1));
                          return Transform.translate(
                            offset: Offset(dx, 0),
                            child: Transform.rotate(angle: rot, child: child),
                          );
                        },
                        child: childForDismissible,
                      )
                    else
                      childForDismissible,
                    // In-card drag overlay removed  use transient overlay when a
                    // like is confirmed so the heart animation appears only once
                    // (when the next card is about to appear).
                    // Removed bottom like/dislike buttons; controls moved to top banner
                  ],
                ),
              )
            : Offstage(offstage: true, child: inner),
        ),
      );

      cards.add(positionedCard);
      // Note: like/dislike controls moved out of the card stack and will be
      // rendered alongside the app logo in the build() method so they sit
      // left/right of the logo consistently. This keeps the card overlay
      // area clean and prevents overlapping with card imagery.
      } catch (e, st) {
        debugPrint('BrowseScreen: error building card for index=$i id=${visible[i].id} -> $e');
        debugPrint('$st');
        // skip this card on error
        continue;
      }
    }

    return cards;
  }

  @override
  Widget build(BuildContext context) {

  final double _topOffset = MediaQuery.of(context).padding.top + 20.0;
  final filtered = _getFilteredCandidates();

    return Scaffold(
      // keep the scaffold background white for a clean browse surface
      extendBody: true,
      backgroundColor: const Color(0xFFFFFBF0),
      body: Container(
        // Use a plain white background instead of the red/yellow gradient
        decoration: const BoxDecoration(
          color: Color(0xFFFFFBF0),
        ),
        child: _loading
            ? const Center(child: CircularProgressIndicator(color: Color(0xFFB71C1C)))
            : (filtered.isEmpty
                    ? Center(
                        child: _toppingUp && _everHadCandidates
                            ? const Center(child: CircularProgressIndicator(color: Color(0xFFB71C1C)))
                            : Center(
                                child: Column(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Container(
                                      padding: const EdgeInsets.all(24),
                                      decoration: BoxDecoration(
                                        shape: BoxShape.circle,
                                        gradient: LinearGradient(
                                          colors: [
                                            const Color(0xFFE53935).withOpacity(0.1),
                                            const Color(0xFFFFF59D).withOpacity(0.1),
                                          ],
                                          begin: Alignment.topLeft,
                                          end: Alignment.bottomRight,
                                        ),
                                        boxShadow: [
                                          BoxShadow(
                                            color: const Color(0xFFE53935).withOpacity(0.1),
                                            blurRadius: 20,
                                            spreadRadius: 5,
                                          ),
                                        ],
                                      ),
                                      child: Icon(
                                        Icons.search_off_rounded,
                                        size: 80,
                                        color: const Color(0xFFE53935).withOpacity(0.6),
                                      ),
                                    ),
                                    const SizedBox(height: 24),
                                    Text(
                                      widget.searchQuery.isNotEmpty
                                          ? 'No Matching Profiles'
                                          : (_error == null ? 'No More Profiles' : 'No Profiles Available'),
                                      style: const TextStyle(
                                        fontSize: 24,
                                        fontWeight: FontWeight.bold,
                                        color: Color(0xFFE53935),
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      widget.searchQuery.isNotEmpty
                                          ? 'Try different search terms to find more people'
                                          : (_error == null ? 'You\'ve seen all available profiles' : 'Error: ${_error ?? ''}'),
                                      textAlign: TextAlign.center,
                                      style: TextStyle(
                                        fontSize: 16,
                                        color: Colors.grey[600],
                                      ),
                                    ),
                                    const SizedBox(height: 20),
                                    SizedBox(
                                      width: 200,
                                      child: ElevatedButton(
                                        onPressed: _revisit,
                                        style: ElevatedButton.styleFrom(
                                          padding: const EdgeInsets.symmetric(vertical: 14),
                                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                                        ),
                                        child: const Text(
                                          'Revisit',
                                          style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600)
                                        ),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                      )
                  : Center(
                      child: Column(
                        // allow column to fill available vertical space and
                        // hand remaining area to the card stack via Expanded
                        mainAxisSize: MainAxisSize.max,
                        children: [
                          // spacer to push content below the parent AppBar
                          SizedBox(height: _topOffset),
                          // App brand/logo with like/dislike buttons on either side
                          Builder(
                            builder: (_) {
                              final Profile? topProfile = _candidates.isNotEmpty ? _candidates.last : null;
                              return Column(
                                children: [
                                  Row(
                                    mainAxisSize: MainAxisSize.min,
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    children: [
                                      // Dislike / skip button (left) - upgraded visual
                                      GestureDetector(
                                        onTap: topProfile == null
                                            ? null
                                            : () {
                                                // animate card off-screen to the right (skip)  visual direction reversed
                                                _startProgrammaticDismiss(topProfile, true, liked: false);
                                              },
                                        child: Container(
                                          // Outer ring with subtle red->yellow gradient
                                          width: 52,
                                          height: 52,
                                          padding: const EdgeInsets.all(6),
                                          decoration: BoxDecoration(
                                            shape: BoxShape.circle,
                                            gradient: const LinearGradient(
                                              colors: [Color(0xFFFFF59D), Color(0xFFF06256)],
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            ),
                                            boxShadow: [
                                              BoxShadow(color: Colors.black.withOpacity(0.12), blurRadius: 10, offset: Offset(0, 6)),
                                            ],
                                          ),
                                          child: Container(
                                            // Inner surface for the icon (white to keep contrast)
                                            decoration: BoxDecoration(
                                              color: Colors.white,
                                              shape: BoxShape.circle,
                                              boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.06), blurRadius: 4, offset: Offset(0, 2))],
                                            ),
                                            alignment: Alignment.center,
                                            child: const Icon(Icons.close, color: Color(0xFFE53935), size: 22),
                                          ),
                                        ),
                                      ),
                                      const SizedBox(width: 32),
                                      Image.asset('assets/logo.png', height: 56, fit: BoxFit.contain),
                                      const SizedBox(width: 32),
                                      // Like button (right)
                                      GestureDetector(
                                        onTap: topProfile == null
                                            ? null
                                            : () {
                                                // animate card off-screen to the left (like)  visual direction reversed
                                                _startProgrammaticDismiss(topProfile, false, liked: true);
                                              },
                                        child: Container(
                                          width: 48,
                                          height: 48,
                                          alignment: Alignment.center,
                                          decoration: const BoxDecoration(
                                            shape: BoxShape.circle,
                                            gradient: LinearGradient(
                                              colors: [Color(0xFFFFD54D), Color(0xFFE53935)],
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            ),
                                          ),
                                          child: const Icon(Icons.favorite, color: Colors.white, size: 26),
                                        ),
                                      ),
                                    ],
                                  ),
                                ],
                              );
                            },
                          ),
                          const SizedBox(height: 6),
                          // Let the card stack take remaining space so it won't
                          // overflow on smaller screens.
                          Expanded(
                            child: Center(
                              child: Transform.translate(
                                offset: const Offset(0, -15),
                                child: Stack(
                                  clipBehavior: Clip.hardEdge,
                                  alignment: Alignment.center,
                                  children: _buildCardStack(),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    )),
      ),
    );
  }

  Future<void> _startProgrammaticDismiss(Profile p, bool isRight, {required bool liked}) async {
    // Prevent stacking multiple programmatic animations
    if (_animController != null || _isDismissing) return;
    _isDismissing = true;
    _animatingProfileId = p.id;
    _animatingRight = isRight;
    _animController = AnimationController(
      vsync: this, 
      duration: const Duration(milliseconds: 250), // Match Dismissible speed
    );
    // trigger a rebuild so AnimatedBuilder starts using the controller
    if (mounted) setState(() {});
    try {
      await _animController!.forward();
    } catch (_) {}

    // After animation finishes, perform the same removal and network actions
    if (mounted) {
      setState(() {
        _programmaticSwiped.add(p.id);
        _candidates.removeWhere((x) => x.id == p.id);
        _swipedIds.add(p.id);
      });
    }

    // Perform the network action that corresponds to the button press.
    if (liked) {
      _like(p);
      _showTransientLike();
    } else {
      _unlike(p);
    }

    if (mounted) setState(() => _toppingUp = true);
    await _onSwiped();
    if (mounted) setState(() {
      _toppingUp = false;
      _animatingProfileId = null;
    });

    _animController?.dispose();
    _animController = null;
    _isDismissing = false;
  }

  @override
  void dispose() {
    _animController?.dispose();
    super.dispose();
  }

  // Show a transient like animation in the app's Overlay
  void _showTransientLike() {
  final overlay = Overlay.of(context);
    final overlayEntry = OverlayEntry(builder: (ctx) {
      return _TransientLikeOverlay();
    });
    overlay.insert(overlayEntry);
    // Remove after animation duration
    Future.delayed(const Duration(milliseconds: 800), () {
      overlayEntry.remove();
    });
  }
}

class _TransientLikeOverlay extends StatefulWidget {
  @override
  State<_TransientLikeOverlay> createState() => _TransientLikeOverlayState();
}

class _TransientLikeOverlayState extends State<_TransientLikeOverlay> with SingleTickerProviderStateMixin {
  late final AnimationController _ctl = AnimationController(vsync: this, duration: const Duration(milliseconds: 700));
  @override
  void initState() {
    super.initState();
    _ctl.forward();
    // remove from tree after animation completes; the parent overlay will also remove it by timer
    _ctl.addStatusListener((s) {
      if (s == AnimationStatus.completed) {
        // let parent remove via timer
      }
    });
  }

  @override
  void dispose() {
    _ctl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final scale = CurvedAnimation(parent: _ctl, curve: Curves.elasticOut);
    final fade = CurvedAnimation(parent: _ctl, curve: const Interval(0.0, 0.6, curve: Curves.easeOut));
    return IgnorePointer(
      child: SizedBox.expand(
        child: Center(
          child: AnimatedBuilder(
            animation: _ctl,
            builder: (_, __) {
              return Opacity(
                opacity: 1.0 - fade.value,
                child: Transform.scale(
                  scale: 0.6 + (scale.value * 1.2),
                  child: Container(
                    padding: const EdgeInsets.all(18),
                    decoration: BoxDecoration(
                      color: Colors.yellow.shade100.withOpacity(0.95),
                      shape: BoxShape.circle,
                      boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.2), blurRadius: 8)],
                    ),
                    child: Icon(Icons.favorite, size: 56, color: Colors.red),
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }
}
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';

import '../models/message.dart';
import '../services/socket_service.dart';
import '../services/message_service.dart';
import '../services/auth_service.dart';
import '../utils/custom_snackbar.dart';

// Lightweight in-memory cache for chat conversations
class _ChatCache {
  final List<Message> messages;
  final List<String> ids;
  final DateTime updatedAt;
  const _ChatCache(this.messages, this.ids, this.updatedAt);
}

class ChatScreen extends StatefulWidget {
  final String currentUserId;
  final String peerId;
  final String peerName;

  const ChatScreen({Key? key, required this.currentUserId, required this.peerId, required this.peerName}) : super(key: key);

  /// Clear all cached chat messages. Should be called on logout to prevent
  /// data leaks between user sessions.
  static void clearAllCache() {
    _ChatScreenState._cache.clear();
  }

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  // Fields
  late List<Message> _messages = [];
  // Store server-side message IDs corresponding to _messages indices
  final List<String> _messageIds = [];
  // Current user's resolved ID (falls back to widget.currentUserId until resolved)
  late String _myId = '';
  // Static cache shared across ChatScreen instances
  static final Map<String, _ChatCache> _cache = <String, _ChatCache>{};
  String get _cacheKey => '${widget.currentUserId}->${widget.peerId}';
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  bool _sending = false;
  bool _loadingMessages = true;
  bool _peerTyping = false;
  bool _typingStartedSent = false;
  // Debounce for our own typing start/stop emits
  Timer? _typingResetTimer;
  // Auto-clear timer for peer typing indicator
  Timer? _peerTypingAutoResetTimer;
  bool _peerOnline = false;
  DateTime? _peerLastSeen;
  Timer? _presenceTicker;
  bool? _explicitOnline;
  bool _presenceInitialized = false; // becomes true after first status event
  bool _hasMarkedRead = false;
  // Track pending local messages (localId -> timeout timer) so we can fallback
  // to REST if socket ack isn't received in time.
  final Map<String, Timer> _pendingAcks = {};
  // Map localId to message text for best-effort matching when server returns
  // the persisted message without echoing our client id.
  final Map<String, String> _pendingLocalText = {};
  StreamSubscription<Map<String, dynamic>>? _newMessageSub;
  StreamSubscription<Map<String, dynamic>>? _userTypingSub;
  StreamSubscription<Map<String, dynamic>>? _userStatusSub;
  StreamSubscription<Map<String, dynamic>>? _messageReadSub;
  final ScrollController _scrollController = ScrollController();
  // ack/error subscriptions for outgoing messages
  StreamSubscription<Map<String, dynamic>>? _messageSentSub;
  StreamSubscription<Map<String, dynamic>>? _messageErrorSub;
  static const List<String> _emojis = [
    '','','','','','','','','','','','','','','','','','','',''
  ];

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  void initState() {
    super.initState();
    // Resolve current user id
    _myId = widget.currentUserId;
    _resolveCurrentUserId();
    // Prime UI from cache to avoid loader flicker
    _primeFromCache();
    _controller.addListener(_handleTyping);
    
    // Attach listener BEFORE subscribing to avoid missing the initial status push
    _userStatusSub = SocketService().onUserStatusChanged.listen((event) {
      final Map<String, dynamic> payload =
          (event['user'] is Map<String, dynamic>)
              ? Map<String, dynamic>.from(event['user'] as Map)
              : (event['data'] is Map<String, dynamic>)
                  ? Map<String, dynamic>.from(event['data'] as Map)
                  : event;
      final userId = payload['user_id']?.toString() ?? payload['userId']?.toString() ?? payload['id']?.toString();
      if (userId != widget.peerId) return;
      DateTime? lastSeen;
      final ls = payload['last_seen'] ?? payload['lastSeen'] ?? payload['last_active'] ?? payload['lastActive'];
      if (ls is String) {
        try { lastSeen = DateTime.parse(ls); } catch (_) {}
      } else if (ls is int) {
        try {
          lastSeen = (ls > 1000000000000)
              ? DateTime.fromMillisecondsSinceEpoch(ls)
              : DateTime.fromMillisecondsSinceEpoch(ls * 1000);
        } catch (_) {}
      }
      bool? explicitOnline;
      final ioVal = payload['is_online'] ?? payload['online'] ?? payload['isOnline'];
      if (ioVal is bool) {
        explicitOnline = ioVal;
      } else if (ioVal is String) {
        if (ioVal.toLowerCase() == 'true' || ioVal == '1') explicitOnline = true;
        if (ioVal.toLowerCase() == 'false' || ioVal == '0') explicitOnline = false;
      } else if (ioVal is num) {
        explicitOnline = ioVal != 0;
      }
      bool online;
      if (explicitOnline != null) {
        online = explicitOnline;
      } else {
        if (lastSeen != null) {
          final seconds = DateTime.now().difference(lastSeen).inSeconds;
          online = seconds <= 60;
        } else {
          online = false;
        }
      }
      if (mounted) {
        setState(() {
          _explicitOnline = explicitOnline;
          _peerOnline = online;
          if (lastSeen != null) _peerLastSeen = lastSeen;
          _presenceInitialized = true;
        });
      }
    });
    
  // Connect socket and subscribe immediately (SocketService will queue if not connected)
  // Increase fallback timeout so we don't prematurely mark users offline on slow connections
  _ensureSocketAndSubscribe();
    _presenceTicker = Timer.periodic(const Duration(seconds: 15), (timer) {
      if (!mounted) return;
      bool newOnline;
      if (_explicitOnline != null) {
        newOnline = _explicitOnline!;
      } else {
        if (_peerLastSeen != null) {
          final seconds = DateTime.now().difference(_peerLastSeen!).inSeconds;
          newOnline = seconds <= 60;
        } else {
          newOnline = false;
        }
      }
      if (newOnline != _peerOnline) {
        setState(() => _peerOnline = newOnline);
      } else {
        setState(() {});
      }
    });
    // ...other initialization logic (message listeners, etc.)...
  _loadFirstPage();

    // Listen for message_read events to update local state
    _messageReadSub = SocketService().onMessageRead.listen((event) {
      final id = event['message_id']?.toString() ?? event['id']?.toString() ?? event['messageId']?.toString();
      if (id == null) return;
      final idx = _messageIds.indexOf(id);
      if (idx >= 0 && idx < _messages.length) {
        final m = _messages[idx];
        if (!m.read) {
          setState(() {
            _messages[idx] = Message(
              fromId: m.fromId,
              toId: m.toId,
              text: m.text,
              timestamp: m.timestamp,
              read: true,
            );
          });
          _saveToCache();
        }
      }
    });

    // Listen for user_typing events to toggle typing indicator
    _userTypingSub = SocketService().onUserTyping.listen((event) {
      try {
        final uid = event['user_id']?.toString() ?? event['userId']?.toString() ?? event['id']?.toString();
        if (uid != widget.peerId) return;
        final raw = event['is_typing'] ?? event['typing'] ?? event['isTyping'];
        bool? isTyping;
        if (raw is bool) {
          isTyping = raw;
        } else if (raw is String) {
          final s = raw.toLowerCase();
          if (s == 'true' || s == '1' || s == 'yes') isTyping = true;
          if (s == 'false' || s == '0' || s == 'no') isTyping = false;
        } else if (raw is num) {
          isTyping = raw != 0;
        }
        if (isTyping == null) return;
        if (!mounted) return;
        setState(() => _peerTyping = isTyping!);
        // Auto-reset typing indicator after a short idle period if server doesn't send stop
        _peerTypingAutoResetTimer?.cancel();
        if (isTyping == true) {
          _peerTypingAutoResetTimer = Timer(const Duration(seconds: 5), () {
            if (!mounted) return;
            setState(() => _peerTyping = false);
          });
        }
      } catch (_) {}
    });

    // Listen for new incoming messages and update UI in real-time
    _newMessageSub = SocketService().onNewMessage.listen((event) {
      try {
        final fromId = (event['fromId'] ?? event['from_id'] ?? event['sender_id'] ?? event['senderId'] ?? event['from'])?.toString() ?? '';
        final toId   = (event['toId']   ?? event['to_id']   ?? event['receiver_id'] ?? event['receiverId'] ?? event['to'])?.toString() ?? '';
        // Only handle messages for this conversation where peer -> me (incoming)
        final isIncomingForThisChat = fromId == widget.peerId && toId == _myId;

        if (!isIncomingForThisChat) return;

        final id = (event['id'] ?? event['message_id'] ?? event['messageId'] ?? event['_id'])?.toString() ?? '';
        if (id.isNotEmpty && _messageIds.contains(id)) {

          return; // avoid duplicates
        }

        final text = (event['text'] ?? event['content'] ?? event['message'] ?? event['body'])?.toString() ?? '';
        final tsRaw = event['timestamp'] ?? event['created_at'] ?? event['createdAt'] ?? event['sent_at'] ?? event['updated_at'];
        DateTime ts;
        try {
          if (tsRaw is String) {
            ts = DateTime.parse(tsRaw);
          } else if (tsRaw is int) {
            ts = tsRaw > 1000000000000
                ? DateTime.fromMillisecondsSinceEpoch(tsRaw)
                : DateTime.fromMillisecondsSinceEpoch(tsRaw * 1000);
          } else if (tsRaw is num) {
            final iv = tsRaw.toInt();
            ts = iv > 1000000000000
                ? DateTime.fromMillisecondsSinceEpoch(iv)
                : DateTime.fromMillisecondsSinceEpoch(iv * 1000);
          } else {
            ts = DateTime.now();
          }
        } catch (_) {
          ts = DateTime.now();
        }

        final msg = Message(
          fromId: fromId,
          toId: toId,
          text: text,
          timestamp: ts,
          read: true, // Mark as read immediately since user is viewing this chat
        );
        if (!mounted) return;
        setState(() {
          _messages.add(msg);
          _messageIds.add(id);
        });

        _saveToCache();
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());

        // Immediately mark as read since user is viewing this conversation
        if (id.isNotEmpty) {
          SocketService().markAsRead(messageId: id);
        }
      } catch (_) {}
    });

    // Listen for message_sent acknowledgements so we can reconcile optimistic UI
    _messageSentSub = SocketService().onMessageSent.listen((event) {
      try {
        // event may be {"success":true,"message":{...}} or plain message
    final payload = (event['message'] is Map)
      ? Map<String, dynamic>.from(event['message'] as Map)
      : (event['data'] is Map
        ? Map<String, dynamic>.from(event['data'] as Map)
        : Map<String, dynamic>.from(event));
    final serverMsg = payload;
        final serverId = (serverMsg['id'] ?? serverMsg['message_id'] ?? serverMsg['messageId'] ?? serverMsg['_id'])?.toString() ?? '';
        final serverText = (serverMsg['content'] ?? serverMsg['text'] ?? serverMsg['message'] ?? serverMsg['body'])?.toString() ?? '';
        final senderId = (serverMsg['sender_id'] ?? serverMsg['from_id'] ?? serverMsg['from'])?.toString() ?? '';
        final receiverId = (serverMsg['receiver_id'] ?? serverMsg['to_id'] ?? serverMsg['to'])?.toString() ?? '';

        // Only handle acknowledgements for messages we sent in this chat
        if (senderId.isNotEmpty && senderId != _myId) return;
        if (receiverId.isNotEmpty && receiverId != widget.peerId) return;

        // Try to match by local pending texts first
        String matchedLocalId = '';
        for (final lid in _pendingLocalText.keys) {
          final txt = _pendingLocalText[lid];
          if (txt != null && txt == serverText) {
            matchedLocalId = lid;
            break;
          }
        }

        int matchIdx = -1;
        if (matchedLocalId.isNotEmpty) {
          matchIdx = _messageIds.indexOf(matchedLocalId);
        }
        // fallback: try to find first placeholder (empty id) matching text and sender
        if (matchIdx < 0 && serverText.isNotEmpty) {
          for (var i = _messageIds.length - 1; i >= 0; i--) {
            if ((_messageIds[i] == '' || _messageIds[i].startsWith('local-')) && _messages[i].text == serverText && _messages[i].fromId == _myId) {
              matchIdx = i;
              break;
            }
          }
        }

        if (matchIdx >= 0) {
          // Replace placeholder id with server id and update message timestamp/read if provided
          final existing = _messages[matchIdx];
          DateTime ts = existing.timestamp;
          final tsRaw = serverMsg['created_at'] ?? serverMsg['timestamp'] ?? serverMsg['sent_at'] ?? serverMsg['createdAt'];
          if (tsRaw is String) {
            try { ts = DateTime.parse(tsRaw); } catch (_) {}
          } else if (tsRaw is int) {
            try { ts = tsRaw > 1000000000000 ? DateTime.fromMillisecondsSinceEpoch(tsRaw) : DateTime.fromMillisecondsSinceEpoch(tsRaw * 1000); } catch (_) {}
          }
          final read = (serverMsg['is_read'] ?? serverMsg['read'] ?? serverMsg['seen']) == true;
          setState(() {
            _messages[matchIdx] = Message(
              fromId: existing.fromId,
              toId: existing.toId,
              text: serverText.isNotEmpty ? serverText : existing.text,
              timestamp: ts,
              read: read,
            );
            _messageIds[matchIdx] = serverId.isNotEmpty ? serverId : _messageIds[matchIdx];
          });
          _saveToCache();
        }

        // Clear any pending ack timer for matched local id
        if (matchedLocalId.isNotEmpty) {
          _pendingAcks[matchedLocalId]?.cancel();
          _pendingAcks.remove(matchedLocalId);
          _pendingLocalText.remove(matchedLocalId);
        }
      } catch (_) {}
    });

    // Listen for message_error to mark message as failed
    _messageErrorSub = SocketService().onMessageError.listen((event) {
      try {
        // Mark any pending messages as failed and clean up
        for (final lid in List<String>.from(_pendingLocalText.keys)) {
          _pendingAcks[lid]?.cancel();
          _pendingAcks.remove(lid);
          _pendingLocalText.remove(lid);
        }
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to send message'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } catch (_) {}
    });
  }

  void _handleTyping() {
    // Emit typing signals with debounce: send typing_start on first activity,
    // and typing_stop 2s after the last keystroke.
    try {
      if (!_typingStartedSent) {
        _typingStartedSent = true;
        SocketService().typingStart(toUserId: widget.peerId);
      }
      _typingResetTimer?.cancel();
      _typingResetTimer = Timer(const Duration(seconds: 2), () {
        _typingStartedSent = false;
        SocketService().typingStop(toUserId: widget.peerId);
      });
    } catch (_) {}
  }

  Future<void> _openEmojiPicker() async {
    _focusNode.unfocus();
    final emoji = await showModalBottomSheet<String>(
      context: context,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(12))),
      builder: (ctx) {
        return Padding(
          padding: const EdgeInsets.all(12.0),
          child: GridView.count(
            shrinkWrap: true,
            crossAxisCount: 6,
            mainAxisSpacing: 8,
            crossAxisSpacing: 8,
            children: _emojis.map((e) => GestureDetector(
              onTap: () => Navigator.of(ctx).pop(e),
              child: Center(child: Text(e, style: const TextStyle(fontSize: 24))),
            )).toList(),
          ),
        );
      }
    );
    if (emoji != null) {
      final sel = _controller.selection;
      final newText = sel.isValid
          ? _controller.text.replaceRange(sel.start, sel.end, emoji)
          : (_controller.text + emoji);
      setState(() {
        _controller.text = newText;
        final pos = (sel.isValid ? sel.start : _controller.text.length) + emoji.length;
        _controller.selection = TextSelection.collapsed(offset: pos.toInt());
      });
      FocusScope.of(context).requestFocus(_focusNode);
    }
  }

  // Fetch first page of messages for this conversation
  Future<void> _loadFirstPage() async {
    setState(() => _loadingMessages = true);
    try {
      // Snapshot current messages to merge later (handles real-time arrivals during load)
      final prevMessages = List<Message>.from(_messages);
      final prevIds = List<String>.from(_messageIds);

      final res = await MessageService().getMessages(
        userId: widget.peerId,
        page: 1,
        limit: 50,
      );
      final items = (res['items'] as List?)?.cast<Map<String, dynamic>>() ?? const <Map<String, dynamic>>[];
      final msgs = <Message>[];
      final ids = <String>[];
      for (final it in items) {
        final mid = _extractMessageId(it);
        ids.add(mid);
        msgs.add(_mapToMessage(it));
      }
      // Ensure chronological order (oldest first)
      msgs.sort((a, b) => a.timestamp.compareTo(b.timestamp));
      // Merge: append any messages that were added while loading (not present by id)
      for (var i = 0; i < prevMessages.length; i++) {
        final pm = prevMessages[i];
        final pid = i < prevIds.length ? prevIds[i] : '';
        final dedupeId = pid.isNotEmpty ? pid : null;
        final already = dedupeId != null ? ids.contains(dedupeId) : false;
        if (!already) {
          msgs.add(pm);
          ids.add(pid);
        }
      }
      // Re-sort after merge
      final paired = List.generate(msgs.length, (i) => MapEntry(ids[i], msgs[i]));
      paired.sort((a, b) => a.value.timestamp.compareTo(b.value.timestamp));
      final mergedIds = <String>[];
      final mergedMsgs = <Message>[];
      for (final e in paired) {
        // keep first occurrence of each non-empty id; allow empty ids (local placeholders)
        if (e.key.isNotEmpty) {
          if (mergedIds.contains(e.key)) continue;
        }
        mergedIds.add(e.key);
        mergedMsgs.add(e.value);
      }
      if (!mounted) return;
      setState(() {
        _messages = mergedMsgs;
        _messageIds
          ..clear()
          ..addAll(mergedIds);
        _loadingMessages = false;
      });
      _saveToCache();
      WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());

  // Mark all peer->me messages as read (await so callers can rely on server state)
  await _markAllFromPeerAsRead();
    } catch (e) {
      debugPrint('ChatScreen: load messages error -> $e');
      if (mounted) setState(() => _loadingMessages = false);
    }
  }

  // Emit mark_as_read for any messages from peer to current user that are not yet marked read
  // Returns when all REST calls (if any) have completed so callers can rely on server state
  Future<void> _markAllFromPeerAsRead() async {
    if (_messages.isEmpty) return;
    final futures = <Future>[];
    try {
      bool hasUpdates = false;
      for (var i = 0; i < _messages.length; i++) {
        final m = _messages[i];
        if (!m.read && m.toId == _myId) {
          final id = (i < _messageIds.length) ? _messageIds[i] : '';
          if (id.isNotEmpty) {
            // Optimistic UI update: mark as read immediately
            _messages[i] = Message(
              fromId: m.fromId,
              toId: m.toId,
              text: m.text,
              read: true, // Mark as read optimistically
              timestamp: m.timestamp,
            );
            hasUpdates = true;
            // Emit socket event for real-time update (fire-and-forget)
            try { SocketService().markAsRead(messageId: id); } catch (_) {}
            // Also call REST API to persist read status on server and collect future
            futures.add(MessageService().markMessageAsRead(messageId: id).catchError((e) {
              debugPrint('ChatScreen: markMessageAsRead REST call failed -> $e');
              return <String, dynamic>{};
            }));
          }
        }
      }
      if (hasUpdates) {
        setState(() {}); // Trigger UI update for optimistic changes
      }
      if (futures.isNotEmpty) {
        _hasMarkedRead = true;
        await Future.wait(futures);
      }
    } catch (e) {
      debugPrint('ChatScreen: _markAllFromPeerAsRead error -> $e');
    }
  }

  // Map raw API item to Message model with tolerant key parsing
  Message _mapToMessage(Map<String, dynamic> j) {
    String str(dynamic v) => v?.toString() ?? '';
    bool boolish(dynamic v) {
      if (v is bool) return v;
      if (v is num) return v != 0;
      if (v is String) {
        final s = v.toLowerCase();
        return s == 'true' || s == '1' || s == 'yes';
      }
      return false;
    }
    DateTime parseTs(dynamic v) {
      if (v is String) {
        try { return DateTime.parse(v); } catch (_) {}
      } else if (v is int) {
        try {
          final dt = v > 1000000000000
              ? DateTime.fromMillisecondsSinceEpoch(v)
              : DateTime.fromMillisecondsSinceEpoch(v * 1000);
          return dt.toLocal();
        } catch (_) {}
      } else if (v is num) {
        final iv = v.toInt();
        try {
          final dt = iv > 1000000000000
              ? DateTime.fromMillisecondsSinceEpoch(iv)
              : DateTime.fromMillisecondsSinceEpoch(iv * 1000);
          return dt.toLocal();
        } catch (_) {}
      }
      try {
        return DateTime.parse(v.toString()).toLocal();
      } catch (_) {
        return DateTime.now().toLocal();
      }
    }

    final fromId = str(j['fromId'] ?? j['from_id'] ?? j['senderId'] ?? j['sender_id'] ?? j['from']);
    final toId   = str(j['toId']   ?? j['to_id']   ?? j['receiverId'] ?? j['receiver_id'] ?? j['to']);
    final text   = str(j['text']   ?? j['content'] ?? j['message'] ?? j['body']);
    final read   = boolish(j['read'] ?? j['is_read'] ?? j['seen']);
    final tsRaw  = j['timestamp'] ?? j['created_at'] ?? j['createdAt'] ?? j['sent_at'] ?? j['updated_at'];

    return Message(
      fromId: fromId,
      toId: toId,
      text: text,
      read: read,
      timestamp: parseTs(tsRaw),
    );
  }

  // Extract a server message ID from common key names
  String _extractMessageId(Map<String, dynamic> j) {
    final v = j['id'] ?? j['message_id'] ?? j['messageId'] ?? j['_id'];
    return v?.toString() ?? '';
  }

  // Cache helpers
  void _primeFromCache() {
    final cached = _cache[_cacheKey];
    if (cached != null && cached.messages.isNotEmpty) {
      setState(() {
        _messages = List<Message>.from(cached.messages);
        _messageIds
          ..clear()
          ..addAll(cached.ids);
        _loadingMessages = false;
      });
      WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
    }
  }

  void _saveToCache() {
    _cache[_cacheKey] = _ChatCache(
      List<Message>.from(_messages),
      List<String>.from(_messageIds),
      DateTime.now(),
    );
  }

  String _lastSeenString(DateTime dt) {
    final now = DateTime.now();
    final localDt = dt.toLocal();
    final diff = now.difference(localDt);
    if (diff.inSeconds < 60) return 'just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes} min ago';
    if (diff.inHours < 24) return '${diff.inHours} hr${diff.inHours > 1 ? 's' : ''} ago';
    return _formatDate(dt);
  }

  String _formatTime(DateTime dt) {
    final local = dt.toLocal();
    final hour = local.hour % 12 == 0 ? 12 : local.hour % 12;
    final ampm = local.hour >= 12 ? 'PM' : 'AM';
    return '${hour.toString().padLeft(2, '0')}:${local.minute.toString().padLeft(2, '0')} $ampm';
  }

  String _formatDate(DateTime dt) {
    final local = dt.toLocal();
    return '${local.day.toString().padLeft(2, '0')} ${_monthName(local.month)} ${local.year}';
  }

  String _monthName(int m) {
    const months = [
      '', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return months[m];
  }

  // Resolve the authenticated user's actual id from profile to avoid using placeholder 'me'
  Future<void> _resolveCurrentUserId() async {
    try {
      // First try cached profile
      final cached = AuthService().getCachedProfile();
      if (cached != null) {
        final id = (cached['id'] ?? cached['user_id'] ?? cached['userId'])?.toString();
        if (id != null && id.isNotEmpty && id != _myId) {
          setState(() => _myId = id);
        }
        return;
      }
      // Fallback to network
      final profile = await AuthService().getProfile();
      final id = (profile['id'] ?? profile['user_id'] ?? profile['userId'])?.toString();
      if (id != null && id.isNotEmpty && id != _myId) {
        if (!mounted) return;
        setState(() => _myId = id);
      }
    } catch (_) {
      // keep widget.currentUserId fallback
    }
  }

  // Ensure socket is connected before subscribing to presence
  Future<void> _ensureSocketAndSubscribe() async {
    try {
      await SocketService().connect();
      // Subscribe immediately; SocketService will queue the subscription if the socket
      // is not yet connected and will re-subscribe on connect.
      if (!mounted) return;
      SocketService().subscribeUserStatus(widget.peerId);
      SocketService().requestUserStatus(widget.peerId);

      // Try a fast REST fallback: fetch the peer profile immediately to get their
      // current online/last_seen state while we wait for the server to push
      // a presence event over the socket. This avoids showing "Offline" on the
      // first attempt when the socket or server takes a moment to respond.
      try {
        final profile = await AuthService().getUserById(widget.peerId, forceRefresh: true);
        DateTime? lastSeen;
        final ls = profile['last_seen'] ?? profile['lastSeen'] ?? profile['last_active'] ?? profile['lastActive'];
        if (ls is String) {
          try {
            lastSeen = DateTime.parse(ls);
          } catch (_) {}
        } else if (ls is int) {
          try {
            lastSeen = (ls > 1000000000000)
                ? DateTime.fromMillisecondsSinceEpoch(ls)
                : DateTime.fromMillisecondsSinceEpoch(ls * 1000);
          } catch (_) {}
        }

        bool? explicitOnline;
        final ioVal = profile['is_online'] ?? profile['online'] ?? profile['isOnline'];
        if (ioVal is bool) {
          explicitOnline = ioVal;
        } else if (ioVal is String) {
          if (ioVal.toLowerCase() == 'true' || ioVal == '1') explicitOnline = true;
          if (ioVal.toLowerCase() == 'false' || ioVal == '0') explicitOnline = false;
        } else if (ioVal is num) {
          explicitOnline = ioVal != 0;
        }

        bool online;
        if (explicitOnline != null) {
          online = explicitOnline;
        } else {
          if (lastSeen != null) {
            final seconds = DateTime.now().difference(lastSeen).inSeconds;
            online = seconds <= 60;
          } else {
            online = false;
          }
        }

        // Only apply this REST-derived state if we haven't yet received any
        // presence update from the socket (avoid overwriting newer socket data).
        if (!mounted) return;
        if (!_presenceInitialized) {
          setState(() {
            _explicitOnline = explicitOnline;
            _peerOnline = online;
            if (lastSeen != null) _peerLastSeen = lastSeen;
            _presenceInitialized = true; // treat REST result as initial presence
          });
        }
      } catch (_) {
        // ignore REST fallback errors and let the socket fallback run below
      }

      // Set a more generous fallback timeout: if we still don't receive a presence event
      // after 8 seconds, mark offline. This helps on slow networks or when the server
      // takes longer to emit the current status. We won't clobber a REST-derived state
      // because _presenceInitialized will already be true in that case.
      Future.delayed(const Duration(seconds: 8), () {
        if (!mounted || _presenceInitialized) return;
        setState(() {
          _peerOnline = false;
          _presenceInitialized = true;
        });
      });
    } catch (_) {
      // Connection failed; show offline
      if (mounted) {
        setState(() {
          _peerOnline = false;
          _presenceInitialized = true;
        });
      }
    }
  }

  Future<void> _showReportDialog() async {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Report User'),
        content: const Text('Are you sure you want to report this user?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () async {
              Navigator.of(ctx).pop();
              
              // Show loading indicator
              showDialog(
                context: context,
                barrierDismissible: false,
                builder: (loadCtx) => const AlertDialog(
                  content: SizedBox(
                    height: 50,
                    child: Center(child: CircularProgressIndicator()),
                  ),
                ),
              );
              
              try {
                await AuthService().reportUser(widget.peerId);
                
                if (!mounted) return;
                Navigator.of(context).pop(); // Close loading dialog
                
                customSnackBar('Success', 'User reported successfully');
              } catch (e) {
                if (!mounted) return;
                Navigator.of(context).pop(); // Close loading dialog
                
                final errorMsg = e.toString();
                customSnackBar('Error', errorMsg.contains('ApiException:') 
                  ? errorMsg.replaceFirst('ApiException: ', '') 
                  : 'Failed to report user');
              }
            },
            child: const Text('Report', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );
  }

  Future<void> _send() async {
    final text = _controller.text.trim();
    if (text.isEmpty || _sending) return;
    
    // Check if socket is connected
    if (!SocketService().isConnected) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Unable to send message. Please check your connection.'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }
    
    // Optimistic update: show message instantly
    final msg = Message(
      fromId: _myId,
      toId: widget.peerId,
      text: text,
      timestamp: DateTime.now(),
    );
    // Create a local id so we can match server acks to this optimistic message
    final localId = 'local-${DateTime.now().millisecondsSinceEpoch}';
    setState(() {
      _messages.add(msg);
      _messageIds.add(localId); // placeholder until server id known
      _pendingLocalText[localId] = text;
      // Always keep messages sorted chronologically
      final paired = List.generate(_messages.length, (i) => MapEntry(_messageIds[i], _messages[i]));
      paired.sort((a, b) => a.value.timestamp.compareTo(b.value.timestamp));
      _messages = paired.map((e) => e.value).toList();
      _messageIds
        ..clear()
        ..addAll(paired.map((e) => e.key));
      _controller.clear();
      _sending = false;
    });
    _saveToCache();
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
    
    // Send to server in background (no await blocking UI)
    setState(() => _sending = true);
    try {
      // Send via socket only
      SocketService().sendMessage(toUserId: widget.peerId, content: text, messageId: localId);
      // Start ack timeout - mark as failed if no ack received
      final t = Timer(const Duration(seconds: 8), () {
        // If still pending, mark as failed
        if (_pendingLocalText.containsKey(localId)) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Message failed to send'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
        _pendingAcks[localId]?.cancel();
        _pendingAcks.remove(localId);
        _pendingLocalText.remove(localId);
      });
      _pendingAcks[localId] = t;
      if (mounted) setState(() => _sending = false);
    } catch (e) {
      debugPrint('ChatScreen: sendMessage error -> $e');
      if (mounted) setState(() => _sending = false);
      // Message already shown; could add retry logic or error indicator here
    }
  }

  @override
  void dispose() {
    _controller.removeListener(_handleTyping);
    _controller.dispose();
    _focusNode.dispose();
    _typingResetTimer?.cancel();
  _peerTypingAutoResetTimer?.cancel();
    _newMessageSub?.cancel();
    _messageSentSub?.cancel();
    _messageErrorSub?.cancel();
    _userTypingSub?.cancel();
    _userStatusSub?.cancel();
    _messageReadSub?.cancel();
    // Cancel any pending ack timers
    for (final t in _pendingAcks.values) {
      t.cancel();
    }
    _pendingAcks.clear();
    _pendingLocalText.clear();
    // Unsubscribe from presence updates
    SocketService().unsubscribeUserStatus(widget.peerId);
    _presenceTicker?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final showLoading = _loadingMessages && _messages.isEmpty;

    return WillPopScope(
      onWillPop: () async {
        // Ensure callers (ChatsListScreen) know whether we marked messages read
        Navigator.of(context).pop({'markedRead': _hasMarkedRead});
        return false; // we've popped manually
      },
      child: Scaffold(
        backgroundColor: const Color(0xFFFFFBF0),
        appBar: PreferredSize(
          preferredSize: const Size.fromHeight(65),
          child: AppBar(
            backgroundColor: Colors.transparent,
            elevation: 0,
            centerTitle: true,
            automaticallyImplyLeading: false,
            // Rounded frosted AppBar to match other screens
            shape: const RoundedRectangleBorder(
              borderRadius: BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
            ),
            flexibleSpace: ClipRRect(
              borderRadius: const BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
              child: BackdropFilter(
                filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
                child: Container(
                  decoration: const BoxDecoration(
                    gradient: LinearGradient(
                      colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      stops: [0.0, 0.5, 1.0],
                    ),
                  ),
                ),
              ),
            ),
            leading: IconButton(
              icon: const Icon(Icons.arrow_back, color: Colors.white),
              onPressed: () => Navigator.of(context).pop({'markedRead': _hasMarkedRead}),
            ),
            title: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Text(widget.peerName, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
                Padding(
                  padding: const EdgeInsets.only(top: 6.0),
                  child: Text(
                    _peerTyping
                        ? '${widget.peerName} is typing...'
                        : (!_presenceInitialized
                            ? 'Checking status'
                            : (_peerOnline
                                ? 'Online'
                                : (_peerLastSeen != null
                                    ? 'Last seen ${_lastSeenString(_peerLastSeen!)}'
                                    : 'Offline'))),
                    style: TextStyle(
                      color: _peerTyping ? Colors.white : Colors.white70,
                      fontStyle: FontStyle.italic,
                      fontSize: _peerTyping ? 14 : 12,
                    ),
                  ),
                ),
              ],
            ),
            actions: [
              PopupMenuButton(
                itemBuilder: (context) => [
                  PopupMenuItem(
                    child: Row(
                      children: const [
                        Icon(Icons.flag_outlined, color: Colors.red),
                        SizedBox(width: 8),
                        Text('Report User'),
                      ],
                    ),
                    onTap: () => _showReportDialog(),
                  ),
                ],
                icon: const Icon(Icons.more_vert, color: Colors.white),
              ),
            ],
            iconTheme: const IconThemeData(color: Colors.white),
          ),
        ),
        body: showLoading
            ? const Center(child: CircularProgressIndicator())
            : Column(
                children: [
                  Expanded(
                    child: ListView.builder(
                      controller: _scrollController,
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                      reverse: false,
                      itemCount: _messages.length,
                      itemBuilder: (context, i) {
                        final m = _messages[i];
                        final mine = m.fromId == _myId;
                        final showDateHeader = i == 0 || m.timestamp.day != _messages[i - 1].timestamp.day || m.timestamp.month != _messages[i - 1].timestamp.month || m.timestamp.year != _messages[i - 1].timestamp.year;
                        return Column(
                          crossAxisAlignment: mine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                          children: [
                            if (showDateHeader)
                              Padding(
                                padding: const EdgeInsets.symmetric(vertical: 12.0),
                                child: Center(
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                                    decoration: BoxDecoration(
                                      gradient: LinearGradient(
                                        colors: [
                                          const Color(0xFFFFF59D).withOpacity(0.3),
                                          const Color(0xFFE53935).withOpacity(0.2),
                                          const Color(0xFFFFF59D).withOpacity(0.3),
                                        ],
                                        begin: Alignment.topLeft,
                                        end: Alignment.bottomRight,
                                      ),
                                      borderRadius: BorderRadius.circular(16),
                                      boxShadow: [
                                        BoxShadow(
                                          color: const Color(0xFFE53935).withOpacity(0.1),
                                          blurRadius: 8,
                                          offset: const Offset(0, 2),
                                        ),
                                      ],
                                    ),
                                    child: Text(
                                      _formatDate(m.timestamp),
                                      style: const TextStyle(
                                        color: Color(0xFFE53935),
                                        fontSize: 12,
                                        fontWeight: FontWeight.w700,
                                        letterSpacing: 0.5,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            Container(
                              margin: EdgeInsets.only(top: 4, bottom: 4, left: mine ? 60 : 0, right: mine ? 0 : 60),
                              alignment: mine ? Alignment.centerRight : Alignment.centerLeft,
                              child: Column(
                                crossAxisAlignment: mine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                                children: [
                                  Container(
                                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                                    decoration: BoxDecoration(
                                      gradient: mine
                                          ? const LinearGradient(
                                              colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            )
                                          : null,
                                      color: mine ? null : Colors.white,
                                      borderRadius: BorderRadius.only(
                                        topLeft: const Radius.circular(20),
                                        topRight: const Radius.circular(20),
                                        bottomLeft: Radius.circular(mine ? 20 : 4),
                                        bottomRight: Radius.circular(mine ? 4 : 20),
                                      ),
                                      boxShadow: [
                                        BoxShadow(
                                          color: mine
                                              ? const Color(0xFFE53935).withOpacity(0.3)
                                              : Colors.black.withOpacity(0.08),
                                          blurRadius: mine ? 12 : 8,
                                          offset: Offset(0, mine ? 4 : 2),
                                        ),
                                      ],
                                      border: mine
                                          ? null
                                          : Border.all(
                                              color: const Color(0xFFFFF59D).withOpacity(0.3),
                                              width: 1,
                                            ),
                                    ),
                                    constraints: const BoxConstraints(maxWidth: 280),
                                    child: Column(
                                      crossAxisAlignment: mine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          m.text,
                                          style: TextStyle(
                                            color: mine ? Colors.white : Colors.black87,
                                            fontSize: 15,
                                            height: 1.4,
                                          ),
                                        ),
                                        const SizedBox(height: 6),
                                        Row(
                                          mainAxisSize: MainAxisSize.min,
                                          children: [
                                            Text(
                                              _formatTime(m.timestamp),
                                              style: TextStyle(
                                                color: mine ? Colors.white.withOpacity(0.9) : Colors.black45,
                                                fontSize: 11,
                                                fontWeight: FontWeight.w500,
                                              ),
                                            ),
                                            if (mine) ...[
                                              const SizedBox(width: 4),
                                              Icon(
                                                m.read ? Icons.done_all_rounded : Icons.done_rounded,
                                                size: 16,
                                                color: m.read ? const Color(0xFFFFF59D) : Colors.white.withOpacity(0.8),
                                              ),
                                            ],
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        );
                      },
                    ),
                  ),
                  SafeArea(
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.05),
                            blurRadius: 10,
                            offset: const Offset(0, -2),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Container(
                              padding: const EdgeInsets.symmetric(horizontal: 4),
                              decoration: BoxDecoration(
                                color: const Color(0xFFFFFBF0),
                                borderRadius: BorderRadius.circular(24),
                                border: Border.all(
                                  color: const Color(0xFFE53935).withOpacity(0.2),
                                  width: 1.5,
                                ),
                                boxShadow: [
                                  BoxShadow(
                                    color: const Color(0xFFE53935).withOpacity(0.08),
                                    blurRadius: 8,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: Row(
                                children: [
                                  IconButton(
                                    onPressed: () async {
                                      try {
                                        await _openEmojiPicker();
                                      } catch (e) {
                                        debugPrint('ChatScreen: Could not open emoji picker');
                                      }
                                    },
                                    icon: const Icon(Icons.emoji_emotions_outlined, color: Color(0xFFE53935), size: 24),
                                  ),
                                  Expanded(
                                    child: TextField(
                                      controller: _controller,
                                      focusNode: _focusNode,
                                      style: const TextStyle(color: Colors.black87, fontSize: 15),
                                      maxLines: null,
                                      textCapitalization: TextCapitalization.sentences,
                                      decoration: const InputDecoration(
                                        hintText: 'Type a message...',
                                        hintStyle: TextStyle(color: Colors.black38, fontSize: 15),
                                        border: InputBorder.none,
                                        contentPadding: EdgeInsets.symmetric(horizontal: 8, vertical: 10),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                          const SizedBox(width: 10),
                          Container(
                            decoration: BoxDecoration(
                              gradient: const LinearGradient(
                                colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                              ),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: const Color(0xFFE53935).withOpacity(0.4),
                                  blurRadius: 12,
                                  offset: const Offset(0, 4),
                                ),
                              ],
                            ),
                            child: Material(
                              color: Colors.transparent,
                              shape: const CircleBorder(),
                              child: InkWell(
                                onTap: _sending ? null : _send,
                                customBorder: const CircleBorder(),
                                child: Container(
                                  width: 48,
                                  height: 48,
                                  alignment: Alignment.center,
                                  child: Icon(
                                    Icons.send_rounded,
                                    color: _sending ? Colors.white.withOpacity(0.5) : Colors.white,
                                    size: 22,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  )
                ],
              ),
      ),
    );
  }
}
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';

import '../models/message.dart';
import '../services/socket_service.dart';
import '../services/message_service.dart';
import '../services/auth_service.dart';
import '../utils/custom_snackbar.dart';

// Lightweight in-memory cache for chat conversations
class _ChatCache {
  final List<Message> messages;
  final List<String> ids;
  final DateTime updatedAt;
  const _ChatCache(this.messages, this.ids, this.updatedAt);
}

class ChatScreen extends StatefulWidget {
  final String currentUserId;
  final String peerId;
  final String peerName;

  const ChatScreen({Key? key, required this.currentUserId, required this.peerId, required this.peerName}) : super(key: key);

  /// Clear all cached chat messages. Should be called on logout to prevent
  /// data leaks between user sessions.
  static void clearAllCache() {
    _ChatScreenState._cache.clear();
  }

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  // Fields
  late List<Message> _messages = [];
  // Store server-side message IDs corresponding to _messages indices
  final List<String> _messageIds = [];
  // Current user's resolved ID (falls back to widget.currentUserId until resolved)
  late String _myId = '';
  // Static cache shared across ChatScreen instances
  static final Map<String, _ChatCache> _cache = <String, _ChatCache>{};
  String get _cacheKey => '${widget.currentUserId}->${widget.peerId}';
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  bool _sending = false;
  bool _loadingMessages = true;
  bool _peerTyping = false;
  bool _typingStartedSent = false;
  // Debounce for our own typing start/stop emits
  Timer? _typingResetTimer;
  // Auto-clear timer for peer typing indicator
  Timer? _peerTypingAutoResetTimer;
  bool _peerOnline = false;
  DateTime? _peerLastSeen;
  Timer? _presenceTicker;
  bool? _explicitOnline;
  bool _presenceInitialized = false; // becomes true after first status event
  bool _hasMarkedRead = false;
  // Track pending local messages (localId -> timeout timer) so we can fallback
  // to REST if socket ack isn't received in time.
  final Map<String, Timer> _pendingAcks = {};
  // Map localId to message text for best-effort matching when server returns
  // the persisted message without echoing our client id.
  final Map<String, String> _pendingLocalText = {};
  StreamSubscription<Map<String, dynamic>>? _newMessageSub;
  StreamSubscription<Map<String, dynamic>>? _userTypingSub;
  StreamSubscription<Map<String, dynamic>>? _userStatusSub;
  StreamSubscription<Map<String, dynamic>>? _messageReadSub;
  final ScrollController _scrollController = ScrollController();
  // ack/error subscriptions for outgoing messages
  StreamSubscription<Map<String, dynamic>>? _messageSentSub;
  StreamSubscription<Map<String, dynamic>>? _messageErrorSub;
  static const List<String> _emojis = [
    '','','','','','','','','','','','','','','','','','','',''
  ];

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  void initState() {
    super.initState();
    // Resolve current user id
    _myId = widget.currentUserId;
    _resolveCurrentUserId();
    // Prime UI from cache to avoid loader flicker
    _primeFromCache();
    _controller.addListener(_handleTyping);
    
    // Attach listener BEFORE subscribing to avoid missing the initial status push
    _userStatusSub = SocketService().onUserStatusChanged.listen((event) {
      final Map<String, dynamic> payload =
          (event['user'] is Map<String, dynamic>)
              ? Map<String, dynamic>.from(event['user'] as Map)
              : (event['data'] is Map<String, dynamic>)
                  ? Map<String, dynamic>.from(event['data'] as Map)
                  : event;
      final userId = payload['user_id']?.toString() ?? payload['userId']?.toString() ?? payload['id']?.toString();
      if (userId != widget.peerId) return;
      DateTime? lastSeen;
      final ls = payload['last_seen'] ?? payload['lastSeen'] ?? payload['last_active'] ?? payload['lastActive'];
      if (ls is String) {
        try { lastSeen = DateTime.parse(ls); } catch (_) {}
      } else if (ls is int) {
        try {
          lastSeen = (ls > 1000000000000)
              ? DateTime.fromMillisecondsSinceEpoch(ls)
              : DateTime.fromMillisecondsSinceEpoch(ls * 1000);
        } catch (_) {}
      }
      bool? explicitOnline;
      final ioVal = payload['is_online'] ?? payload['online'] ?? payload['isOnline'];
      if (ioVal is bool) {
        explicitOnline = ioVal;
      } else if (ioVal is String) {
        if (ioVal.toLowerCase() == 'true' || ioVal == '1') explicitOnline = true;
        if (ioVal.toLowerCase() == 'false' || ioVal == '0') explicitOnline = false;
      } else if (ioVal is num) {
        explicitOnline = ioVal != 0;
      }
      bool online;
      if (explicitOnline != null) {
        online = explicitOnline;
      } else {
        if (lastSeen != null) {
          final seconds = DateTime.now().difference(lastSeen).inSeconds;
          online = seconds <= 60;
        } else {
          online = false;
        }
      }
      if (mounted) {
        setState(() {
          _explicitOnline = explicitOnline;
          _peerOnline = online;
          if (lastSeen != null) _peerLastSeen = lastSeen;
          _presenceInitialized = true;
        });
      }
    });
    
  // Connect socket and subscribe immediately (SocketService will queue if not connected)
  // Increase fallback timeout so we don't prematurely mark users offline on slow connections
  _ensureSocketAndSubscribe();
    _presenceTicker = Timer.periodic(const Duration(seconds: 15), (timer) {
      if (!mounted) return;
      bool newOnline;
      if (_explicitOnline != null) {
        newOnline = _explicitOnline!;
      } else {
        if (_peerLastSeen != null) {
          final seconds = DateTime.now().difference(_peerLastSeen!).inSeconds;
          newOnline = seconds <= 60;
        } else {
          newOnline = false;
        }
      }
      if (newOnline != _peerOnline) {
        setState(() => _peerOnline = newOnline);
      } else {
        setState(() {});
      }
    });
    // ...other initialization logic (message listeners, etc.)...
  _loadFirstPage();

    // Listen for message_read events to update local state
    _messageReadSub = SocketService().onMessageRead.listen((event) {
      final id = event['message_id']?.toString() ?? event['id']?.toString() ?? event['messageId']?.toString();
      if (id == null) return;
      final idx = _messageIds.indexOf(id);
      if (idx >= 0 && idx < _messages.length) {
        final m = _messages[idx];
        if (!m.read) {
          setState(() {
            _messages[idx] = Message(
              fromId: m.fromId,
              toId: m.toId,
              text: m.text,
              timestamp: m.timestamp,
              read: true,
            );
          });
          _saveToCache();
        }
      }
    });

    // Listen for user_typing events to toggle typing indicator
    _userTypingSub = SocketService().onUserTyping.listen((event) {
      try {
        final uid = event['user_id']?.toString() ?? event['userId']?.toString() ?? event['id']?.toString();
        if (uid != widget.peerId) return;
        final raw = event['is_typing'] ?? event['typing'] ?? event['isTyping'];
        bool? isTyping;
        if (raw is bool) {
          isTyping = raw;
        } else if (raw is String) {
          final s = raw.toLowerCase();
          if (s == 'true' || s == '1' || s == 'yes') isTyping = true;
          if (s == 'false' || s == '0' || s == 'no') isTyping = false;
        } else if (raw is num) {
          isTyping = raw != 0;
        }
        if (isTyping == null) return;
        if (!mounted) return;
        setState(() => _peerTyping = isTyping!);
        // Auto-reset typing indicator after a short idle period if server doesn't send stop
        _peerTypingAutoResetTimer?.cancel();
        if (isTyping == true) {
          _peerTypingAutoResetTimer = Timer(const Duration(seconds: 5), () {
            if (!mounted) return;
            setState(() => _peerTyping = false);
          });
        }
      } catch (_) {}
    });

    // Listen for new incoming messages and update UI in real-time
    _newMessageSub = SocketService().onNewMessage.listen((event) {
      try {
        final fromId = (event['fromId'] ?? event['from_id'] ?? event['sender_id'] ?? event['senderId'] ?? event['from'])?.toString() ?? '';
        final toId   = (event['toId']   ?? event['to_id']   ?? event['receiver_id'] ?? event['receiverId'] ?? event['to'])?.toString() ?? '';
        // Only handle messages for this conversation where peer -> me (incoming)
        final isIncomingForThisChat = fromId == widget.peerId && toId == _myId;

        if (!isIncomingForThisChat) return;

        final id = (event['id'] ?? event['message_id'] ?? event['messageId'] ?? event['_id'])?.toString() ?? '';
        if (id.isNotEmpty && _messageIds.contains(id)) {

          return; // avoid duplicates
        }

        final text = (event['text'] ?? event['content'] ?? event['message'] ?? event['body'])?.toString() ?? '';
        final tsRaw = event['timestamp'] ?? event['created_at'] ?? event['createdAt'] ?? event['sent_at'] ?? event['updated_at'];
        DateTime ts;
        try {
          if (tsRaw is String) {
            ts = DateTime.parse(tsRaw);
          } else if (tsRaw is int) {
            ts = tsRaw > 1000000000000
                ? DateTime.fromMillisecondsSinceEpoch(tsRaw)
                : DateTime.fromMillisecondsSinceEpoch(tsRaw * 1000);
          } else if (tsRaw is num) {
            final iv = tsRaw.toInt();
            ts = iv > 1000000000000
                ? DateTime.fromMillisecondsSinceEpoch(iv)
                : DateTime.fromMillisecondsSinceEpoch(iv * 1000);
          } else {
            ts = DateTime.now();
          }
        } catch (_) {
          ts = DateTime.now();
        }

        final msg = Message(
          fromId: fromId,
          toId: toId,
          text: text,
          timestamp: ts,
          read: true, // Mark as read immediately since user is viewing this chat
        );
        if (!mounted) return;
        setState(() {
          _messages.add(msg);
          _messageIds.add(id);
        });

        _saveToCache();
        WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());

        // Immediately mark as read since user is viewing this conversation
        if (id.isNotEmpty) {
          SocketService().markAsRead(messageId: id);
        }
      } catch (_) {}
    });

    // Listen for message_sent acknowledgements so we can reconcile optimistic UI
    _messageSentSub = SocketService().onMessageSent.listen((event) {
      try {
        // event may be {"success":true,"message":{...}} or plain message
    final payload = (event['message'] is Map)
      ? Map<String, dynamic>.from(event['message'] as Map)
      : (event['data'] is Map
        ? Map<String, dynamic>.from(event['data'] as Map)
        : Map<String, dynamic>.from(event));
    final serverMsg = payload;
        final serverId = (serverMsg['id'] ?? serverMsg['message_id'] ?? serverMsg['messageId'] ?? serverMsg['_id'])?.toString() ?? '';
        final serverText = (serverMsg['content'] ?? serverMsg['text'] ?? serverMsg['message'] ?? serverMsg['body'])?.toString() ?? '';
        final senderId = (serverMsg['sender_id'] ?? serverMsg['from_id'] ?? serverMsg['from'])?.toString() ?? '';
        final receiverId = (serverMsg['receiver_id'] ?? serverMsg['to_id'] ?? serverMsg['to'])?.toString() ?? '';

        // Only handle acknowledgements for messages we sent in this chat
        if (senderId.isNotEmpty && senderId != _myId) return;
        if (receiverId.isNotEmpty && receiverId != widget.peerId) return;

        // Try to match by local pending texts first
        String matchedLocalId = '';
        for (final lid in _pendingLocalText.keys) {
          final txt = _pendingLocalText[lid];
          if (txt != null && txt == serverText) {
            matchedLocalId = lid;
            break;
          }
        }

        int matchIdx = -1;
        if (matchedLocalId.isNotEmpty) {
          matchIdx = _messageIds.indexOf(matchedLocalId);
        }
        // fallback: try to find first placeholder (empty id) matching text and sender
        if (matchIdx < 0 && serverText.isNotEmpty) {
          for (var i = _messageIds.length - 1; i >= 0; i--) {
            if ((_messageIds[i] == '' || _messageIds[i].startsWith('local-')) && _messages[i].text == serverText && _messages[i].fromId == _myId) {
              matchIdx = i;
              break;
            }
          }
        }

        if (matchIdx >= 0) {
          // Replace placeholder id with server id and update message timestamp/read if provided
          final existing = _messages[matchIdx];
          DateTime ts = existing.timestamp;
          final tsRaw = serverMsg['created_at'] ?? serverMsg['timestamp'] ?? serverMsg['sent_at'] ?? serverMsg['createdAt'];
          if (tsRaw is String) {
            try { ts = DateTime.parse(tsRaw); } catch (_) {}
          } else if (tsRaw is int) {
            try { ts = tsRaw > 1000000000000 ? DateTime.fromMillisecondsSinceEpoch(tsRaw) : DateTime.fromMillisecondsSinceEpoch(tsRaw * 1000); } catch (_) {}
          }
          final read = (serverMsg['is_read'] ?? serverMsg['read'] ?? serverMsg['seen']) == true;
          setState(() {
            _messages[matchIdx] = Message(
              fromId: existing.fromId,
              toId: existing.toId,
              text: serverText.isNotEmpty ? serverText : existing.text,
              timestamp: ts,
              read: read,
            );
            _messageIds[matchIdx] = serverId.isNotEmpty ? serverId : _messageIds[matchIdx];
          });
          _saveToCache();
        }

        // Clear any pending ack timer for matched local id
        if (matchedLocalId.isNotEmpty) {
          _pendingAcks[matchedLocalId]?.cancel();
          _pendingAcks.remove(matchedLocalId);
          _pendingLocalText.remove(matchedLocalId);
        }
      } catch (_) {}
    });

    // Listen for message_error to mark message as failed
    _messageErrorSub = SocketService().onMessageError.listen((event) {
      try {
        // Mark any pending messages as failed and clean up
        for (final lid in List<String>.from(_pendingLocalText.keys)) {
          _pendingAcks[lid]?.cancel();
          _pendingAcks.remove(lid);
          _pendingLocalText.remove(lid);
        }
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to send message'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } catch (_) {}
    });
  }

  void _handleTyping() {
    // Emit typing signals with debounce: send typing_start on first activity,
    // and typing_stop 2s after the last keystroke.
    try {
      if (!_typingStartedSent) {
        _typingStartedSent = true;
        SocketService().typingStart(toUserId: widget.peerId);
      }
      _typingResetTimer?.cancel();
      _typingResetTimer = Timer(const Duration(seconds: 2), () {
        _typingStartedSent = false;
        SocketService().typingStop(toUserId: widget.peerId);
      });
    } catch (_) {}
  }

  Future<void> _openEmojiPicker() async {
    _focusNode.unfocus();
    final emoji = await showModalBottomSheet<String>(
      context: context,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(12))),
      builder: (ctx) {
        return Padding(
          padding: const EdgeInsets.all(12.0),
          child: GridView.count(
            shrinkWrap: true,
            crossAxisCount: 6,
            mainAxisSpacing: 8,
            crossAxisSpacing: 8,
            children: _emojis.map((e) => GestureDetector(
              onTap: () => Navigator.of(ctx).pop(e),
              child: Center(child: Text(e, style: const TextStyle(fontSize: 24))),
            )).toList(),
          ),
        );
      }
    );
    if (emoji != null) {
      final sel = _controller.selection;
      final newText = sel.isValid
          ? _controller.text.replaceRange(sel.start, sel.end, emoji)
          : (_controller.text + emoji);
      setState(() {
        _controller.text = newText;
        final pos = (sel.isValid ? sel.start : _controller.text.length) + emoji.length;
        _controller.selection = TextSelection.collapsed(offset: pos.toInt());
      });
      FocusScope.of(context).requestFocus(_focusNode);
    }
  }

  // Fetch first page of messages for this conversation
  Future<void> _loadFirstPage() async {
    setState(() => _loadingMessages = true);
    try {
      // Snapshot current messages to merge later (handles real-time arrivals during load)
      final prevMessages = List<Message>.from(_messages);
      final prevIds = List<String>.from(_messageIds);

      final res = await MessageService().getMessages(
        userId: widget.peerId,
        page: 1,
        limit: 50,
      );
      final items = (res['items'] as List?)?.cast<Map<String, dynamic>>() ?? const <Map<String, dynamic>>[];
      final msgs = <Message>[];
      final ids = <String>[];
      for (final it in items) {
        final mid = _extractMessageId(it);
        ids.add(mid);
        msgs.add(_mapToMessage(it));
      }
      // Ensure chronological order (oldest first)
      msgs.sort((a, b) => a.timestamp.compareTo(b.timestamp));
      // Merge: append any messages that were added while loading (not present by id)
      for (var i = 0; i < prevMessages.length; i++) {
        final pm = prevMessages[i];
        final pid = i < prevIds.length ? prevIds[i] : '';
        final dedupeId = pid.isNotEmpty ? pid : null;
        final already = dedupeId != null ? ids.contains(dedupeId) : false;
        if (!already) {
          msgs.add(pm);
          ids.add(pid);
        }
      }
      // Re-sort after merge
      final paired = List.generate(msgs.length, (i) => MapEntry(ids[i], msgs[i]));
      paired.sort((a, b) => a.value.timestamp.compareTo(b.value.timestamp));
      final mergedIds = <String>[];
      final mergedMsgs = <Message>[];
      for (final e in paired) {
        // keep first occurrence of each non-empty id; allow empty ids (local placeholders)
        if (e.key.isNotEmpty) {
          if (mergedIds.contains(e.key)) continue;
        }
        mergedIds.add(e.key);
        mergedMsgs.add(e.value);
      }
      if (!mounted) return;
      setState(() {
        _messages = mergedMsgs;
        _messageIds
          ..clear()
          ..addAll(mergedIds);
        _loadingMessages = false;
      });
      _saveToCache();
      WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());

  // Mark all peer->me messages as read (await so callers can rely on server state)
  await _markAllFromPeerAsRead();
    } catch (e) {
      debugPrint('ChatScreen: load messages error -> $e');
      if (mounted) setState(() => _loadingMessages = false);
    }
  }

  // Emit mark_as_read for any messages from peer to current user that are not yet marked read
  // Returns when all REST calls (if any) have completed so callers can rely on server state
  Future<void> _markAllFromPeerAsRead() async {
    if (_messages.isEmpty) return;
    final futures = <Future>[];
    try {
      bool hasUpdates = false;
      for (var i = 0; i < _messages.length; i++) {
        final m = _messages[i];
        if (!m.read && m.toId == _myId) {
          final id = (i < _messageIds.length) ? _messageIds[i] : '';
          if (id.isNotEmpty) {
            // Optimistic UI update: mark as read immediately
            _messages[i] = Message(
              fromId: m.fromId,
              toId: m.toId,
              text: m.text,
              read: true, // Mark as read optimistically
              timestamp: m.timestamp,
            );
            hasUpdates = true;
            // Emit socket event for real-time update (fire-and-forget)
            try { SocketService().markAsRead(messageId: id); } catch (_) {}
            // Also call REST API to persist read status on server and collect future
            futures.add(MessageService().markMessageAsRead(messageId: id).catchError((e) {
              debugPrint('ChatScreen: markMessageAsRead REST call failed -> $e');
              return <String, dynamic>{};
            }));
          }
        }
      }
      if (hasUpdates) {
        setState(() {}); // Trigger UI update for optimistic changes
      }
      if (futures.isNotEmpty) {
        _hasMarkedRead = true;
        await Future.wait(futures);
      }
    } catch (e) {
      debugPrint('ChatScreen: _markAllFromPeerAsRead error -> $e');
    }
  }

  // Map raw API item to Message model with tolerant key parsing
  Message _mapToMessage(Map<String, dynamic> j) {
    String str(dynamic v) => v?.toString() ?? '';
    bool boolish(dynamic v) {
      if (v is bool) return v;
      if (v is num) return v != 0;
      if (v is String) {
        final s = v.toLowerCase();
        return s == 'true' || s == '1' || s == 'yes';
      }
      return false;
    }
    DateTime parseTs(dynamic v) {
      if (v is String) {
        try { return DateTime.parse(v); } catch (_) {}
      } else if (v is int) {
        try {
          final dt = v > 1000000000000
              ? DateTime.fromMillisecondsSinceEpoch(v)
              : DateTime.fromMillisecondsSinceEpoch(v * 1000);
          return dt.toLocal();
        } catch (_) {}
      } else if (v is num) {
        final iv = v.toInt();
        try {
          final dt = iv > 1000000000000
              ? DateTime.fromMillisecondsSinceEpoch(iv)
              : DateTime.fromMillisecondsSinceEpoch(iv * 1000);
          return dt.toLocal();
        } catch (_) {}
      }
      try {
        return DateTime.parse(v.toString()).toLocal();
      } catch (_) {
        return DateTime.now().toLocal();
      }
    }

    final fromId = str(j['fromId'] ?? j['from_id'] ?? j['senderId'] ?? j['sender_id'] ?? j['from']);
    final toId   = str(j['toId']   ?? j['to_id']   ?? j['receiverId'] ?? j['receiver_id'] ?? j['to']);
    final text   = str(j['text']   ?? j['content'] ?? j['message'] ?? j['body']);
    final read   = boolish(j['read'] ?? j['is_read'] ?? j['seen']);
    final tsRaw  = j['timestamp'] ?? j['created_at'] ?? j['createdAt'] ?? j['sent_at'] ?? j['updated_at'];

    return Message(
      fromId: fromId,
      toId: toId,
      text: text,
      read: read,
      timestamp: parseTs(tsRaw),
    );
  }

  // Extract a server message ID from common key names
  String _extractMessageId(Map<String, dynamic> j) {
    final v = j['id'] ?? j['message_id'] ?? j['messageId'] ?? j['_id'];
    return v?.toString() ?? '';
  }

  // Cache helpers
  void _primeFromCache() {
    final cached = _cache[_cacheKey];
    if (cached != null && cached.messages.isNotEmpty) {
      setState(() {
        _messages = List<Message>.from(cached.messages);
        _messageIds
          ..clear()
          ..addAll(cached.ids);
        _loadingMessages = false;
      });
      WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
    }
  }

  void _saveToCache() {
    _cache[_cacheKey] = _ChatCache(
      List<Message>.from(_messages),
      List<String>.from(_messageIds),
      DateTime.now(),
    );
  }

  String _lastSeenString(DateTime dt) {
    final now = DateTime.now();
    final localDt = dt.toLocal();
    final diff = now.difference(localDt);
    if (diff.inSeconds < 60) return 'just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes} min ago';
    if (diff.inHours < 24) return '${diff.inHours} hr${diff.inHours > 1 ? 's' : ''} ago';
    return _formatDate(dt);
  }

  String _formatTime(DateTime dt) {
    final local = dt.toLocal();
    final hour = local.hour % 12 == 0 ? 12 : local.hour % 12;
    final ampm = local.hour >= 12 ? 'PM' : 'AM';
    return '${hour.toString().padLeft(2, '0')}:${local.minute.toString().padLeft(2, '0')} $ampm';
  }

  String _formatDate(DateTime dt) {
    final local = dt.toLocal();
    return '${local.day.toString().padLeft(2, '0')} ${_monthName(local.month)} ${local.year}';
  }

  String _monthName(int m) {
    const months = [
      '', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return months[m];
  }

  // Resolve the authenticated user's actual id from profile to avoid using placeholder 'me'
  Future<void> _resolveCurrentUserId() async {
    try {
      // First try cached profile
      final cached = AuthService().getCachedProfile();
      if (cached != null) {
        final id = (cached['id'] ?? cached['user_id'] ?? cached['userId'])?.toString();
        if (id != null && id.isNotEmpty && id != _myId) {
          setState(() => _myId = id);
        }
        return;
      }
      // Fallback to network
      final profile = await AuthService().getProfile();
      final id = (profile['id'] ?? profile['user_id'] ?? profile['userId'])?.toString();
      if (id != null && id.isNotEmpty && id != _myId) {
        if (!mounted) return;
        setState(() => _myId = id);
      }
    } catch (_) {
      // keep widget.currentUserId fallback
    }
  }

  // Ensure socket is connected before subscribing to presence
  Future<void> _ensureSocketAndSubscribe() async {
    try {
      await SocketService().connect();
      // Subscribe immediately; SocketService will queue the subscription if the socket
      // is not yet connected and will re-subscribe on connect.
      if (!mounted) return;
      SocketService().subscribeUserStatus(widget.peerId);
      SocketService().requestUserStatus(widget.peerId);

      // Try a fast REST fallback: fetch the peer profile immediately to get their
      // current online/last_seen state while we wait for the server to push
      // a presence event over the socket. This avoids showing "Offline" on the
      // first attempt when the socket or server takes a moment to respond.
      try {
        final profile = await AuthService().getUserById(widget.peerId, forceRefresh: true);
        DateTime? lastSeen;
        final ls = profile['last_seen'] ?? profile['lastSeen'] ?? profile['last_active'] ?? profile['lastActive'];
        if (ls is String) {
          try {
            lastSeen = DateTime.parse(ls);
          } catch (_) {}
        } else if (ls is int) {
          try {
            lastSeen = (ls > 1000000000000)
                ? DateTime.fromMillisecondsSinceEpoch(ls)
                : DateTime.fromMillisecondsSinceEpoch(ls * 1000);
          } catch (_) {}
        }

        bool? explicitOnline;
        final ioVal = profile['is_online'] ?? profile['online'] ?? profile['isOnline'];
        if (ioVal is bool) {
          explicitOnline = ioVal;
        } else if (ioVal is String) {
          if (ioVal.toLowerCase() == 'true' || ioVal == '1') explicitOnline = true;
          if (ioVal.toLowerCase() == 'false' || ioVal == '0') explicitOnline = false;
        } else if (ioVal is num) {
          explicitOnline = ioVal != 0;
        }

        bool online;
        if (explicitOnline != null) {
          online = explicitOnline;
        } else {
          if (lastSeen != null) {
            final seconds = DateTime.now().difference(lastSeen).inSeconds;
            online = seconds <= 60;
          } else {
            online = false;
          }
        }

        // Only apply this REST-derived state if we haven't yet received any
        // presence update from the socket (avoid overwriting newer socket data).
        if (!mounted) return;
        if (!_presenceInitialized) {
          setState(() {
            _explicitOnline = explicitOnline;
            _peerOnline = online;
            if (lastSeen != null) _peerLastSeen = lastSeen;
            _presenceInitialized = true; // treat REST result as initial presence
          });
        }
      } catch (_) {
        // ignore REST fallback errors and let the socket fallback run below
      }

      // Set a more generous fallback timeout: if we still don't receive a presence event
      // after 8 seconds, mark offline. This helps on slow networks or when the server
      // takes longer to emit the current status. We won't clobber a REST-derived state
      // because _presenceInitialized will already be true in that case.
      Future.delayed(const Duration(seconds: 8), () {
        if (!mounted || _presenceInitialized) return;
        setState(() {
          _peerOnline = false;
          _presenceInitialized = true;
        });
      });
    } catch (_) {
      // Connection failed; show offline
      if (mounted) {
        setState(() {
          _peerOnline = false;
          _presenceInitialized = true;
        });
      }
    }
  }

  Future<void> _showReportDialog() async {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Report User'),
        content: const Text('Are you sure you want to report this user?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () async {
              Navigator.of(ctx).pop();
              
              // Show loading indicator
              showDialog(
                context: context,
                barrierDismissible: false,
                builder: (loadCtx) => const AlertDialog(
                  content: SizedBox(
                    height: 50,
                    child: Center(child: CircularProgressIndicator()),
                  ),
                ),
              );
              
              try {
                await AuthService().reportUser(widget.peerId);
                
                if (!mounted) return;
                Navigator.of(context).pop(); // Close loading dialog
                
                customSnackBar('Success', 'User reported successfully');
              } catch (e) {
                if (!mounted) return;
                Navigator.of(context).pop(); // Close loading dialog
                
                final errorMsg = e.toString();
                customSnackBar('Error', errorMsg.contains('ApiException:') 
                  ? errorMsg.replaceFirst('ApiException: ', '') 
                  : 'Failed to report user');
              }
            },
            child: const Text('Report', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );
  }

  Future<void> _send() async {
    final text = _controller.text.trim();
    if (text.isEmpty || _sending) return;
    
    // Check if socket is connected
    if (!SocketService().isConnected) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Unable to send message. Please check your connection.'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }
    
    // Optimistic update: show message instantly
    final msg = Message(
      fromId: _myId,
      toId: widget.peerId,
      text: text,
      timestamp: DateTime.now(),
    );
    // Create a local id so we can match server acks to this optimistic message
    final localId = 'local-${DateTime.now().millisecondsSinceEpoch}';
    setState(() {
      _messages.add(msg);
      _messageIds.add(localId); // placeholder until server id known
      _pendingLocalText[localId] = text;
      // Always keep messages sorted chronologically
      final paired = List.generate(_messages.length, (i) => MapEntry(_messageIds[i], _messages[i]));
      paired.sort((a, b) => a.value.timestamp.compareTo(b.value.timestamp));
      _messages = paired.map((e) => e.value).toList();
      _messageIds
        ..clear()
        ..addAll(paired.map((e) => e.key));
      _controller.clear();
      _sending = false;
    });
    _saveToCache();
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
    
    // Send to server in background (no await blocking UI)
    setState(() => _sending = true);
    try {
      // Send via socket only
      SocketService().sendMessage(toUserId: widget.peerId, content: text, messageId: localId);
      // Start ack timeout - mark as failed if no ack received
      final t = Timer(const Duration(seconds: 8), () {
        // If still pending, mark as failed
        if (_pendingLocalText.containsKey(localId)) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Message failed to send'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
        _pendingAcks[localId]?.cancel();
        _pendingAcks.remove(localId);
        _pendingLocalText.remove(localId);
      });
      _pendingAcks[localId] = t;
      if (mounted) setState(() => _sending = false);
    } catch (e) {
      debugPrint('ChatScreen: sendMessage error -> $e');
      if (mounted) setState(() => _sending = false);
      // Message already shown; could add retry logic or error indicator here
    }
  }

  @override
  void dispose() {
    _controller.removeListener(_handleTyping);
    _controller.dispose();
    _focusNode.dispose();
    _typingResetTimer?.cancel();
  _peerTypingAutoResetTimer?.cancel();
    _newMessageSub?.cancel();
    _messageSentSub?.cancel();
    _messageErrorSub?.cancel();
    _userTypingSub?.cancel();
    _userStatusSub?.cancel();
    _messageReadSub?.cancel();
    // Cancel any pending ack timers
    for (final t in _pendingAcks.values) {
      t.cancel();
    }
    _pendingAcks.clear();
    _pendingLocalText.clear();
    // Unsubscribe from presence updates
    SocketService().unsubscribeUserStatus(widget.peerId);
    _presenceTicker?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final showLoading = _loadingMessages && _messages.isEmpty;

    return WillPopScope(
      onWillPop: () async {
        // Ensure callers (ChatsListScreen) know whether we marked messages read
        Navigator.of(context).pop({'markedRead': _hasMarkedRead});
        return false; // we've popped manually
      },
      child: Scaffold(
        backgroundColor: const Color(0xFFFFFBF0),
        appBar: PreferredSize(
          preferredSize: const Size.fromHeight(65),
          child: AppBar(
            backgroundColor: Colors.transparent,
            elevation: 0,
            centerTitle: true,
            automaticallyImplyLeading: false,
            // Rounded frosted AppBar to match other screens
            shape: const RoundedRectangleBorder(
              borderRadius: BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
            ),
            flexibleSpace: ClipRRect(
              borderRadius: const BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
              child: BackdropFilter(
                filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
                child: Container(
                  decoration: const BoxDecoration(
                    gradient: LinearGradient(
                      colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      stops: [0.0, 0.5, 1.0],
                    ),
                  ),
                ),
              ),
            ),
            leading: IconButton(
              icon: const Icon(Icons.arrow_back, color: Colors.white),
              onPressed: () => Navigator.of(context).pop({'markedRead': _hasMarkedRead}),
            ),
            title: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                Text(widget.peerName, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
                Padding(
                  padding: const EdgeInsets.only(top: 6.0),
                  child: Text(
                    _peerTyping
                        ? '${widget.peerName} is typing...'
                        : (!_presenceInitialized
                            ? 'Checking status'
                            : (_peerOnline
                                ? 'Online'
                                : (_peerLastSeen != null
                                    ? 'Last seen ${_lastSeenString(_peerLastSeen!)}'
                                    : 'Offline'))),
                    style: TextStyle(
                      color: _peerTyping ? Colors.white : Colors.white70,
                      fontStyle: FontStyle.italic,
                      fontSize: _peerTyping ? 14 : 12,
                    ),
                  ),
                ),
              ],
            ),
            actions: [
              PopupMenuButton(
                itemBuilder: (context) => [
                  PopupMenuItem(
                    child: Row(
                      children: const [
                        Icon(Icons.flag_outlined, color: Colors.red),
                        SizedBox(width: 8),
                        Text('Report User'),
                      ],
                    ),
                    onTap: () => _showReportDialog(),
                  ),
                ],
                icon: const Icon(Icons.more_vert, color: Colors.white),
              ),
            ],
            iconTheme: const IconThemeData(color: Colors.white),
          ),
        ),
        body: showLoading
            ? const Center(child: CircularProgressIndicator())
            : Column(
                children: [
                  Expanded(
                    child: ListView.builder(
                      controller: _scrollController,
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                      reverse: false,
                      itemCount: _messages.length,
                      itemBuilder: (context, i) {
                        final m = _messages[i];
                        final mine = m.fromId == _myId;
                        final showDateHeader = i == 0 || m.timestamp.day != _messages[i - 1].timestamp.day || m.timestamp.month != _messages[i - 1].timestamp.month || m.timestamp.year != _messages[i - 1].timestamp.year;
                        return Column(
                          crossAxisAlignment: mine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                          children: [
                            if (showDateHeader)
                              Padding(
                                padding: const EdgeInsets.symmetric(vertical: 12.0),
                                child: Center(
                                  child: Container(
                                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                                    decoration: BoxDecoration(
                                      gradient: LinearGradient(
                                        colors: [
                                          const Color(0xFFFFF59D).withOpacity(0.3),
                                          const Color(0xFFE53935).withOpacity(0.2),
                                          const Color(0xFFFFF59D).withOpacity(0.3),
                                        ],
                                        begin: Alignment.topLeft,
                                        end: Alignment.bottomRight,
                                      ),
                                      borderRadius: BorderRadius.circular(16),
                                      boxShadow: [
                                        BoxShadow(
                                          color: const Color(0xFFE53935).withOpacity(0.1),
                                          blurRadius: 8,
                                          offset: const Offset(0, 2),
                                        ),
                                      ],
                                    ),
                                    child: Text(
                                      _formatDate(m.timestamp),
                                      style: const TextStyle(
                                        color: Color(0xFFE53935),
                                        fontSize: 12,
                                        fontWeight: FontWeight.w700,
                                        letterSpacing: 0.5,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            Container(
                              margin: EdgeInsets.only(top: 4, bottom: 4, left: mine ? 60 : 0, right: mine ? 0 : 60),
                              alignment: mine ? Alignment.centerRight : Alignment.centerLeft,
                              child: Column(
                                crossAxisAlignment: mine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                                children: [
                                  Container(
                                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                                    decoration: BoxDecoration(
                                      gradient: mine
                                          ? const LinearGradient(
                                              colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            )
                                          : null,
                                      color: mine ? null : Colors.white,
                                      borderRadius: BorderRadius.only(
                                        topLeft: const Radius.circular(20),
                                        topRight: const Radius.circular(20),
                                        bottomLeft: Radius.circular(mine ? 20 : 4),
                                        bottomRight: Radius.circular(mine ? 4 : 20),
                                      ),
                                      boxShadow: [
                                        BoxShadow(
                                          color: mine
                                              ? const Color(0xFFE53935).withOpacity(0.3)
                                              : Colors.black.withOpacity(0.08),
                                          blurRadius: mine ? 12 : 8,
                                          offset: Offset(0, mine ? 4 : 2),
                                        ),
                                      ],
                                      border: mine
                                          ? null
                                          : Border.all(
                                              color: const Color(0xFFFFF59D).withOpacity(0.3),
                                              width: 1,
                                            ),
                                    ),
                                    constraints: const BoxConstraints(maxWidth: 280),
                                    child: Column(
                                      crossAxisAlignment: mine ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          m.text,
                                          style: TextStyle(
                                            color: mine ? Colors.white : Colors.black87,
                                            fontSize: 15,
                                            height: 1.4,
                                          ),
                                        ),
                                        const SizedBox(height: 6),
                                        Row(
                                          mainAxisSize: MainAxisSize.min,
                                          children: [
                                            Text(
                                              _formatTime(m.timestamp),
                                              style: TextStyle(
                                                color: mine ? Colors.white.withOpacity(0.9) : Colors.black45,
                                                fontSize: 11,
                                                fontWeight: FontWeight.w500,
                                              ),
                                            ),
                                            if (mine) ...[
                                              const SizedBox(width: 4),
                                              Icon(
                                                m.read ? Icons.done_all_rounded : Icons.done_rounded,
                                                size: 16,
                                                color: m.read ? const Color(0xFFFFF59D) : Colors.white.withOpacity(0.8),
                                              ),
                                            ],
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        );
                      },
                    ),
                  ),
                  SafeArea(
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.05),
                            blurRadius: 10,
                            offset: const Offset(0, -2),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Container(
                              padding: const EdgeInsets.symmetric(horizontal: 4),
                              decoration: BoxDecoration(
                                color: const Color(0xFFFFFBF0),
                                borderRadius: BorderRadius.circular(24),
                                border: Border.all(
                                  color: const Color(0xFFE53935).withOpacity(0.2),
                                  width: 1.5,
                                ),
                                boxShadow: [
                                  BoxShadow(
                                    color: const Color(0xFFE53935).withOpacity(0.08),
                                    blurRadius: 8,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: Row(
                                children: [
                                  IconButton(
                                    onPressed: () async {
                                      try {
                                        await _openEmojiPicker();
                                      } catch (e) {
                                        debugPrint('ChatScreen: Could not open emoji picker');
                                      }
                                    },
                                    icon: const Icon(Icons.emoji_emotions_outlined, color: Color(0xFFE53935), size: 24),
                                  ),
                                  Expanded(
                                    child: TextField(
                                      controller: _controller,
                                      focusNode: _focusNode,
                                      style: const TextStyle(color: Colors.black87, fontSize: 15),
                                      maxLines: null,
                                      textCapitalization: TextCapitalization.sentences,
                                      decoration: const InputDecoration(
                                        hintText: 'Type a message...',
                                        hintStyle: TextStyle(color: Colors.black38, fontSize: 15),
                                        border: InputBorder.none,
                                        contentPadding: EdgeInsets.symmetric(horizontal: 8, vertical: 10),
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ),
                          const SizedBox(width: 10),
                          Container(
                            decoration: BoxDecoration(
                              gradient: const LinearGradient(
                                colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                              ),
                              shape: BoxShape.circle,
                              boxShadow: [
                                BoxShadow(
                                  color: const Color(0xFFE53935).withOpacity(0.4),
                                  blurRadius: 12,
                                  offset: const Offset(0, 4),
                                ),
                              ],
                            ),
                            child: Material(
                              color: Colors.transparent,
                              shape: const CircleBorder(),
                              child: InkWell(
                                onTap: _sending ? null : _send,
                                customBorder: const CircleBorder(),
                                child: Container(
                                  width: 48,
                                  height: 48,
                                  alignment: Alignment.center,
                                  child: Icon(
                                    Icons.send_rounded,
                                    color: _sending ? Colors.white.withOpacity(0.5) : Colors.white,
                                    size: 22,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  )
                ],
              ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'dart:ui';
import '../services/auth_service.dart';

import '../utils/custom_snackbar.dart';
import 'reset_link_sent_screen.dart';


class ForgotPasswordScreen extends StatefulWidget {
  const ForgotPasswordScreen({Key? key}) : super(key: key);

  @override
  State<ForgotPasswordScreen> createState() => _ForgotPasswordScreenState();
}

class _ForgotPasswordScreenState extends State<ForgotPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  bool _isLoading = false;

  String? _validateEmail(String? v) {
    if (v == null || v.trim().isEmpty) return 'Please enter your email';
    final emailReg = RegExp(r"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}");
    if (!emailReg.hasMatch(v.trim())) return 'Please enter a valid email';
    return null;
  }

  Future<void> _submit() async {
    final form = _formKey.currentState!;
    if (!form.validate()) return;
    setState(() => _isLoading = true);
    try {
      final auth = AuthService();
      final resp = await auth.forgotPassword(email: _emailController.text.trim());
      setState(() => _isLoading = false);

      String msg = '';
      // Extract message from nested data structure: data.message
      if (resp.containsKey('data') && resp['data'] is Map<String, dynamic>) {
        final data = resp['data'] as Map<String, dynamic>;
        if (data.containsKey('message') && data['message'] is String) {
          msg = data['message'];
        }
      }
      // Fallback to top-level message key if nested message not found
      if (msg.isEmpty && resp.containsKey('message') && resp['message'] is String) {
        msg = resp['message'];
      }
      
      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (ctx) => ResetLinkSentScreen(message: msg.isNotEmpty ? msg : null),
          ),
        );
      }
    } catch (e) {
      setState(() => _isLoading = false);
      final message = e is Exception ? e.toString().replaceAll('ApiException: ', '') : 'Request failed';
      customSnackBar('Error', message);
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
  final size = MediaQuery.of(context).size;
    return Scaffold(
      backgroundColor: const Color(0xFFFFFBF0), // Soft yellow-tinted background
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(72),
        child: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          centerTitle: true,
          automaticallyImplyLeading: false,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.only(
              bottomLeft: Radius.circular(18),
              bottomRight: Radius.circular(18),
            ),
          ),
          flexibleSpace: ClipRRect(
            borderRadius: const BorderRadius.only(
              bottomLeft: Radius.circular(18),
              bottomRight: Radius.circular(18),
            ),
            child: BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
              child: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    stops: [0.0, 0.5, 1.0],
                  ),
                ),
              ),
            ),
          ),
          leading: IconButton(
            icon: const Icon(Icons.arrow_back, color: Colors.white),
            onPressed: () => Navigator.of(context).maybePop(),
          ),
          title: const Text('Forgot password', style: TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
          iconTheme: const IconThemeData(color: Colors.white),
        ),
      ),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 20),
            child: Container(
              width: size.width,
              padding: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
                border: Border.all(
                  color: const Color(0xFFFFD54D).withOpacity(0.3),
                  width: 2,
                ),
                boxShadow: [
                  BoxShadow(
                    color: const Color(0xFFE53935).withOpacity(0.15),
                    blurRadius: 20,
                    offset: const Offset(0, 8),
                  ),
                ],
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  children: [
                    const Text(
                      'Enter the email associated with your account',
                      style: TextStyle(
                        color: Colors.black87,
                        fontSize: 15,
                        fontWeight: FontWeight.w500,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _emailController,
                      style: const TextStyle(color: Colors.black87, fontSize: 16),
                      decoration: InputDecoration(
                        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 18),
                        prefixIcon: const Icon(Icons.email_outlined, color: Color(0xFFE53935)),
                        labelText: 'Email',
                        labelStyle: TextStyle(
                          color: const Color(0xFFE53935).withOpacity(0.7),
                          fontWeight: FontWeight.w500,
                        ),
                        filled: true,
                        fillColor: Colors.white,
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(16),
                          borderSide: BorderSide(color: const Color(0xFFFFD54D).withOpacity(0.3), width: 1.5),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(16),
                          borderSide: const BorderSide(color: Color(0xFFE53935), width: 2.0),
                        ),
                        errorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(16),
                          borderSide: BorderSide(color: const Color(0xFFE53935).withOpacity(0.9), width: 1.8),
                        ),
                        focusedErrorBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(16),
                          borderSide: const BorderSide(color: Color(0xFFE53935), width: 2.0),
                        ),
                        errorStyle: const TextStyle(color: Color(0xFFE53935), fontSize: 12, fontWeight: FontWeight.w500),
                      ),
                      keyboardType: TextInputType.emailAddress,
                      validator: _validateEmail,
                    ),
                    const SizedBox(height: 18),
                    SizedBox(
                      width: double.infinity,
                      child: Container(
                        decoration: BoxDecoration(
                          gradient: const LinearGradient(
                            colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
                            begin: Alignment.topLeft,
                            end: Alignment.bottomRight,
                          ),
                          borderRadius: BorderRadius.circular(12),
                          boxShadow: [
                            BoxShadow(
                              color: const Color(0xFFE53935).withOpacity(0.4),
                              blurRadius: 12,
                              offset: const Offset(0, 6),
                            ),
                          ],
                        ),
                        child: ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.transparent,
                            shadowColor: Colors.transparent,
                            foregroundColor: Colors.white,
                            disabledBackgroundColor: Colors.transparent,
                            disabledForegroundColor: Colors.white70,
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                          ),
                          onPressed: _isLoading ? null : _submit,
                          child: _isLoading
                            ? const SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2.5),
                              )
                            : const Text(
                                'Send reset link',
                                style: TextStyle(
                                  fontSize: 18,
                                  fontWeight: FontWeight.w700,
                                  letterSpacing: 0.5,
                                ),
                              ),
                        ),
                      ),
                    )
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
import 'dart:ui';
import 'package:flutter/material.dart';

import '../services/auth_service.dart';
import 'chat_screen.dart';
import '../services/follow_service.dart';
import '../utils/custom_snackbar.dart';
import '../models/profile.dart';
import 'profile_detail_screen.dart';

class FriendsScreen extends StatefulWidget {
  const FriendsScreen({Key? key}) : super(key: key);

  @override
  State<FriendsScreen> createState() => _FriendsScreenState();
}

class _FriendsAppBar extends StatelessWidget implements PreferredSizeWidget {
  const _FriendsAppBar({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      centerTitle: true,
      automaticallyImplyLeading: false,
      // Rounded frosted AppBar to match the app's header theme
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
      ),
      flexibleSpace: ClipRRect(
        borderRadius: const BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
          child: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                stops: [0.0, 0.5, 1.0],
              ),
            ),
          ),
        ),
      ),
      leading: IconButton(
        icon: const Icon(Icons.arrow_back, color: Colors.white),
        onPressed: () => Navigator.of(context).pushNamedAndRemoveUntil('/home', (route) => false),
      ),
      title: const Text('Friends', style: TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
      iconTheme: const IconThemeData(color: Colors.white),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(72);
}

class _FriendsScreenState extends State<FriendsScreen> {
  bool _loading = true;
  String? _error;
  List<Map<String, dynamic>> _matches = [];

  @override
  void initState() {
    super.initState();
    _loadMatches();
  }

  Future<void> _loadMatches() async {
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final res = await followService.getMatches();
      setState(() {
        _matches = res;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _matches = [];
      });
      customSnackBar('Error', _error ?? 'Failed to load matches');
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  Future<void> _openProfile(Map<String, dynamic> m) async {
    final String userId = (m['id'] ?? '').toString();
    if (userId.isEmpty) return;

    // Check cache first
    final cached = AuthService().getCachedUser(userId);
    if (cached != null) {
      final profile = Profile.fromJson(cached);
      Navigator.of(context).push(
        MaterialPageRoute(
          builder: (_) => ProfileDetailScreen(
            profile: profile,
            hideFollowButton: true,
            onFollow: (String id) {
              // Optional: handle follow action
            },
          ),
        ),
      );
      return;
    }

    // Show loading while fetching full profile from API
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );

    try {
      final Map<String, dynamic> userMap = await AuthService().getUserById(userId);
      final profile = Profile.fromJson(userMap);
      
      if (!mounted) return;
      Navigator.of(context).pop(); // Close loading dialog
      
      Navigator.of(context).push(
        MaterialPageRoute(
          builder: (_) => ProfileDetailScreen(
            profile: profile,
            hideFollowButton: true,
            onFollow: (String id) {
              // Optional: handle follow action
            },
          ),
        ),
      );
    } catch (e) {
      if (!mounted) return;
      Navigator.of(context).pop(); // Close loading dialog
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to load profile');
    }
  }

  Widget _buildCard(Map<String, dynamic> m) {
    final String name = (m['full_name'] ?? m['name'] ?? '') as String;
    final String image = (m['imageUrl'] ?? m['profile_picture'] ?? '') as String;
    final String userId = (m['id'] ?? '').toString();
    final String subtitle = '';

    return Container(
      margin: const EdgeInsets.only(bottom: 10),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.08),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _openProfile(m),
          child: Padding(
            padding: const EdgeInsets.all(10),
            child: Row(
              children: [
                Hero(
                  tag: 'profile_$userId',
                  child: Container(
                    width: 56,
                    height: 56,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      image: image.isNotEmpty ? DecorationImage(image: NetworkImage(image), fit: BoxFit.cover) : null,
                      color: Colors.grey.shade200,
                    ),
                    child: image.isEmpty ? const Icon(Icons.person, size: 32, color: Colors.grey) : null,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(name, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                      if (subtitle.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 4.0),
                          child: Text(subtitle, style: const TextStyle(color: Colors.black54, fontSize: 14)),
                        ),
                    ],
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.chat_bubble_outline, color: Colors.red),
                  onPressed: () {
                    Navigator.of(context).push(MaterialPageRoute(builder: (_) => ChatScreen(currentUserId: 'me', peerId: userId, peerName: name)));
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: LinearGradient(
                colors: [
                  const Color(0xFFE53935).withOpacity(0.1),
                  const Color(0xFFFFF59D).withOpacity(0.1),
                ],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              boxShadow: [
                BoxShadow(
                  color: const Color(0xFFE53935).withOpacity(0.1),
                  blurRadius: 20,
                  spreadRadius: 5,
                ),
              ],
            ),
            child: Icon(
              Icons.people,
              size: 80,
              color: const Color(0xFFE53935).withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 24),
          const Text(
            'No Friends Yet',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Color(0xFFE53935),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Start connecting with people!',
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'When you match with someone, they\'ll appear here',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey[500],
            ),
          ),
          const SizedBox(height: 20),
          SizedBox(
            width: 200,
            child: ElevatedButton(
              onPressed: () => Navigator.of(context).pushNamedAndRemoveUntil('/home', (route) => false),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
              child: const Text(
                'Browse Profiles',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600)
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorState(String message) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.error_outline, color: Colors.red, size: 48),
          const SizedBox(height: 12),
          Text(message, textAlign: TextAlign.center),
          const SizedBox(height: 12),
          ElevatedButton(
            onPressed: () => _loadMatches(),
            child: const Text('Retry'),
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFFFFBF0),
      // Use the same minimal/transparent app bar style as BrowseScreen so
      // the content sits higher and matches the app's visual language.
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(72),
        child: _FriendsAppBar(),
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : (_matches.isEmpty
              ? _error == null
                  ? _buildEmptyState()
                  : _buildErrorState(_error!)
              : RefreshIndicator(
                  onRefresh: _loadMatches,
                  child: ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    itemCount: _matches.length,
                    itemBuilder: (ctx, i) => _buildCard(_matches[i]),
                  ),
                )),
    );
  }
}
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'browse_screen.dart';
import 'chats_list_screen.dart';
// profile_screen imported by sidebar when needed
import 'sidebar_screen.dart';
import 'requests_screen.dart';
import 'likes_screen.dart';
import 'notifications_screen.dart';
import '../services/message_service.dart';
import '../services/fcm_service.dart';

const Color _kAccent = Color(0xFFE53935); // primary red accent


class HomeScreen extends StatefulWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> with WidgetsBindingObserver {
  int _currentIndex = 0;
  // Lazily create LikesScreen only when the user first opens the Likes tab so
  // we don't call the Likes API during app initialization. The widget is
  // cached in-memory for the session and recreated only on app restart.
  bool _likesOpened = false;
  Widget? _likesWidget;
  int _unreadMessagesCount = 0;
  StreamSubscription<void>? _notifSub;
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocus = FocusNode();
  Timer? _searchDebounce;
  String _debouncedSearchQuery = '';

  @override
  void initState() {
    super.initState();
    // Add debounced listener to search controller to avoid rebuilding on every keystroke
    _searchController.addListener(() {
      // Cancel previous timer if user is still typing
      _searchDebounce?.cancel();
      
      // Start new timer - only trigger search after user stops typing for 300ms
      _searchDebounce = Timer(const Duration(milliseconds: 300), () {
        if (mounted && _searchController.text != _debouncedSearchQuery) {
          setState(() {
            _debouncedSearchQuery = _searchController.text;
          });
        }
      });
    });
    // Observe app lifecycle so we can connect/disconnect socket when app is
    // backgrounded or resumed. This helps the server correctly mark users
    // online/offline based on active socket connections.
    WidgetsBinding.instance.addObserver(this);
    // If launched via notification with an argument to open a specific tab,
    // handle it here. We expect {'openTab': 'chat'} to open the Chats tab.
    try {
      final args = Get.arguments;
      if (args is Map && args['openTab'] == 'chat') {
        _currentIndex = 2;
      }
    } catch (_) {}

    // Also check SharedPreferences for a pending navigation flag written by
    // the FCM handler (fallback if Get navigation didn't work).
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      try {
        final prefs = await SharedPreferences.getInstance();
        
        // Check if we need to navigate to notifications screen
        final pendingScreen = prefs.getString('pending_open_screen');
        if (pendingScreen == 'notifications') {
          try { await prefs.remove('pending_open_screen'); } catch (_) {}
          // Navigate to notifications screen
          if (mounted) {
            Navigator.of(context).pushNamed('/notifications');
          }
          return;
        }
        
        // Check if we need to open a specific tab
        final pending = prefs.getString('pending_open_tab');
        if (pending == 'chat') {
          setState(() {
            _currentIndex = 2;
          });
          try { await prefs.remove('pending_open_tab'); } catch (_) {}
          try { await prefs.remove('pending_chat_id'); } catch (_) {}
        }
      } catch (_) {}
    });
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Load unread count only on app start/restart
      _loadUnreadCount();

      // Subscribe to FCM notification arrival events and refresh unread count
      // Only call API when notification arrives (not on timer or other events)
      try {
        _notifSub = fcmService.onNotificationArrived.listen((_) {
          _loadUnreadCount();
        });
      } catch (_) {}
    });
  }

  @override
  void dispose() {
    _searchDebounce?.cancel();
    try { WidgetsBinding.instance.removeObserver(this); } catch (_) {}
    try { _notifSub?.cancel(); } catch (_) {}
    _searchController.dispose();
    _searchFocus.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    // App lifecycle is now managed at app level, not screen level
  }

  Future<void> _loadUnreadCount() async {
    try {
      final count = await MessageService().getTotalUnreadCount();
      if (mounted) {
        setState(() {
          _unreadMessagesCount = count;
        });
      }
    } catch (e) {
      debugPrint('HomeScreen: Failed to load unread count -> $e');
    }
  }

  void _clearSearch() {
    _searchDebounce?.cancel();
    _searchController.clear();
    setState(() {
      _isSearching = false;
      _debouncedSearchQuery = '';
    });
  }

  @override
  Widget build(BuildContext context) {
    
    final tabs = [
      BrowseScreen(
        key: ValueKey('browse_$_debouncedSearchQuery'),
        currentUserId: 'me', 
        searchQuery: _debouncedSearchQuery,
      ),
      // Lazily create LikesScreen only when the tab is first opened so the
      // likes API is not called during app initialization. We cache the
      // created widget in-memory for the session in `_likesWidget`.
      _likesWidget ?? const SizedBox.shrink(),
      ChatsListScreen(
        currentUserId: 'me',
        onReturnFromChat: () {
          // Refresh unread count immediately when returning from chat
          _loadUnreadCount();
        },
      ),
      const RequestsScreen(currentUserId: 'me'),
    ];

  final bool isBrowse = _currentIndex == 0;

  return Scaffold(
    // When Browse tab is active we want the body gradient to extend
    // behind the AppBar so rounded corners show the screen gradient
    // instead of the parent scaffold background. For other tabs keep
    // the original off-white scaffold color.
    extendBodyBehindAppBar: isBrowse,
    // Also allow the body to extend behind the bottom navigation when
    // Browse is active so the page gradient continues into the area
    // under the nav pill instead of showing a solid background.
    extendBody: isBrowse,
    backgroundColor: isBrowse ? Colors.transparent : const Color(0xFFFFFBF0),
    // Hide parent appBar when Likes, Chat, or Requests tab is active so those screens' AppBars appear instead
    // Also hide when searching to show full search bar
    appBar: (_currentIndex == 1 || _currentIndex == 2 || _currentIndex == 3 || _isSearching)
        ? null
    : PreferredSize(
      preferredSize: const Size.fromHeight(72),
            child: AppBar(
              backgroundColor: Colors.transparent,
              elevation: 0,
              // give the AppBar a rounded shape so underlying scaffold
              // color does not peek through at the corners
              shape: const RoundedRectangleBorder(
                borderRadius: BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
              ),
              centerTitle: true,
              automaticallyImplyLeading: false,
              flexibleSpace: ClipRRect(
                borderRadius: const BorderRadius.only(
                  bottomLeft: Radius.circular(18),
                  bottomRight: Radius.circular(18),
                ),
                child: BackdropFilter(
                  filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
                  child: Container(
                    decoration: const BoxDecoration(
                      // yellow -> red -> yellow so the AppBar has yellow on
                      // the left and right edges with red focused at center
                      gradient: LinearGradient(
                        colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                        stops: [0.0, 0.5, 1.0],
                      ),
                    ),
                  ),
                ),
              ),
              leading: Builder(
                builder: (ctx) => IconButton(
                  // show white menu icon for contrast on the gradient AppBar
                  icon: const Icon(Icons.menu, color: Colors.white),
                  onPressed: () => Scaffold.of(ctx).openDrawer(),
                ),
              ),
              title: Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: const [
                          // title sits near center red; keep it white for contrast
                          Text('Anchor', style: TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
                          SizedBox(height: 2),
                          Text('Discover', style: TextStyle(color: Colors.white70, fontSize: 14, fontWeight: FontWeight.w600)),
                        ],
                      ),
                    ),
              actions: [
                IconButton(
                  icon: const Icon(Icons.notifications_outlined, color: Colors.white),
                  onPressed: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(builder: (_) => const NotificationsScreen()),
                    );
                  },
                ),
              ],
            ),
          ),
      drawer: const SidebarDrawer(),
      // Floating Action Button for Chat
      floatingActionButton: Container(
        width: 56,
        height: 56,
        decoration: BoxDecoration(
          gradient: const LinearGradient(
            colors: [
              Color(0xFFFFF59D),
              Color(0xFFE53935),
              Color(0xFFFFF59D),
            ],
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            stops: [0.0, 0.5, 1.0],
          ),
          shape: BoxShape.circle,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.3),
              spreadRadius: 1,
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: () {
              setState(() => _currentIndex = 2);
              // Reload unread count when switching to chat tab (to reflect messages read in chat screen)
              _loadUnreadCount();
            },
            borderRadius: BorderRadius.circular(28),
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                const Center(
                  child: Icon(Icons.chat_bubble_rounded, color: Colors.white, size: 28),
                ),
                if (_unreadMessagesCount > 0)
                  Positioned(
                    top: 4,
                    right: 4,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        shape: BoxShape.circle,
                        border: Border.all(color: const Color(0xFFE53935), width: 2),
                      ),
                      constraints: const BoxConstraints(
                        minWidth: 20,
                        minHeight: 20,
                      ),
                      child: Center(
                        child: Text(
                          _unreadMessagesCount > 99 ? '99+' : _unreadMessagesCount.toString(),
                          style: const TextStyle(
                            color: Color(0xFFE53935),
                            fontSize: 10,
                            fontWeight: FontWeight.bold,
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
      floatingActionButtonLocation: _CustomFabLocation(),
      // Disable Hero animations for the tabbed content to avoid
      // unintended cross-tab hero transitions (these were causing the
      // avatar placeholder to 'fall' when switching between Likes and
      // Browse). If you want hero animations for profile opens, we can
      // selectively enable them during navigation instead.
      body: Column(
        children: [
          // Show search bar when searching
          if (_isSearching && _currentIndex == 0)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                gradient: const LinearGradient(
                  colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  stops: [0.0, 0.5, 1.0],
                ),
                boxShadow: [
                  BoxShadow(color: Colors.black.withOpacity(0.1), blurRadius: 4, offset: const Offset(0, 2)),
                ],
              ),
              child: SafeArea(
                bottom: false,
                child: TextField(
                  controller: _searchController,
                  focusNode: _searchFocus,
                  style: const TextStyle(color: Colors.white, fontSize: 16),
                  decoration: InputDecoration(
                    hintText: 'Search profiles...',
                    hintStyle: const TextStyle(color: Colors.white70),
                    prefixIcon: const Icon(Icons.search, color: Colors.white),
                    suffixIcon: IconButton(
                      icon: const Icon(Icons.close, color: Colors.white),
                      onPressed: () {
                        _clearSearch();
                      },
                    ),
                    filled: true,
                    fillColor: Colors.white.withOpacity(0.2),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(24),
                      borderSide: BorderSide.none,
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  ),
                ),
              ),
            ),
          Expanded(
            child: HeroMode(
              enabled: false,
              child: IndexedStack(index: _currentIndex, children: tabs),
            ),
          ),
        ],
      ),
      bottomNavigationBar: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 10.0),
        child: SafeArea(
          top: false,
          child: ClipPath(
            clipper: _BottomNavClipper(),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
              decoration: BoxDecoration(
                // Red + yellow theme: pale yellow edges with the app red as the
                // dominant tone so the pill reads warm and branded while
                // preserving contrast for icons and labels.
                gradient: const LinearGradient(
                  colors: [Color(0xFFFFF59D), Color(0xFFF06256)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  stops: [0.0, 1.0],
                ),
                borderRadius: BorderRadius.circular(28),
                boxShadow: [
                  BoxShadow(color: Colors.black.withOpacity(0.08), blurRadius: 20, offset: const Offset(0, 8)),
                ],
                border: Border.all(color: Colors.white.withOpacity(0.08)),
              ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      _NavBarItem(
                        icon: Icons.home_rounded,
                        label: 'Home',
                        selected: _currentIndex == 0 && !_isSearching,
                        onTap: () => setState(() {
                          _currentIndex = 0;
                          if (_isSearching) {
                            _clearSearch();
                          }
                        }),
                      ),
                      _NavBarItem(
                        icon: Icons.search,
                        label: 'Discover',
                        selected: _isSearching,
                        onTap: () {
                          setState(() {
                            if (_isSearching) {
                              _clearSearch();
                            } else {
                              _currentIndex = 0; // Switch to Home tab to show search
                              _isSearching = true;
                              Future.delayed(const Duration(milliseconds: 100), () {
                                _searchFocus.requestFocus();
                              });
                            }
                          });
                        },
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 80), // Space for FAB notch
                Expanded(
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      _NavBarItem(
                        icon: Icons.favorite_rounded,
                        label: 'Likes',
                        selected: _currentIndex == 1,
                        onTap: () => setState(() {
                          _currentIndex = 1;
                          if (_isSearching) {
                            _clearSearch();
                          }
                          // Create the LikesScreen the first time the user opens the
                          // Likes tab. This avoids calling the Likes API on app
                          // initialization; subsequent opens reuse the cached widget.
                          if (!_likesOpened) {
                            _likesOpened = true;
                            _likesWidget = LikesScreen(key: const ValueKey('likes'), currentUserId: 'me');
                          }
                        }),
                      ),
                      _NavBarItem(
                        icon: Icons.people_alt_rounded,
                        label: 'Requests',
                        selected: _currentIndex == 3,
                        onTap: () => setState(() {
                          _currentIndex = 3;
                          if (_isSearching) {
                            _clearSearch();
                          }
                        }),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
      )
    );
  }
}

// Custom clipper for bottom navigation bar with notch for FAB
class _BottomNavClipper extends CustomClipper<Path> {
  @override
  Path getClip(Size size) {
    final path = Path();
    const notchRadius = 35.0; // Radius of the circular notch
    const notchMargin = 8.0; // Space between FAB and nav bar edge
    
    final centerX = size.width / 2;
    
    // Start from top-left
    path.moveTo(0, 0);
    
    // Left side before notch
    path.lineTo(centerX - notchRadius - notchMargin, 0);
    
    // Create circular notch
    path.arcToPoint(
      Offset(centerX + notchRadius + notchMargin, 0),
      radius: const Radius.circular(notchRadius + notchMargin),
      clockwise: false,
    );
    
    // Right side after notch
    path.lineTo(size.width, 0);
    
    // Complete the rectangle
    path.lineTo(size.width, size.height);
    path.lineTo(0, size.height);
    path.close();
    
    return path;
  }

  @override
  bool shouldReclip(CustomClipper<Path> oldClipper) => false;
}

class _NavBarItem extends StatelessWidget {
  final IconData icon;
  final String label;
  final bool selected;
  final VoidCallback onTap;

  const _NavBarItem({
    required this.icon,
    required this.label,
    required this.selected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
  // On the red+yellow pill: both selected and unselected icons should be
  // white for consistent visibility across the gradient; labels for
  // unselected items remain a darker grey for subtlety.
  final iconColor = Colors.white;
  final labelColor = selected ? Colors.white : Colors.grey.shade800;
    
    return Expanded(
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.symmetric(vertical: 4),
        decoration: selected
            ? BoxDecoration(
                // stronger red background for the selected item so white
                // icons/labels contrast well regardless of where the
                // gradient sits underneath.
                color: _kAccent.withOpacity(0.95),
                borderRadius: BorderRadius.circular(12),
                boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.06), blurRadius: 8, offset: const Offset(0, 4))],
              )
            : null,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: iconColor, size: selected ? 28 : 24),
            const SizedBox(height: 2),
            Text(
              label,
              style: TextStyle(
                color: labelColor,
                fontWeight: selected ? FontWeight.bold : FontWeight.normal,
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    ));
  }
}

// Custom FloatingActionButtonLocation to position FAB lower in the navigation bar
class _CustomFabLocation extends FloatingActionButtonLocation {
  @override
  Offset getOffset(ScaffoldPrelayoutGeometry scaffoldGeometry) {
    // Get the default centerDocked position
    final double fabX = (scaffoldGeometry.scaffoldSize.width - scaffoldGeometry.floatingActionButtonSize.width) / 2;
    // Compute Y so the FAB sits slightly above the body/content bottom
    // (which is above the bottom navigation notch). This keeps the FAB
    // visually in the same place across very large screens.
    // Small gap above the notch - adjusted to move FAB lower
    const double gapAboveNav = -8.0;
    final double fabHalf = scaffoldGeometry.floatingActionButtonSize.height / 2.0;

    // contentBottom should represent the bottom edge of the scaffold body
    // (i.e. the top of any bottom navigation). Use a safe fallback if it's
    // not available.
    double bodyBottom = scaffoldGeometry.contentBottom;
    if (bodyBottom.isNaN || bodyBottom.isInfinite) {
      bodyBottom = scaffoldGeometry.scaffoldSize.height;
    }

    double fabY = bodyBottom - fabHalf - gapAboveNav;

    // Ensure fabY remains in a sensible range (at least 16px from top and
    // not offscreen). This is defensive but shouldn't normally be hit.
    final double minY = 16.0;
    final double maxY = scaffoldGeometry.scaffoldSize.height - fabHalf;
    if (fabY.isNaN || fabY.isInfinite) fabY = scaffoldGeometry.scaffoldSize.height - scaffoldGeometry.floatingActionButtonSize.height - 50.0;
    if (fabY < minY) fabY = minY;
    if (fabY > maxY) fabY = maxY;

    return Offset(fabX, fabY);
  }
}
import 'package:flutter/material.dart';
import 'dart:ui';
import '../models/profile.dart';
import '../services/match_service.dart';
import '../services/auth_service.dart';
import '../network/api_client.dart';
import '../config/api_config.dart';
import 'profile_detail_screen.dart';
import '../utils/custom_snackbar.dart';

class LikesScreen extends StatefulWidget {
  final String currentUserId;
  const LikesScreen({Key? key, required this.currentUserId}) : super(key: key);

  @override
  State<LikesScreen> createState() => _LikesScreenState();
}

class _LikesScreenState extends State<LikesScreen> {
  // State for 'Liked By Me' tab
  List<Map<String, dynamic>> _likedByMe = [];
  bool _likedByMeLoading = false;
  String? _likedByMeError;
  // Track whether we've attempted an automatic load of "Liked By Me" in
  // this app session. This prevents calling the API every time the user
  // switches to the tab; the API will be called automatically only on the
  // first open after app start. Manual refresh (pull-to-refresh) still works.
  bool _likedByMeLoaded = false;

  Future<void> _loadLikedByMe() async {
    setState(() {
      _likedByMeLoading = true;
      _likedByMeError = null;
    });
    try {
      final resp = await apiClient.get('/likes/liked-by-me');
      final data = resp.data;
      List<Map<String, dynamic>> items = [];
      if (data is Map<String, dynamic>) {
        final d = data[ApiConfig.dataKey] ?? data;
        if (d is List) items = List<Map<String, dynamic>>.from(d.map((e) => e as Map<String, dynamic>));
        else if (d is Map<String, dynamic>) {
          if (d['likes'] is List) items = List<Map<String, dynamic>>.from((d['likes'] as List).map((e) => e as Map<String, dynamic>));
          else if (d['items'] is List) items = List<Map<String, dynamic>>.from((d['items'] as List).map((e) => e as Map<String, dynamic>));
        } else if (data['likes'] is List) {
          items = List<Map<String, dynamic>>.from((data['likes'] as List).map((e) => e as Map<String, dynamic>));
        }
      } else if (data is List) {
        items = List<Map<String, dynamic>>.from(data.map((e) => e as Map<String, dynamic>));
      }

      final out = <Map<String, dynamic>>[];
      if (items.isNotEmpty) {
        for (final it in items) {
          try {
            Map<String, dynamic> userMap;
            String? likedAt;
            if (it.containsKey('user') && it['user'] is Map<String, dynamic>) {
              userMap = Map<String, dynamic>.from(it['user']);
              likedAt = it['created_at']?.toString();
            } else {
              userMap = Map<String, dynamic>.from(it);
              likedAt = it['created_at']?.toString();
            }

            // Normalize profile picture path if necessary
            if (userMap.containsKey('profile_picture') && userMap['profile_picture'] != null) {
              final raw = userMap['profile_picture'].toString();
              if (!raw.startsWith('http')) {
                var base = ApiConfig.baseUrl;
                if (base.endsWith('/api')) base = base.substring(0, base.length - 4);
                userMap['profile_picture'] = raw.startsWith('/') ? '$base$raw' : '$base/$raw';
              }
            }

            final Profile prof = Profile.fromJson(userMap);
            out.add({'profile': prof, 'liked_at': likedAt});
          } catch (_) {
            // ignore malformed items
          }
        }
      }

      if (out.isNotEmpty) {
        MatchService.setCachedLikedByMe(widget.currentUserId, out);
      }
      setState(() {
        _likedByMe = out;
        _likedByMeError = null;
      });
    } catch (e) {
      setState(() {
        _likedByMeError = e is Exception ? e.toString() : '$e';
        _likedByMe = [];
      });
    } finally {
      setState(() {
        _likedByMeLoading = false;
      });
    }
  }
  // Each entry is a map with keys: 'profile': Profile, 'liked_at': String?
  late List<Map<String, dynamic>> _liked = [];
  bool _loading = true;
  String? _error;

  int _tabIndex = 0;

  @override
  void initState() {
    super.initState();
    // Try to read cached likes and display immediately to avoid the
    // loading spinner on every open. Then fetch fresh results in the
    // background and update UI/cache when available.
    final cached = MatchService.getCachedLikes(widget.currentUserId);
    if (cached != null && cached.isNotEmpty) {
      setState(() {
        _liked = cached.map((m) => {'profile': m['profile'] as Profile, 'liked_at': m['liked_at']}).toList();
        _loading = false;
      });
      // refresh in background without showing loading indicator
      _loadMyLikes(showLoading: false);
    } else {
      _loadMyLikes();
    }
  }

  Future<void> _loadMyLikes({bool showLoading = true}) async {
    if (showLoading) {
      setState(() {
        _loading = true;
        _error = null;
      });
    }

    try {
      final resp = await apiClient.get('/likes/my-likes');
      final data = resp.data;

      // Normalize to a list of maps representing either like objects or user maps
      List<Map<String, dynamic>> items = [];
      if (data is Map<String, dynamic>) {
        final d = data[ApiConfig.dataKey] ?? data;
        if (d is List) items = List<Map<String, dynamic>>.from(d.map((e) => e as Map<String, dynamic>));
        else if (d is Map<String, dynamic>) {
          if (d['likes'] is List) items = List<Map<String, dynamic>>.from((d['likes'] as List).map((e) => e as Map<String, dynamic>));
          else if (d['items'] is List) items = List<Map<String, dynamic>>.from((d['items'] as List).map((e) => e as Map<String, dynamic>));
        } else if (data['likes'] is List) {
          items = List<Map<String, dynamic>>.from((data['likes'] as List).map((e) => e as Map<String, dynamic>));
        }
      } else if (data is List) {
        items = List<Map<String, dynamic>>.from(data.map((e) => e as Map<String, dynamic>));
      }

      final out = <Map<String, dynamic>>[];
      if (items.isNotEmpty) {
        for (final it in items) {
          try {
            Map<String, dynamic> userMap;
            String? likedAt;
            if (it.containsKey('user') && it['user'] is Map<String, dynamic>) {
              userMap = Map<String, dynamic>.from(it['user']);
              likedAt = it['created_at']?.toString();
            } else {
              userMap = Map<String, dynamic>.from(it);
              likedAt = it['created_at']?.toString();
            }

            // Normalize profile picture path if necessary
            if (userMap.containsKey('profile_picture') && userMap['profile_picture'] != null) {
              final raw = userMap['profile_picture'].toString();
              if (!raw.startsWith('http')) {
                var base = ApiConfig.baseUrl;
                if (base.endsWith('/api')) base = base.substring(0, base.length - 4);
                userMap['profile_picture'] = raw.startsWith('/') ? '$base$raw' : '$base/$raw';
              }
            }

            final Profile prof = Profile.fromJson(userMap);
            out.add({'profile': prof, 'liked_at': likedAt});
          } catch (_) {
            // ignore malformed items
          }
        }
      }

      if (out.isNotEmpty) {
        MatchService.setCachedLikes(widget.currentUserId, out);
        setState(() {
          _liked = out;
          _error = null;
        });
      } else {
        // No likes returned from API
        MatchService.setCachedLikes(widget.currentUserId, []);
        setState(() {
          _liked = [];
          _error = null;
        });
      }
    } catch (e) {
      _error = e is Exception ? e.toString() : '$e';
      setState(() {
        _liked = [];
        _error = _error;
      });
    } finally {
      if (mounted && showLoading) setState(() { _loading = false; });
    }
  }

  // initial load is handled by _loadMyLikes called in the primary initState

  Future<void> _openProfile(Profile p) async {
    // If user is cached we can navigate immediately without showing a loading dialog.
    final cached = AuthService().getCachedUser(p.id);
    if (cached != null) {
      final raw = Profile.fromJson(cached);
      final fetched = Profile(
        id: raw.id.isNotEmpty ? raw.id : p.id,
        name: raw.name.isNotEmpty ? raw.name : p.name,
        age: raw.age != 0 ? raw.age : p.age,
        bio: raw.bio.isNotEmpty ? raw.bio : p.bio,
        imageUrl: raw.imageUrl.isNotEmpty ? raw.imageUrl : p.imageUrl,
        gender: raw.gender,
        location: raw.location,
        interests: raw.interests,
        hobbies: raw.hobbies,
        relationshipGoals: raw.relationshipGoals,
        partnerQualities: raw.partnerQualities,
      );
      Navigator.of(context).push(MaterialPageRoute(builder: (_) => ProfileDetailScreen(
        profile: fetched, 
        requested: false, 
        onFollow: (_) {}
      )));
      return;
    }

    // show loading while fetching full profile
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );
    try {
      final Map<String, dynamic> userMap = await AuthService().getUserById(p.id);
      final raw = Profile.fromJson(userMap);
      final fetched = Profile(
        id: raw.id.isNotEmpty ? raw.id : p.id,
        name: raw.name.isNotEmpty ? raw.name : p.name,
        age: raw.age != 0 ? raw.age : p.age,
        bio: raw.bio.isNotEmpty ? raw.bio : p.bio,
        imageUrl: raw.imageUrl.isNotEmpty ? raw.imageUrl : p.imageUrl,
        gender: raw.gender,
        location: raw.location,
        interests: raw.interests,
        hobbies: raw.hobbies,
        relationshipGoals: raw.relationshipGoals,
        partnerQualities: raw.partnerQualities,
      );
      Navigator.of(context).pop();
      Navigator.of(context).push(MaterialPageRoute(builder: (_) => ProfileDetailScreen(
        profile: fetched, 
        requested: false, 
        onFollow: (_) {}
      )));
    } catch (e) {
      Navigator.of(context).pop();
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to load profile');
    }
  }

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        Navigator.of(context).pushNamedAndRemoveUntil('/home', (route) => false);
        return false;
      },
      child: DefaultTabController(
        length: 2,
        initialIndex: _tabIndex,
        child: Scaffold(
          backgroundColor: const Color(0xFFFFFBF0),
          appBar: const PreferredSize(
            preferredSize: Size.fromHeight(72),
            child: _LikesAppBar(),
          ),
          body: Column(
            children: [
              Container(
                color: const Color(0xFFFFFBF0),
                child: TabBar(
                  tabs: const [
                    Tab(text: 'Liked'),
                    Tab(text: 'Matches'),
                  ],
                  labelColor: Colors.red,
                  unselectedLabelColor: Colors.black54,
                  indicatorColor: Colors.red,
                  indicatorWeight: 3,
                  onTap: (idx) {
                    setState(() {
                      _tabIndex = idx;
                    });
                    if (idx == 1) {
                      // Try to read a cached "Liked By Me" result and show it immediately.
                      final cachedLikedByMe = MatchService.getCachedLikedByMe(widget.currentUserId);
                      if (cachedLikedByMe != null && cachedLikedByMe.isNotEmpty) {
                        setState(() {
                          _likedByMe = cachedLikedByMe
                              .map((m) => {'profile': m['profile'] as Profile, 'liked_at': m['liked_at']})
                              .toList();
                          _likedByMeError = null;
                          _likedByMeLoading = false;
                        });
                        if (!_likedByMeLoaded) {
                          _likedByMeLoaded = true;
                          _loadLikedByMe();
                        }
                      } else {
                        if (!_likedByMeLoaded) {
                          _likedByMeLoaded = true;
                          _loadLikedByMe();
                        }
                      }
                    }
                  },
                ),
              ),
              Expanded(
                child: TabBarView(
                  // physics: const NeverScrollableScrollPhysics(),
                  children: [
                    _loading
                        ? const Center(child: CircularProgressIndicator())
                        : (_liked.isEmpty
                            ? _buildEmptyState(
                                'No Likes Yet',
                                _error == null
                                    ? 'Every great story starts with a swipe. Explore profiles and find your match!'
                                    : 'No likes (${_error ?? ''})',
                                Icons.favorite_border,
                                'Browse Profiles',
                                () => Navigator.of(context)
                                    .pushNamedAndRemoveUntil('/home', (route) => false),
                              )
                            : RefreshIndicator(
                                onRefresh: _loadMyLikes,
                                child: ListView.builder(
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 16, vertical: 12),
                                  itemCount: _liked.length,
                                  itemBuilder: (context, i) {
                                    final entry = _liked[i];
                                    final Profile p = entry['profile'] as Profile;
                                    final String? likedAt =
                                        entry['liked_at'] as String?;
                                    final subtitle = (p.bio.isNotEmpty && p.bio != '-')
                                        ? p.bio
                                        : (likedAt != null
                                            ? 'Liked on ${DateTime.tryParse(likedAt)?.toIso8601String().split('T').first ?? likedAt}'
                                            : '');
                                    return _buildLikeTile(
                                        p: p, subtitle: subtitle);
                                  },
                                ),
                              )),
                    // Liked By Me tab
                    _likedByMeLoading
                        ? const Center(child: CircularProgressIndicator())
                        : (_likedByMeError != null
                            ? Center(
                                child: Text('Error: $_likedByMeError',
                                    style: const TextStyle(color: Colors.red)))
                            : (_likedByMe.isEmpty
                                ? _buildEmptyState(
                                    'No Likes Yet',
                                    'You haven\'t liked anyone yet. Browse profiles and show your interest!',
                                    Icons.favorite_border,
                                    'Browse Profiles',
                                    () => Navigator.of(context)
                                        .pushNamedAndRemoveUntil(
                                            '/home', (route) => false),
                                  )
                                : RefreshIndicator(
                                    onRefresh: _loadLikedByMe,
                                    child: ListView.builder(
                                      padding: const EdgeInsets.symmetric(
                                          horizontal: 16, vertical: 12),
                                      itemCount: _likedByMe.length,
                                      itemBuilder: (context, i) {
                                        final entry = _likedByMe[i];
                                        final Profile p =
                                            entry['profile'] as Profile;
                                        final String? likedAt =
                                            entry['liked_at'] as String?;
                                        final subtitle =
                                            (p.bio.isNotEmpty && p.bio != '-')
                                                ? p.bio
                                                : (likedAt != null
                                                    ? 'Liked on ${DateTime.tryParse(likedAt)?.toIso8601String().split('T').first ?? likedAt}'
                                                    : '');
                                        return _buildLikeTile(
                                            p: p, subtitle: subtitle);
                                      },
                                    ),
                                  ))),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState(String title, String subtitle, IconData icon, String primaryLabel, VoidCallback onPrimary) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: LinearGradient(
                colors: [
                  const Color(0xFFE53935).withOpacity(0.1),
                  const Color(0xFFFFF59D).withOpacity(0.1),
                ],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              boxShadow: [
                BoxShadow(
                  color: const Color(0xFFE53935).withOpacity(0.1),
                  blurRadius: 20,
                  spreadRadius: 5,
                ),
              ],
            ),
            child: Icon(
              icon,
              size: 80,
              color: const Color(0xFFE53935).withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 24),
          Text(
            title,
            style: const TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Color(0xFFE53935),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            subtitle,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 20),
          SizedBox(
            width: 200, // Reduced from double.infinity to 200
            child: ElevatedButton(
              onPressed: onPrimary,
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 14),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
              child: Text(primaryLabel, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLikeTile({required Profile p, required String subtitle}) {
    final Color accentStart = const Color(0xFFFFF59D);
    final Color accentEnd = const Color(0xFFE53935);

    return Container(
      margin: const EdgeInsets.only(bottom: 10),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(16),
          onTap: () => _openProfile(p),
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(16),
              boxShadow: [
                BoxShadow(color: Colors.red.shade100.withOpacity(0.25), blurRadius: 18, offset: const Offset(0, 8)),
                BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 6, offset: const Offset(0, 2)),
              ],
              border: Border.all(color: Colors.white.withOpacity(0.7), width: 1),
            ),
            child: Stack(
              children: [
                // Left gradient accent bar (matches Notifications tiles)
                Positioned(
                  left: 0,
                  top: 0,
                  bottom: 0,
                  child: Container(
                    width: 6,
                    decoration: BoxDecoration(
                      borderRadius: const BorderRadius.only(
                        topLeft: Radius.circular(16),
                        bottomLeft: Radius.circular(16),
                      ),
                      gradient: LinearGradient(
                        colors: [accentStart, accentEnd],
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                      ),
                    ),
                  ),
                ),
                // Content row
                Padding(
                  // extra left padding to account for the accent bar thickness
                  padding: const EdgeInsets.fromLTRB(14 + 8, 10, 10, 10),
                  child: Row(
                    children: [
                      Hero(
                        tag: 'profile_${p.id}',
                        child: Container(
                          width: 56,
                          height: 56,
                          decoration: BoxDecoration(
                            shape: BoxShape.circle,
                            image: p.imageUrl.isNotEmpty
                                ? DecorationImage(image: NetworkImage(p.imageUrl), fit: BoxFit.cover)
                                : null,
                            color: Colors.grey.shade200,
                          ),
                          child: p.imageUrl.isEmpty
                              ? const Icon(Icons.person, size: 32, color: Colors.grey)
                              : null,
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(p.name, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black)),
                            if (subtitle.isNotEmpty)
                              Padding(
                                padding: const EdgeInsets.only(top: 4.0),
                                child: Text(subtitle, style: const TextStyle(color: Colors.black54, fontSize: 14)),
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

// Reusable styled app bar for Likes (matches HomeScreen styling)
class _LikesAppBar extends StatelessWidget implements PreferredSizeWidget {
  const _LikesAppBar({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      centerTitle: true,
      automaticallyImplyLeading: false,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
      ),
      flexibleSpace: ClipRRect(
        borderRadius: const BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
          child: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                stops: [0.0, 0.5, 1.0],
              ),
            ),
          ),
        ),
      ),
      leading: IconButton(
        icon: const Icon(Icons.arrow_back, color: Colors.white),
        onPressed: () => Navigator.of(context).pushNamedAndRemoveUntil('/home', (route) => false),
      ),
      title: const Text('Likes', style: TextStyle(color: Colors.white, fontWeight: FontWeight.w800, fontSize: 20)),
      iconTheme: const IconThemeData(color: Colors.white),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(72);
}
import 'dart:ui';
import 'package:flutter/material.dart';

import '../services/notification_service.dart';
import '../services/auth_service.dart';
import 'requests_screen.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../network/api_client.dart';

class NotificationsScreen extends StatefulWidget {
  const NotificationsScreen({Key? key}) : super(key: key);

  @override
  State<NotificationsScreen> createState() => _NotificationsScreenState();
}

class _NotificationsScreenState extends State<NotificationsScreen> {
  bool _loading = true;
  String? _error;
  int _page = 1;
  int _limit = 20;
  List<Map<String, dynamic>> _items = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load({bool refresh = false}) async {
    if (!refresh) {
      setState(() {
        _loading = true;
        _error = null;
      });
    }
    try {
      final resp = await notificationService.fetchNotifications(page: _page, limit: _limit);
      final rawItems = resp['items'];
      final items = (rawItems is List) ? rawItems.cast<Map<String, dynamic>>() : <Map<String, dynamic>>[];
      setState(() {
        _items = items;
      });
    } catch (e) {
      setState(() => _error = e is ApiException ? e.message : e.toString());
    } finally {
      if (!refresh) {
        setState(() => _loading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFFFFBF0),
      appBar: const PreferredSize(
        preferredSize: Size.fromHeight(72),
        child: _NotificationsAppBar(),
      ),
      body: _loading
          ? const Center(child: CircularProgressIndicator(color: Color(0xFFB71C1C)))
          : (_error != null
              ? _buildErrorState(_error!)
              : (_items.isEmpty
                  ? _buildEmptyState()
                  : RefreshIndicator(
                      color: const Color(0xFFB71C1C),
                      onRefresh: () => _load(refresh: true),
                      child: ListView.separated(
                        physics: const AlwaysScrollableScrollPhysics(),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        itemCount: _items.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 0),
                        itemBuilder: (context, i) {
                          final n = _items[i];
                          return _buildTile(n);
                        },
                      ),
                    ))),
    );
  }

  Widget _buildTile(Map<String, dynamic> n) {
    final String title = _pickString(n, ['title', 'notification_title', 'name', 'from_user_name']) ?? 'Notification';
    final String body = _pickString(n, ['body', 'message', 'content', 'text']) ?? '';
    final String time = _relativeTime(_pickString(n, ['created_at', 'createdAt', 'timestamp', 'time']));
  // Keep id utility if needed later for actions; not required for render-only
    final bool read = _pickBool(n, ['read', 'is_read', 'isRead']) ?? false;

    final Color accentStart = const Color(0xFFFFF59D);
    final Color accentEnd = const Color(0xFFE53935);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      child: InkWell(
        borderRadius: BorderRadius.circular(16),
        onTap: () {
          // If this looks like a friend/follow request notification, navigate
          // directly to the Requests screen (Received tab). Otherwise show
          // the details dialog as before.
          if (_isFriendRequest(n, title: title, body: body)) {
            final profile = AuthService().getCachedProfile();
            final currentUserId = profile != null && profile['id'] != null && profile['id'].toString().isNotEmpty
                ? profile['id'].toString()
                : 'me';
            Navigator.of(context).push(
              MaterialPageRoute(builder: (_) => RequestsScreen(currentUserId: currentUserId)),
            );
            return;
          }

          // Navigate to Chat for new message notifications
          if (_isNewMessage(n, title: title, body: body)) {
            // Navigate to chat list instead of a specific chat thread.
            // Also set a fallback flag so Home can switch to the Chat tab.
            try {
              SharedPreferences.getInstance().then((prefs) {
                try {
                  prefs.setString('pending_open_tab', 'chat');
                } catch (_) {}
              });
            } catch (_) {}
            // Clear back stack and open Home (Chat tab will be selected by HomeScreen)
            Navigator.of(context).pushNamedAndRemoveUntil('/home', (route) => false);
            return;
          }

          showDialog<void>(
            context: context,
            builder: (ctx) => AlertDialog(
              title: Text(title),
              content: Text(body.isNotEmpty ? body : 'No additional details'),
              actions: [
                TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Close')),
              ],
            ),
          );
        },
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(color: Colors.red.shade100.withOpacity(0.25), blurRadius: 18, offset: const Offset(0, 8)),
              BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 6, offset: const Offset(0, 2)),
            ],
            border: Border.all(color: Colors.white.withOpacity(0.7), width: 1),
          ),
          child: Stack(
            children: [
              // Left gradient accent bar
              Positioned(
                left: 0,
                top: 0,
                bottom: 0,
                child: Container(
                  width: 6,
                  decoration: BoxDecoration(
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(16),
                      bottomLeft: Radius.circular(16),
                    ),
                    gradient: LinearGradient(
                      colors: read ? [Colors.grey.shade200, Colors.grey.shade300] : [accentStart, accentEnd],
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                    ),
                  ),
                ),
              ),
              // Content
              Padding(
                padding: const EdgeInsets.fromLTRB(14 + 8, 12, 12, 12),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Leading icon
                    Container(
                      width: 48,
                      height: 48,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        gradient: LinearGradient(
                          colors: read ? [Colors.grey.shade200, Colors.grey.shade300] : [accentStart, accentEnd],
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                        ),
                        boxShadow: [
                          BoxShadow(color: Colors.black.withOpacity(0.06), blurRadius: 6, offset: const Offset(0, 3)),
                        ],
                      ),
                      child: Icon(read ? Icons.notifications_none : Icons.notifications, color: Colors.white),
                    ),
                    const SizedBox(width: 12),
                    // Texts
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.center,
                            children: [
                              Expanded(
                                child: Text(
                                  title,
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                  style: TextStyle(
                                    fontSize: 15.5,
                                    fontWeight: FontWeight.w800,
                                    color: read ? Colors.black87.withOpacity(0.7) : Colors.black87,
                                  ),
                                ),
                              ),
                              if (time.isNotEmpty) ...[
                                const SizedBox(width: 8),
                                Container(
                                  padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                                  decoration: BoxDecoration(
                                    color: Colors.grey.shade100,
                                    borderRadius: BorderRadius.circular(999),
                                    border: Border.all(color: Colors.grey.shade300, width: 1),
                                  ),
                                  child: Text(time, style: const TextStyle(fontSize: 11.5, color: Colors.black54, fontWeight: FontWeight.w600)),
                                ),
                              ],
                            ],
                          ),
                          const SizedBox(height: 6),
                          if (body.isNotEmpty)
                            Text(
                              body,
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                              style: TextStyle(
                                fontSize: 13.5,
                                height: 1.35,
                                color: read ? Colors.black87.withOpacity(0.6) : Colors.black87,
                              ),
                            ),
                          const SizedBox(height: 8),
                          // Unread dot only (no hint text)
                          if (!read)
                            Row(
                              children: const [
                                SizedBox(height: 4),
                                SizedBox(
                                  width: 8,
                                  height: 8,
                                  child: DecoratedBox(
                                    decoration: BoxDecoration(color: Color(0xFFE53935), shape: BoxShape.circle),
                                  ),
                                ),
                              ],
                            ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _relativeTime(String? isoOrMillis) {
    if (isoOrMillis == null || isoOrMillis.isEmpty) return '';
    DateTime? dt;
    try {
      if (RegExp(r'^\d{10,}$').hasMatch(isoOrMillis)) {
        final ms = int.tryParse(isoOrMillis);
        if (ms != null) dt = DateTime.fromMillisecondsSinceEpoch(ms);
      }
      dt ??= DateTime.tryParse(isoOrMillis);
    } catch (_) {}
    dt ??= DateTime.now();
    final diff = DateTime.now().difference(dt);
    if (diff.inMinutes < 1) return 'just now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    return '${diff.inDays}d ago';
  }

  String? _pickString(Map<String, dynamic> m, List<String> keys) {
    for (final k in keys) {
      if (m.containsKey(k) && m[k] != null) return m[k].toString();
    }
    return null;
  }

  bool? _pickBool(Map<String, dynamic> m, List<String> keys) {
    for (final k in keys) {
      if (m.containsKey(k) && m[k] != null) {
        final v = m[k];
        if (v is bool) return v;
        if (v is num) return v != 0;
        final s = v.toString().toLowerCase();
        if (s == 'true') return true;
        if (s == 'false') return false;
      }
    }
    return null;
  }

  bool _isFriendRequest(Map<String, dynamic> m, {String? title, String? body}) {
    String pickLower(List<String> keys) {
      for (final k in keys) {
        final v = m[k];
        if (v != null) return v.toString().toLowerCase();
      }
      return '';
    }

    final type = pickLower(['type', 'notification_type', 'category', 'action']);
    if (type.contains('follow_request') ||
        type.contains('friend_request') ||
        type.contains('new_follow_request') ||
        type.contains('request_received')) {
      return true;
    }

    final t = (title ?? '').toLowerCase();
    final b = (body ?? '').toLowerCase();
    final text = '$t $b';
    if (text.contains('follow request') ||
        text.contains('friend request') ||
        text.contains('requested to follow') ||
        text.contains('wants to follow') ||
        text.contains('sent you a request')) {
      return true;
    }

    // Fallback: if payload mentions relationship or request_received
    final rel = pickLower(['relationship_status']);
    if (rel == 'request_received') return true;
    return false;
  }

  bool _isNewMessage(Map<String, dynamic> m, {String? title, String? body}) {
    String pickLower(List<String> keys) {
      for (final k in keys) {
        final v = m[k];
        if (v != null) return v.toString().toLowerCase();
      }
      return '';
    }

    final type = pickLower(['type', 'notification_type', 'category', 'action', 'event']);
    if (type.contains('new_message') || type.contains('message') || type == 'chat') return true;

    final t = (title ?? '').toLowerCase();
    final b = (body ?? '').toLowerCase();
    final text = '$t $b';
    if (text.contains('new message') || text.contains('sent you a message') || text.contains('messaged you')) return true;

    // Fallback: if payload contains senderId-like keys and a message body
    final hasSender = _extractPeerId(m) != null;
    final hasMsgText = (m['message'] != null || m['content'] != null || m['text'] != null || (body != null && body.isNotEmpty));
    return hasSender && hasMsgText;
  }

  String? _extractPeerId(Map<String, dynamic> m) {
    final v = m['sender_id'] ?? m['senderId'] ?? m['from_id'] ?? m['fromId'] ?? m['user_id'] ?? m['userId'] ?? m['peer_id'] ?? m['peerId'];
    return v?.toString();
  }

  // _extractPeerName removed: not needed when navigating to chat list

  // _pickId removed as local read/unread toggle is no longer supported

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: LinearGradient(
                colors: [
                  const Color(0xFFE53935).withOpacity(0.1),
                  const Color(0xFFFFF59D).withOpacity(0.1),
                ],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
              boxShadow: [
                BoxShadow(
                  color: const Color(0xFFE53935).withOpacity(0.1),
                  blurRadius: 20,
                  spreadRadius: 5,
                ),
              ],
            ),
            child: Icon(
              Icons.notifications_none,
              size: 80,
              color: const Color(0xFFE53935).withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 24),
          const Text(
            'No Notifications',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Color(0xFFE53935),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'You\'re all caught up!',
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey[600],
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'We\'ll notify you when something new arrives',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey[500],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildErrorState(String message) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.error_outline, color: Colors.red, size: 48),
          const SizedBox(height: 12),
          Text(message, textAlign: TextAlign.center),
          const SizedBox(height: 12),
          ElevatedButton(
            onPressed: () => _load(),
            child: const Text('Retry'),
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
          ),
        ],
      ),
    );
  }
}

class _NotificationsAppBar extends StatelessWidget implements PreferredSizeWidget {
  const _NotificationsAppBar({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      centerTitle: true,
      automaticallyImplyLeading: false,
      // Use the same frosted, rounded gradient as Likes/Home for visual
      // consistency across the app (yellow -> red -> yellow).
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
      ),
      flexibleSpace: ClipRRect(
        borderRadius: const BorderRadius.only(bottomLeft: Radius.circular(18), bottomRight: Radius.circular(18)),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 8, sigmaY: 8),
          child: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: [Color(0xFFFFF59D), Color(0xFFE53935), Color(0xFFFFF59D)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                stops: [0.0, 0.5, 1.0],
              ),
            ),
          ),
        ),
      ),
      leading: IconButton(
        icon: const Icon(Icons.arrow_back, color: Colors.white),
        onPressed: () => Navigator.of(context).pushNamedAndRemoveUntil('/home', (route) => false),
      ),
      title: const Text('Notifications', style: TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
      iconTheme: const IconThemeData(color: Colors.white),
    );
  }

  @override
  Size get preferredSize => const Size.fromHeight(72);
}
import 'dart:ui';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../services/socket_service.dart';
import '../utils/custom_snackbar.dart';

class OnboardingWizardScreen extends StatefulWidget {
  const OnboardingWizardScreen({Key? key}) : super(key: key);

  @override
  State<OnboardingWizardScreen> createState() => _OnboardingWizardScreenState();
}

class _OnboardingWizardScreenState extends State<OnboardingWizardScreen> with TickerProviderStateMixin {
  int _currentStep = 0;
  String? _seekingRelation;
  String? _interestedIn;
  String? _haveKids;
  // have_kids returned to wizard; kids/bio remain removed per request
  String? _location;
  String? _dateYouReason;
  String? _height;
  List<String> _selectedHobbies = [];
  List<String> _selectedQualities = [];
  List<String> _selectedRelationshipGoals = [];
  
  late TextEditingController _locationController;
  late TextEditingController _dateYouReasonController;
  late TextEditingController _heightController;
  
  // API data lists - replacing static lists
  List<Map<String, dynamic>> _hobbiesList = [];
  List<Map<String, dynamic>> _qualitiesList = [];
  List<Map<String, dynamic>> _relationshipGoalsList = [];
  
  // Loading states
  bool _loadingHobbies = false;
  bool _loadingQualities = false;
  bool _loadingRelationshipGoals = false;
  bool _isSubmitting = false;
  
  late AnimationController _cardAnimationController;
  late AnimationController _buttonAnimationController;
  late Animation<double> _cardScaleAnimation;
  late Animation<double> _cardFadeAnimation;
  late Animation<Offset> _cardSlideAnimation;
  late PageController _heightPageController;

  @override
  void initState() {
    super.initState();
    
    // Initialize text controllers
    _locationController = TextEditingController();
    _dateYouReasonController = TextEditingController();
    _heightController = TextEditingController();
    
    // Load saved wizard state
    _loadWizardState();
    
    // Fetch API data
    _fetchHobbies();
    _fetchQualities();
    _fetchRelationshipGoals();
    
    // Card animation controller
    _cardAnimationController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    
    _cardScaleAnimation = CurvedAnimation(
      parent: _cardAnimationController,
      curve: Curves.easeOutBack,
    );
    
    _cardFadeAnimation = CurvedAnimation(
      parent: _cardAnimationController,
      curve: Curves.easeIn,
    );
    
    _cardSlideAnimation = Tween<Offset>(
      begin: const Offset(0, 0.3),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _cardAnimationController,
      curve: Curves.easeOutCubic,
    ));
    
    // Button animation controller
    _buttonAnimationController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    
    // Start animations
    _cardAnimationController.forward();
    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted) _buttonAnimationController.forward();
    });
    // Height page controller for one-item-per-scroll picker
    _heightPageController = PageController(initialPage: 0);
  }

  @override
  void dispose() {
    _cardAnimationController.dispose();
    _buttonAnimationController.dispose();
    _locationController.dispose();
    _dateYouReasonController.dispose();
    _heightController.dispose();
    _heightPageController.dispose();
    super.dispose();
  }

  void _nextStep() {
    // Close keyboard
    FocusScope.of(context).unfocus();
    
    if (_currentStep == 0 && _seekingRelation == null) {
      customSnackBar('Error', 'Please select what brings you to Anchor');
      return;
    }
    if (_currentStep == 1 && _interestedIn == null) {
      customSnackBar('Error', 'Please select who you like to meet');
      return;
    }
    if (_currentStep == 2 && (_dateYouReason == null || _dateYouReason!.isEmpty)) {
      customSnackBar('Error', 'Please enter what it\'s like to date you');
      return;
    }
    if (_currentStep == 3 && (_location == null || _location!.isEmpty)) {
      customSnackBar('Error', 'Please enter your location');
      return;
    }
    // Height is optional now; skip validation for step 4
    // If user didn't pick a height and presses Continue on the height step,
    // default to the first available height option so the wizard advances
    if (_currentStep == 4 && (_height == null || _height!.isEmpty)) {
      if (_heightOptions.isNotEmpty) {
        _updateAndSave(() {
          _height = _heightOptions[0];
          _heightController.text = _height ?? '';
          if (_heightPageController.hasClients) {
            _heightPageController.jumpToPage(0);
          }
        });
      }
    }
    if (_currentStep == 5 && _selectedHobbies.isEmpty) {
      customSnackBar('Error', 'Please select at least one hobby');
      return;
    }
    if (_currentStep == 6 && (_haveKids == null || _haveKids!.isEmpty)) {
      customSnackBar('Error', 'Please select whether you have children');
      return;
    }
    if (_currentStep == 7 && _selectedRelationshipGoals.isEmpty) {
      customSnackBar('Error', 'Please select a relationship goal');
      return;
    }
    if (_currentStep == 8 && _selectedQualities.isEmpty) {
      customSnackBar('Error', 'Please select at least one partner quality');
      return;
    }
    
    if (_currentStep < 8) {
      setState(() {
        _currentStep++;
      });
      // Save wizard state
      _saveWizardState();
      // Restart animations for new step
      _cardAnimationController.reset();
      _buttonAnimationController.reset();
      _cardAnimationController.forward();
      Future.delayed(const Duration(milliseconds: 200), () {
        if (mounted) _buttonAnimationController.forward();
      });
    } else {
      _completeOnboarding();
    }
  }

  void _previousStep() {
    // Close keyboard
    FocusScope.of(context).unfocus();
    
    if (_currentStep > 0) {
      setState(() {
        _currentStep--;
      });
      // Save wizard state
      _saveWizardState();
      // Restart animations
      _cardAnimationController.reset();
      _buttonAnimationController.reset();
      _cardAnimationController.forward();
      Future.delayed(const Duration(milliseconds: 200), () {
        if (mounted) _buttonAnimationController.forward();
      });
    }
  }

  void _showError(String message) {
    customSnackBar('Error', message);
  }

  /// Save wizard state to SharedPreferences
  Future<void> _saveWizardState() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      final wizardData = {
        'currentStep': _currentStep,
        'seekingRelation': _seekingRelation,
        'interestedIn': _interestedIn,
        'haveKids': _haveKids,
        'location': _location,
        'height': _height,
        'dateYouReason': _dateYouReason,
        'selectedHobbies': _selectedHobbies,
        'selectedQualities': _selectedQualities,
        'selectedRelationshipGoals': _selectedRelationshipGoals,
      };
      
      await prefs.setString('wizard_state', jsonEncode(wizardData));
    } catch (e) {
      // removed debug print
    }
  }

  /// Load wizard state from SharedPreferences
  Future<void> _loadWizardState() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final wizardDataJson = prefs.getString('wizard_state');
      
      if (wizardDataJson != null) {
        final wizardData = jsonDecode(wizardDataJson) as Map<String, dynamic>;
        
          if (mounted) {
            setState(() {
              _currentStep = wizardData['currentStep'] as int? ?? 0;
              _seekingRelation = wizardData['seekingRelation'] as String?;
              _interestedIn = wizardData['interestedIn'] as String?;
              _haveKids = wizardData['haveKids'] as String?;
              _location = wizardData['location'] as String?;
              _height = wizardData['height'] as String?;
              _dateYouReason = wizardData['dateYouReason'] as String?;
              _selectedHobbies = List<String>.from(wizardData['selectedHobbies'] as List? ?? []);
              _selectedQualities = List<String>.from(wizardData['selectedQualities'] as List? ?? []);
              _selectedRelationshipGoals = List<String>.from(wizardData['selectedRelationshipGoals'] as List? ?? []);
            
              // Restore text controller values
              _locationController.text = _location ?? '';
              _heightController.text = _height ?? '';
              _dateYouReasonController.text = _dateYouReason ?? '';
            });

            // After rebuild, move height page controller to the saved height if present
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (_height != null) {
                final idx = _heightOptions.indexOf(_height!);
                if (idx >= 0 && _heightPageController.hasClients) {
                  _heightPageController.jumpToPage(idx);
                }
              }
            });
          }
      }
    } catch (e) {
      // removed debug print
    }
  }

  /// Clear saved wizard state
  Future<void> _clearWizardState() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('wizard_state');
    } catch (e) {
      // removed debug print
    }
  }

  /// Helper to update state and save wizard progress
  void _updateAndSave(VoidCallback updateFn) {
    setState(updateFn);
    _saveWizardState();
  }

  Future<void> _completeOnboarding() async {
    try {
      // Set loading state
      setState(() {
        _isSubmitting = true;
      });
      
      // Prepare the request body
      // Map UI values to API-expected values when necessary
      final interestedInForApi = (_interestedIn == 'others') ? 'other' : _interestedIn;

      final Map<String, dynamic> body = {
        'location': _location,
        'height': _height,
        'seeking_relation': _seekingRelation,
        'interested_in': interestedInForApi,
        'have_kids': _haveKids,
        'date_you_reason': _dateYouReason,
        'hobbies': _selectedHobbies,
        'relationship_goals': _selectedRelationshipGoals,
        'partner_qualities': _selectedQualities,
      };
      
      // Call the profile update API
      await AuthService().updateProfile(body);
      
      if (!mounted) return;
      
      // Show success message
      customSnackBar('Success', 'Profile completed successfully');
      
      // Clear wizard state from SharedPreferences
      await _clearWizardState();
      
      // Navigate to home screen (which includes browse as the default tab)
      if (mounted) {
        // Connect socket before navigating so user appears online
        try {
          await SocketService().connect();
        } catch (_) {}
        Navigator.of(context).pushReplacementNamed('/home');
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
        _showError('Failed to complete onboarding: $e');
      }
      // removed debug print
    }
  }

  Future<void> _fetchHobbies() async {
    try {
      setState(() {
        _loadingHobbies = true;
      });
      
      final response = await AuthService().getHobbies();
      
      if (!mounted) return;
      
      // Parse response - support both { data: [...] } and direct array
      List<Map<String, dynamic>> hobbies = [];
      if (response is Map<String, dynamic>) {
        if (response.containsKey('data') && response['data'] is List) {
          hobbies = List<Map<String, dynamic>>.from(
            (response['data'] as List).map((item) => 
              item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
            )
          );
        } else if (response.containsKey('hobbies') && response['hobbies'] is List) {
          hobbies = List<Map<String, dynamic>>.from(
            (response['hobbies'] as List).map((item) => 
              item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
            )
          );
        }
      } else if (response is List) {
        hobbies = List<Map<String, dynamic>>.from(
          response.map((item) => 
            item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
          )
        );
      }
      
      setState(() {
        _hobbiesList = hobbies;
        _loadingHobbies = false;
      });
    } catch (e) {
      if (mounted) {
        setState(() {
          _loadingHobbies = false;
        });
      }
      // removed debug print
    }
  }

  Future<void> _fetchQualities() async {
    try {
      setState(() {
        _loadingQualities = true;
      });
      
      final response = await AuthService().getPartnerQualities();
      
      if (!mounted) return;
      
      // Parse response - support both { data: [...] } and direct array
      List<Map<String, dynamic>> qualities = [];
      if (response is Map<String, dynamic>) {
        if (response.containsKey('data') && response['data'] is List) {
          qualities = List<Map<String, dynamic>>.from(
            (response['data'] as List).map((item) => 
              item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
            )
          );
        } else if (response.containsKey('qualities') && response['qualities'] is List) {
          qualities = List<Map<String, dynamic>>.from(
            (response['qualities'] as List).map((item) => 
              item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
            )
          );
        }
      } else if (response is List) {
        qualities = List<Map<String, dynamic>>.from(
          response.map((item) => 
            item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
          )
        );
      }
      
      setState(() {
        _qualitiesList = qualities;
        _loadingQualities = false;
      });
    } catch (e) {
      if (mounted) {
        setState(() {
          _loadingQualities = false;
        });
      }
      // removed debug print
    }
  }

  Future<void> _fetchRelationshipGoals() async {
    try {
      setState(() {
        _loadingRelationshipGoals = true;
      });
      
      final response = await AuthService().getRelationshipGoals();
      
      if (!mounted) return;
      
      // Parse response - support both { data: [...] } and direct array
      List<Map<String, dynamic>> goals = [];
      if (response is Map<String, dynamic>) {
        if (response.containsKey('data') && response['data'] is List) {
          goals = List<Map<String, dynamic>>.from(
            (response['data'] as List).map((item) => 
              item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
            )
          );
        } else if (response.containsKey('goals') && response['goals'] is List) {
          goals = List<Map<String, dynamic>>.from(
            (response['goals'] as List).map((item) => 
              item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
            )
          );
        }
      } else if (response is List) {
        goals = List<Map<String, dynamic>>.from(
          response.map((item) => 
            item is Map<String, dynamic> ? item : {'id': item, 'name': item.toString()}
          )
        );
      }
      
      setState(() {
        _relationshipGoalsList = goals;
        _loadingRelationshipGoals = false;
      });
    } catch (e) {
      if (mounted) {
        setState(() {
          _loadingRelationshipGoals = false;
        });
      }
      // removed debug print
    }
  }

  // Centralized height options so other methods (controllers) can reference them
  List<String> get _heightOptions => [
        "4'10\"",
        "4'11\"",
        "5'0\"",
        "5'1\"",
        "5'2\"",
        "5'3\"",
        "5'4\"",
        "5'5\"",
        "5'6\"",
        "5'7\"",
        "5'8\"",
        "5'9\"",
        "5'10\"",
        "5'11\"",
        "6'0\"",
        "6'1\"",
        "6'2\"",
        "6'3\"",
        "6'4\"",
        "6'5\"",
        "6'6\"",
        "6'7\"",
        "6'8\"",
      ];

  Widget _buildOptionCard({
    required String title,
    required String subtitle,
    required IconData icon,
    required bool isSelected,
    required VoidCallback onTap,
    required Color color,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
        margin: const EdgeInsets.symmetric(vertical: 10, horizontal: 20),
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          gradient: isSelected
              ? LinearGradient(
                  colors: [color.withOpacity(0.9), color],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                )
              : LinearGradient(
                  colors: [Colors.white, Colors.white],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(
            color: isSelected ? color : Colors.grey.withOpacity(0.2),
            width: isSelected ? 3 : 2,
          ),
          boxShadow: [
            BoxShadow(
              color: isSelected ? color.withOpacity(0.3) : Colors.black.withOpacity(0.05),
              blurRadius: isSelected ? 20 : 10,
              offset: const Offset(0, 5),
              spreadRadius: isSelected ? 2 : 0,
            ),
          ],
        ),
        child: Row(
          children: [
            // Icon container
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: isSelected ? Colors.white.withOpacity(0.2) : color.withOpacity(0.1),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: isSelected ? Colors.white.withOpacity(0.3) : color.withOpacity(0.2),
                  width: 2,
                ),
              ),
              child: Icon(
                icon,
                size: 36,
                color: isSelected ? Colors.white : color,
              ),
            ),
            const SizedBox(width: 20),
            // Text content
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                      color: isSelected ? Colors.white : Colors.black87,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    subtitle,
                    style: TextStyle(
                      fontSize: 14,
                      color: isSelected ? Colors.white.withOpacity(0.9) : Colors.grey.shade600,
                    ),
                  ),
                ],
              ),
            ),
            // Checkmark
            AnimatedContainer(
              duration: const Duration(milliseconds: 300),
              width: 32,
              height: 32,
              decoration: BoxDecoration(
                color: isSelected ? Colors.white : Colors.transparent,
                shape: BoxShape.circle,
                border: Border.all(
                  color: isSelected ? Colors.white : Colors.grey.withOpacity(0.3),
                  width: 2,
                ),
              ),
              child: isSelected
                  ? Icon(Icons.check, color: color, size: 20)
                  : null,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStep0() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        _buildOptionCard(
          title: 'Date',
          subtitle: 'Looking for romantic connections',
          icon: Icons.favorite,
          isSelected: _seekingRelation == 'date',
          onTap: () => _updateAndSave(() => _seekingRelation = 'date'),
          color: const Color(0xFFE53935),
        ),
        _buildOptionCard(
          title: 'BFF',
          subtitle: 'Looking for new friendships',
          icon: Icons.people,
          isSelected: _seekingRelation == 'bff',
          onTap: () => _updateAndSave(() => _seekingRelation = 'bff'),
          color: const Color(0xFFFFD54D),
        ),
      ],
    );
  }

  Widget _buildStep1() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        _buildOptionCard(
          title: 'Male',
          subtitle: 'Interested in meeting men',
          icon: Icons.male,
          isSelected: _interestedIn == 'male',
          onTap: () => _updateAndSave(() => _interestedIn = 'male'),
          color: const Color(0xFF2196F3),
        ),
        _buildOptionCard(
          title: 'Female',
          subtitle: 'Interested in meeting women',
          icon: Icons.female,
          isSelected: _interestedIn == 'female',
          onTap: () => _updateAndSave(() => _interestedIn = 'female'),
          color: const Color(0xFFE91E63),
        ),
        _buildOptionCard(
          title: 'Others',
          subtitle: 'Open to all connections',
          icon: Icons.diversity_3,
          isSelected: _interestedIn == 'others',
          onTap: () => _updateAndSave(() => _interestedIn = 'others'),
          color: const Color(0xFF9C27B0),
        ),
      ],
    );
  }

  Widget _buildMultiSelectChip({
    required String label,
    required bool isSelected,
    required VoidCallback onTap,
    required Color color,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        margin: const EdgeInsets.all(6),
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
        decoration: BoxDecoration(
          gradient: isSelected
              ? LinearGradient(
                  colors: [color.withOpacity(0.9), color],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                )
              : null,
          color: isSelected ? null : Colors.white,
          borderRadius: BorderRadius.circular(25),
          border: Border.all(
            color: isSelected ? color : Colors.grey.withOpacity(0.3),
            width: isSelected ? 2 : 1.5,
          ),
          boxShadow: [
            BoxShadow(
              color: isSelected ? color.withOpacity(0.3) : Colors.black.withOpacity(0.05),
              blurRadius: isSelected ? 12 : 6,
              offset: const Offset(0, 3),
            ),
          ],
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (isSelected)
              Padding(
                padding: const EdgeInsets.only(right: 8),
                child: Icon(
                  Icons.check_circle,
                  size: 18,
                  color: Colors.white,
                ),
              ),
            Text(
              label,
              style: TextStyle(
                fontSize: 15,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.w500,
                color: isSelected ? Colors.white : Colors.black87,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildStep2() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: _loadingHobbies
          ? const SizedBox(
              height: 200,
              child: Center(child: CircularProgressIndicator()),
            )
          : Column(
              children: [
                const SizedBox(height: 24),
                Wrap(
                  alignment: WrapAlignment.center,
                  children: _hobbiesList.map((hobby) {
                    final hobbyId = hobby['id']?.toString() ?? '';
                    final hobbyName = hobby['name']?.toString() ?? '';
                    return _buildMultiSelectChip(
                      label: hobbyName,
                      isSelected: _selectedHobbies.contains(hobbyId),
                      onTap: () {
                        setState(() {
                          if (_selectedHobbies.contains(hobbyId)) {
                            _selectedHobbies.remove(hobbyId);
                          } else {
                            _selectedHobbies.add(hobbyId);
                          }
                        });
                      },
                      color: Colors.orange,
                    );
                  }).toList(),
                ),
                const SizedBox(height: 20),
              ],
            ),
    );
  }

  Widget _buildStep3() {

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: SingleChildScrollView(
        child: Column(
          children: [
            const SizedBox(height: 12),
            // Height selector: vertical pager showing one item per scroll (no surrounding boxes)
            SizedBox(
              height: 200,
              child: Stack(
                alignment: Alignment.center,
                children: [
                  PageView.builder(
                    controller: _heightPageController,
                    scrollDirection: Axis.vertical,
                    itemCount: _heightOptions.length,
                    onPageChanged: (index) {
                      _updateAndSave(() => _height = _heightOptions[index]);
                    },
                    itemBuilder: (context, index) {
                      final h = _heightOptions[index];
                      final selectedFlag = _height == h;
                      return Center(
                        child: GestureDetector(
                          onTap: () => _updateAndSave(() => _height = h),
                          child: Text(
                            h,
                            textAlign: TextAlign.center,
                            style: TextStyle(
                              color: Colors.black,
                              fontSize: 20,
                              fontWeight: selectedFlag ? FontWeight.w700 : FontWeight.w500,
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                  // Small chevron indicators
                  Positioned(
                    top: 8,
                    child: Icon(Icons.keyboard_arrow_up, color: Colors.grey.shade400, size: 20),
                  ),
                  Positioned(
                    bottom: 8,
                    child: Icon(Icons.keyboard_arrow_down, color: Colors.grey.shade400, size: 20),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHaveKidsStep() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: Column(
        children: [
          const SizedBox(height: 24),
          // Replace dropdown with option cards matching the gender selection style
          _buildOptionCard(
            title: 'Have kids',
            subtitle: 'You have one or more children',
            icon: Icons.child_care,
            isSelected: _haveKids == 'Have kids',
            onTap: () => _updateAndSave(() => _haveKids = 'Have kids'),
            color: const Color(0xFF4CAF50),
          ),
          _buildOptionCard(
            title: "Don't have kids",
            subtitle: 'You do not have children',
            icon: Icons.family_restroom,
            isSelected: _haveKids == "Don't have kids",
            onTap: () => _updateAndSave(() => _haveKids = "Don't have kids"),
            color: const Color(0xFF9E9E9E),
          ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }

  // previous 'Have kids' and 'Want kids' steps removed per product request

  Widget _buildStep6() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: SingleChildScrollView(
        child: Column(
          children: [
            const SizedBox(height: 24),
            TextField(
              controller: _dateYouReasonController,
              onChanged: (value) => _updateAndSave(() => _dateYouReason = value),
              maxLines: 4,
              style: const TextStyle(
                color: Colors.black,
                fontSize: 16,
              ),
              cursorColor: Colors.orange,
              decoration: InputDecoration(
                hintText: 'Describe what you\'re like as a partner...',
                hintStyle: TextStyle(
                  color: Colors.grey.shade500,
                  fontSize: 16,
                ),
                filled: true,
                fillColor: Colors.white,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(color: Colors.orange, width: 2),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(color: Colors.orange, width: 2),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(color: Colors.orange, width: 3),
                ),
                contentPadding: const EdgeInsets.all(16),
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  Widget _buildStep7() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: SingleChildScrollView(
        child: Column(
          children: [
            TextField(
              controller: _locationController,
              onChanged: (value) => _updateAndSave(() => _location = value),
              style: const TextStyle(
                color: Colors.black,
                fontSize: 16,
              ),
              cursorColor: Colors.orange,
              decoration: InputDecoration(
                hintText: 'e.g. New York, USA',
                hintStyle: TextStyle(
                  color: Colors.grey.shade500,
                  fontSize: 16,
                ),
                filled: true,
                fillColor: Colors.white,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(color: Colors.orange, width: 2),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(color: Colors.orange, width: 2),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(16),
                  borderSide: const BorderSide(color: Colors.orange, width: 3),
                ),
                contentPadding: const EdgeInsets.all(16),
              ),
            ),
            const SizedBox(height: 20),
          ],
        ),
      ),
    );
  }

  // previous 'Bio' step removed per product request

  Widget _buildStep9() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: _loadingRelationshipGoals
          ? const SizedBox(
              height: 200,
              child: Center(child: CircularProgressIndicator()),
            )
          : Column(
              children: [
                const SizedBox(height: 24),
                Wrap(
                  alignment: WrapAlignment.center,
                    children: _relationshipGoalsList.map((goal) {
                      final goalId = goal['id']?.toString() ?? '';
                      final goalName = goal['name']?.toString() ?? '';
                      return _buildMultiSelectChip(
                        label: goalName,
                        isSelected: _selectedRelationshipGoals.contains(goalId),
                        onTap: () {
                          setState(() {
                            // Enforce single-select: if tapping the currently selected item, deselect it,
                            // otherwise replace selection with the tapped item.
                            if (_selectedRelationshipGoals.contains(goalId)) {
                              _selectedRelationshipGoals.remove(goalId);
                            } else {
                              _selectedRelationshipGoals = [goalId];
                            }
                          });
                        },
                        color: Colors.deepPurple,
                      );
                    }).toList(),
                ),
                const SizedBox(height: 20),
              ],
            ),
    );
  }

  Widget _buildStep10() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: _loadingQualities
          ? const SizedBox(
              height: 200,
              child: Center(child: CircularProgressIndicator()),
            )
          : Column(
              children: [
                const SizedBox(height: 24),
                Wrap(
                  alignment: WrapAlignment.center,
                  children: _qualitiesList.map((quality) {
                    final qualityId = quality['id']?.toString() ?? '';
                    final qualityName = quality['name']?.toString() ?? '';
                    return _buildMultiSelectChip(
                      label: qualityName,
                      isSelected: _selectedQualities.contains(qualityId),
                      onTap: () {
                        setState(() {
                          if (_selectedQualities.contains(qualityId)) {
                            _selectedQualities.remove(qualityId);
                          } else {
                            _selectedQualities.add(qualityId);
                          }
                        });
                      },
                      color: Colors.purple,
                    );
                  }).toList(),
                ),
                const SizedBox(height: 20),
              ],
            ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.of(context).size;
    
    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: SystemUiOverlayStyle.dark.copyWith(statusBarColor: Colors.transparent),
      child: Scaffold(
        body: Container(
          width: size.width,
          height: size.height,
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              colors: [Color(0xFFFFFBF0), Color(0xFFFFF3E0), Color(0xFFFFE0B2)],
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
            ),
          ),
          child: SafeArea(
            child: Column(
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 30),
                  child: Column(
                    children: [
                      // Logo with animation
                      TweenAnimationBuilder<double>(
                        tween: Tween(begin: 0.0, end: 1.0),
                        duration: const Duration(milliseconds: 800),
                        curve: Curves.elasticOut,
                        builder: (context, value, child) {
                          return Transform.scale(
                            scale: value,
                            child: Container(
                              padding: const EdgeInsets.all(20),
                              decoration: BoxDecoration(
                                gradient: const LinearGradient(
                                  colors: [Color(0xFFFFD54D), Color(0xFFE53935)],
                                  begin: Alignment.topLeft,
                                  end: Alignment.bottomRight,
                                ),
                                shape: BoxShape.circle,
                                boxShadow: [
                                  BoxShadow(
                                    color: const Color(0xFFE53935).withOpacity(0.3),
                                    blurRadius: 20,
                                    spreadRadius: 5,
                                  ),
                                ],
                              ),
                              child: const Icon(
                                Icons.anchor,
                                size: 50,
                                color: Colors.white,
                              ),
                            ),
                          );
                        },
                      ),
                      const SizedBox(height: 24),
                      // Title
                      TweenAnimationBuilder<double>(
                        tween: Tween(begin: 0.0, end: 1.0),
                        duration: const Duration(milliseconds: 600),
                        builder: (context, value, child) {
                          return Opacity(
                            opacity: value,
                            child: Transform.translate(
                              offset: Offset(0, 20 * (1 - value)),
                              child: child,
                            ),
                          );
                        },
                        child: Text(
              _currentStep == 0 ? 'What brings you to Anchor?'
              : _currentStep == 1 ? 'Who you like to meet?'
              : _currentStep == 2 ? 'Tell us about yourself'
              : _currentStep == 3 ? 'Where are you located?'
              : _currentStep == 4 ? 'What is your height?'
              : _currentStep == 5 ? 'Your Hobbies'
              : _currentStep == 6 ? 'Do you have children?'
              : _currentStep == 7 ? 'Relationship Goals'
              : 'Partner Qualities',
                          style: const TextStyle(
                            fontSize: 28,
                            fontWeight: FontWeight.bold,
                            color: Color(0xFFE53935),
                          ),
                          textAlign: TextAlign.center,
                        ),
                      ),
                      const SizedBox(height: 12),
                      // Subtitle
                      TweenAnimationBuilder<double>(
                        tween: Tween(begin: 0.0, end: 1.0),
                        duration: const Duration(milliseconds: 800),
                        builder: (context, value, child) {
                          return Opacity(
                            opacity: value,
                            child: Transform.translate(
                              offset: Offset(0, 20 * (1 - value)),
                              child: child,
                            ),
                          );
                        },
            child: Text(
              _currentStep == 0
                ? 'Help us personalize your experience'
                : _currentStep == 1
                  ? 'This helps us find the best matches for you'
                  : _currentStep == 2
                    ? 'What is it like to date you?'
                    : _currentStep == 3
                      ? 'Where can we find you?'
                      : _currentStep == 4
                        ? 'How tall are you?'
                        : _currentStep == 5
                          ? 'Share what you love to do'
                          : _currentStep == 6
                            ? 'Let us know if you have children'
                            : _currentStep == 7
                              ? 'What are you looking for?'
                              : 'What do you value in a partner?',
              style: TextStyle(
              fontSize: 16,
              color: Colors.grey.shade700,
              ),
              textAlign: TextAlign.center,
            ),
                      ),
                      const SizedBox(height: 20),
                      // Progress indicator (9 steps)
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: List.generate(9, (index) {
                          return AnimatedContainer(
                            duration: const Duration(milliseconds: 300),
                            margin: const EdgeInsets.symmetric(horizontal: 4),
                            width: _currentStep == index ? 40 : 12,
                            height: 12,
                            decoration: BoxDecoration(
                              gradient: _currentStep >= index
                                  ? const LinearGradient(
                                      colors: [Color(0xFFFFD54D), Color(0xFFE53935)],
                                      begin: Alignment.topLeft,
                                      end: Alignment.bottomRight,
                                    )
                                  : null,
                              color: _currentStep < index ? Colors.grey.withOpacity(0.3) : null,
                              borderRadius: BorderRadius.circular(8),
                              boxShadow: _currentStep == index
                                  ? [
                                      BoxShadow(
                                        color: const Color(0xFFE53935).withOpacity(0.4),
                                        blurRadius: 8,
                                        offset: const Offset(0, 2),
                                      ),
                                    ]
                                  : null,
                            ),
                          );
                        }),
                      ),
                    ],
                  ),
                ),
                
                // Content
                Expanded(
                  child: SlideTransition(
                    position: _cardSlideAnimation,
                    child: FadeTransition(
                      opacity: _cardFadeAnimation,
                      child: ScaleTransition(
                        scale: _cardScaleAnimation,
              child: SingleChildScrollView(
                          physics: const BouncingScrollPhysics(),
              child: _currentStep == 0
                ? _buildStep0()
                : _currentStep == 1
                  ? _buildStep1()
                  : _currentStep == 2
                    ? _buildStep6()
                    : _currentStep == 3
                      ? _buildStep7()
                      : _currentStep == 4
                        ? _buildStep3()
                        : _currentStep == 5
                          ? _buildStep2()
                          : _currentStep == 6
                            ? _buildHaveKidsStep()
                            : _currentStep == 7
                              ? _buildStep9()
                              : _buildStep10(),
                        ),
                      ),
                    ),
                  ),
                ),
                
                // Navigation buttons
                Padding(
                  padding: const EdgeInsets.all(20),
                  child: FadeTransition(
                    opacity: _buttonAnimationController,
                    child: Row(
                      children: [
                        // Back button
                        if (_currentStep > 0)
                          Expanded(
                            child: OutlinedButton(
                              style: OutlinedButton.styleFrom(
                                side: const BorderSide(color: Color(0xFFE53935), width: 2),
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(16),
                                ),
                              ),
                              onPressed: _previousStep,
                              child: const Text(
                                'Back',
                                style: TextStyle(
                                  fontSize: 18,
                                  fontWeight: FontWeight.bold,
                                  color: Color(0xFFE53935),
                                ),
                              ),
                            ),
                          ),
                        if (_currentStep > 0) const SizedBox(width: 16),
                        // Continue button
                        Expanded(
                          flex: _currentStep == 0 ? 1 : 1,
                          child: Container(
                            decoration: BoxDecoration(
                              gradient: const LinearGradient(
                                colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
                                begin: Alignment.topLeft,
                                end: Alignment.bottomRight,
                              ),
                              borderRadius: BorderRadius.circular(16),
                              boxShadow: [
                                BoxShadow(
                                  color: const Color(0xFFE53935).withOpacity(0.4),
                                  blurRadius: 12,
                                  offset: const Offset(0, 6),
                                ),
                              ],
                            ),
                            child: ElevatedButton(
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Colors.transparent,
                                shadowColor: Colors.transparent,
                                padding: const EdgeInsets.symmetric(vertical: 16),
                                shape: RoundedRectangleBorder(
                                  borderRadius: BorderRadius.circular(16),
                                ),
                              ),
                              onPressed: _isSubmitting ? null : _nextStep,
                              child: _isSubmitting
                                  ? const SizedBox(
                                      height: 24,
                                      width: 24,
                                      child: CircularProgressIndicator(
                                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                                        strokeWidth: 2,
                                      ),
                                    )
                                  : Row(
                                      mainAxisAlignment: MainAxisAlignment.center,
                                      children: [
                                        Text(
                                          _currentStep < 9 ? 'Continue' : 'Get Started',
                                          style: const TextStyle(
                                            fontSize: 18,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.white,
                                          ),
                                        ),
                                        const SizedBox(width: 8),
                                        const Icon(Icons.arrow_forward, color: Colors.white),
                                      ],
                                    ),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'dart:ui';

import '../models/profile.dart';
import '../services/auth_service.dart';
import '../services/follow_service.dart';
import '../services/match_service.dart';
import '../utils/custom_snackbar.dart';

class ProfileDetailScreen extends StatefulWidget {
  final Profile profile;
  final bool requested;
  final bool hideFollowButton;
  // Optional callback invoked when a follow request is successfully sent.
  // Receives the profile id that was requested.
  final void Function(String profileId)? onFollow;
  const ProfileDetailScreen({
    Key? key, 
    required this.profile, 
    this.requested = false, 
    this.hideFollowButton = false,
    this.onFollow
  }) : super(key: key);

  @override
  State<ProfileDetailScreen> createState() => _ProfileDetailScreenState();
}

class _ProfileDetailScreenState extends State<ProfileDetailScreen> {
  late bool _requested;
  bool _loading = false;

  @override
  void initState() {
    super.initState();
    _requested = widget.requested;
  }

  Future<void> _sendFollow() async {
    if (_requested) return;
    setState(() => _loading = true);
    try {
      await followService.follow(widget.profile.id);
      // optimistic local update
      MatchService.sendFollowRequest(AuthService().getCachedProfile()?['id']?.toString() ?? 'me', widget.profile.id);
      if (!mounted) return;
      setState(() => _requested = true);
        // notify caller (browse/requests screens) so they can update local UI
        try {
          widget.onFollow?.call(widget.profile.id);
        } catch (_) {}
      customSnackBar('Success', 'Follow request sent to ${widget.profile.name}');
    } catch (e) {
      if (!mounted) return;
      customSnackBar('Error', e is Exception ? e.toString() : 'Failed to send follow request');
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final profile = widget.profile;
    final displayName = profile.name.isNotEmpty ? profile.name : 'User';
    // If user uploaded an imageUrl, use it. Otherwise avoid showing
    // local placeholder assets (image1/image2). We'll render a neutral
    // background and an Icon instead so the UI doesn't display app
    // placeholder pictures for users without uploaded photos.
    final bool hasImage = profile.imageUrl.isNotEmpty;
    // Responsive sizing: use screen width to compute a good height so the
    // top of the image is visible on narrow screens. Also take status bar
    // padding into account for a small spacer so the image doesn't sit
    // under the app bar or notch.
    final screenWidth = MediaQuery.of(context).size.width;
  final topPadding = MediaQuery.of(context).padding.top;
  // Small upward nudge: reduce the spacer so the image sits slightly higher.
  final spacerHeight = (topPadding - 6) < 4.0 ? 4.0 : (topPadding - 6);
  final avatarHeight = (screenWidth * 0.75).clamp(220.0, 420.0);

    return Scaffold(
      backgroundColor: const Color(0xFFFFFBF0),
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(72),
        child: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          centerTitle: true,
          automaticallyImplyLeading: true,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.only(
              bottomLeft: Radius.circular(18),
              bottomRight: Radius.circular(18),
            ),
          ),
          flexibleSpace: ClipRRect(
            borderRadius: const BorderRadius.only(
              bottomLeft: Radius.circular(18),
              bottomRight: Radius.circular(18),
            ),
            child: BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 10.0, sigmaY: 10.0),
              child: Container(
                decoration: const BoxDecoration(
                  gradient: LinearGradient(
                    colors: [Color(0xFFFFD54D), Color(0xFFE53935), Color(0xFFFFD54D)],
                    stops: [0.0, 0.5, 1.0],
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                  ),
                ),
              ),
            ),
          ),
          title: Padding(
            padding: const EdgeInsets.only(top: 10.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(displayName, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.w700, fontSize: 20)),
                const SizedBox(height: 2),
                const Text('Profile', style: TextStyle(color: Colors.white70, fontSize: 14, fontWeight: FontWeight.w600)),
              ],
            ),
          ),
        ),
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Profile avatar - spaced down slightly so it doesn't sit under the app bar
              SizedBox(height: spacerHeight),
              // Profile avatar - edge to edge with app bar
              Container(
              height: avatarHeight,
              width: double.infinity,
              decoration: BoxDecoration(
                boxShadow: [
                  BoxShadow(
                    color: Colors.red.shade200.withOpacity(0.3),
                    blurRadius: 20,
                    spreadRadius: 0,
                    offset: const Offset(0, 10),
                  ),
                  BoxShadow(
                    color: Colors.black.withOpacity(0.15),
                    blurRadius: 15,
                    offset: const Offset(0, 8),
                  ),
                ],
              ),
              child: hasImage
                  ? Image.network(
                      profile.imageUrl,
                      fit: BoxFit.cover,
                      alignment: Alignment.topCenter,
                      width: double.infinity,
                    )
                  : Container(
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          colors: [Colors.red.shade100, Colors.yellow.shade100],
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                        ),
                      ),
                      child: const Center(
                        child: Icon(Icons.person, color: Colors.white70, size: 96),
                      ),
                    ),
            ),

            const SizedBox(height: 20),

            // Main content card for info and actions
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 20.0),
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(24),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.red.shade100.withOpacity(0.3),
                      blurRadius: 25,
                      spreadRadius: 0,
                      offset: const Offset(0, 10),
                    ),
                    BoxShadow(
                      color: Colors.black.withOpacity(0.08),
                      blurRadius: 15,
                      spreadRadius: -2,
                      offset: const Offset(0, 8),
                    ),
                  ],
                  border: Border.all(
                    color: Colors.white.withOpacity(0.8),
                    width: 1.5,
                  ),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Center(
                        child: Text(
                          displayName,
                          style: const TextStyle(
                            fontSize: 26,
                            fontWeight: FontWeight.w900,
                            color: Colors.black87,
                            letterSpacing: 0.5,
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                      Center(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [Color(0xFFFFF59D).withOpacity(0.3), Color(0xFFE53935).withOpacity(0.2)],
                              begin: Alignment.topLeft,
                              end: Alignment.bottomRight,
                            ),
                            borderRadius: BorderRadius.circular(20),
                          ),
                          child: Text(
                            '${profile.age} years old',
                            style: const TextStyle(
                              color: Colors.black87,
                              fontSize: 15,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(height: 24),
                      _buildInfoSection(profile),
                      const SizedBox(height: 24),
                      if (!widget.hideFollowButton)
                        _requested
                            ? Container(
                                height: 52,
                                decoration: BoxDecoration(
                                  color: Colors.grey.shade100,
                                  borderRadius: BorderRadius.circular(26),
                                  border: Border.all(color: Colors.green.shade200, width: 2),
                                ),
                                child: Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: const [
                                    Icon(Icons.check_circle, color: Colors.green, size: 24),
                                    SizedBox(width: 10),
                                    Text(
                                      'Requested',
                                      style: TextStyle(
                                        color: Colors.black87,
                                        fontSize: 16,
                                        fontWeight: FontWeight.w700,
                                        letterSpacing: 0.5,
                                      ),
                                    ),
                                  ],
                                ),
                              )
                            : Container(
                                height: 52,
                                decoration: BoxDecoration(
                                  gradient: const LinearGradient(
                                    colors: [Color(0xFFE53935), Color(0xFFD32F2F)],
                                    begin: Alignment.topCenter,
                                    end: Alignment.bottomCenter,
                                  ),
                                  borderRadius: BorderRadius.circular(26),
                                  boxShadow: [
                                    BoxShadow(
                                      color: Colors.red.shade300.withOpacity(0.5),
                                      blurRadius: 15,
                                      offset: const Offset(0, 6),
                                    ),
                                    BoxShadow(
                                      color: Colors.black.withOpacity(0.1),
                                      blurRadius: 10,
                                      offset: const Offset(0, 4),
                                    ),
                                  ],
                                ),
                                child: ElevatedButton.icon(
                                  onPressed: _loading ? () {} : _sendFollow,
                                  icon: _loading
                                      ? const SizedBox(
                                          height: 20,
                                          width: 20,
                                          child: CircularProgressIndicator(
                                            color: Colors.white,
                                            strokeWidth: 2.5,
                                          ),
                                        )
                                      : const Icon(Icons.person_add, color: Colors.white, size: 22),
                                  label: Text(
                                    _loading ? 'Sending...' : 'Follow',
                                    style: const TextStyle(
                                      fontSize: 16,
                                      fontWeight: FontWeight.w700,
                                      letterSpacing: 0.5,
                                    ),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: Colors.transparent,
                                    foregroundColor: Colors.white,
                                    elevation: 0,
                                    shadowColor: Colors.transparent,
                                    shape: RoundedRectangleBorder(
                                      borderRadius: BorderRadius.circular(26),
                                    ),
                                  ),
                                ),
                              ),
                    ],
                  ),
                ),
              ),
            ),
            const SizedBox(height: 30),
          ],
        ),
      ),
    );
  }
}

Widget _buildInfoSection(Profile profile) {
  return Builder(builder: (ctx) {

    // Try to read server-provided "date_you_reason" from the raw cached
    // profile (AuthService stores per-user raw maps). The typed `Profile`
    // model doesn't include this field so we prefer the raw cache first and
    // fall back to Profile.toJson().
    final rawCached = AuthService().getCachedUser(profile.id);
    String dateYouReason = '';
    if (rawCached != null) {
      dateYouReason = (rawCached['date_you_reason'] ?? rawCached['dateYouReason'] ?? '')?.toString() ?? '';
    }
    if (dateYouReason.isEmpty) {
      final map = profile.toJson();
      dateYouReason = (map['date_you_reason'] ?? map['dateYouReason'] ?? '')?.toString() ?? '';
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [Colors.grey.shade50, Colors.white],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: Colors.grey.shade200, width: 1),
          ),
          child: Column(
            children: [
              _InfoRow(label: 'Gender', value: profile.gender.isNotEmpty ? profile.gender : 'Not specified'),
              const SizedBox(height: 12),
              _InfoRow(label: 'Location', value: profile.location.isNotEmpty ? profile.location : 'Not specified'),
              const SizedBox(height: 12),
              _InfoRow(label: 'Height', value: _formatHeight(profile)),
            ],
          ),
        ),
        const SizedBox.shrink(),
        // Render server-provided "About" (date_you_reason) if present.
        if (dateYouReason.isNotEmpty) ...[
          const SizedBox(height: 24),
          Row(
            children: [
              Container(
                width: 4,
                height: 24,
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [Color(0xFFE53935), Color(0xFFFFF59D)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  ),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              const Text(
                'About',
                style: TextStyle(
                  color: Colors.black87,
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                  letterSpacing: 0.3,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            dateYouReason,
            style: const TextStyle(
              color: Colors.black87,
              height: 1.5,
              fontSize: 15,
            ),
          ),
        ],
        if (profile.interests.isNotEmpty) ...[
          const SizedBox(height: 24),
          Row(
            children: [
              Container(
                width: 4,
                height: 24,
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [Color(0xFFE53935), Color(0xFFFFF59D)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  ),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              const Text(
                'Interests',
                style: TextStyle(
                  color: Colors.black87,
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                  letterSpacing: 0.3,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(spacing: 10, runSpacing: 10, children: profile.interests.map((t) => _InterestChip(t)).toList()),
        ],
        if (profile.hobbies.isNotEmpty) ...[
          const SizedBox(height: 24),
          Row(
            children: [
              Container(
                width: 4,
                height: 24,
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [Color(0xFFE53935), Color(0xFFFFF59D)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  ),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              const Text(
                'Hobbies',
                style: TextStyle(
                  color: Colors.black87,
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                  letterSpacing: 0.3,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 10,
            runSpacing: 10,
            children: profile.hobbies
                .map((hobby) => hobby['name'] != null ? _HobbyChip(hobby['name'].toString()) : const SizedBox.shrink())
                .toList(),
          ),
        ],
        if (profile.relationshipGoals.isNotEmpty) ...[
          const SizedBox(height: 24),
          Row(
            children: [
              Container(
                width: 4,
                height: 24,
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [Color(0xFFE53935), Color(0xFFFFF59D)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  ),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              const Text(
                'Relationship Goals',
                style: TextStyle(
                  color: Colors.black87,
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                  letterSpacing: 0.3,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 10,
            runSpacing: 10,
            children: profile.relationshipGoals
                .map((goal) => goal['name'] != null ? _GoalChip(goal['name'].toString()) : const SizedBox.shrink())
                .toList(),
          ),
        ],
        if (profile.partnerQualities.isNotEmpty) ...[
          const SizedBox(height: 24),
          Row(
            children: [
              Container(
                width: 4,
                height: 24,
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [Color(0xFFE53935), Color(0xFFFFF59D)],
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                  ),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              const SizedBox(width: 12),
              const Text(
                'Partner Qualities',
                style: TextStyle(
                  color: Colors.black87,
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                  letterSpacing: 0.3,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Wrap(
            spacing: 10,
            runSpacing: 10,
            children: profile.partnerQualities
                .map((quality) => quality['name'] != null ? _QualityChip(quality['name'].toString()) : const SizedBox.shrink())
                .toList(),
          ),
        ],
      ],
    );
  });
}

Widget _InterestChip(String text) {
  return Container(
    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
    decoration: BoxDecoration(
      gradient: const LinearGradient(
        colors: [Color(0xFFE53935), Color(0xFFFF6F60)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ),
      borderRadius: BorderRadius.circular(24),
      boxShadow: [
        BoxShadow(
          color: Colors.red.shade200.withOpacity(0.4),
          blurRadius: 8,
          offset: const Offset(0, 3),
        ),
        BoxShadow(
          color: Colors.black.withOpacity(0.08),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        color: Colors.white.withOpacity(0.3),
        width: 1,
      ),
    ),
    child: Text(
      _capitalize(text),
      style: const TextStyle(
        color: Colors.white,
        fontWeight: FontWeight.w700,
        fontSize: 13,
        letterSpacing: 0.3,
      ),
    ),
  );
}

Widget _HobbyChip(String text) {
  return Container(
    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
    decoration: BoxDecoration(
      gradient: const LinearGradient(
        colors: [Color(0xFF6A4C93), Color(0xFF9B7EBD)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ),
      borderRadius: BorderRadius.circular(24),
      boxShadow: [
        BoxShadow(
          color: const Color(0xFF6A4C93).withOpacity(0.3),
          blurRadius: 8,
          offset: const Offset(0, 3),
        ),
        BoxShadow(
          color: Colors.black.withOpacity(0.08),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        color: Colors.white.withOpacity(0.3),
        width: 1,
      ),
    ),
    child: Text(
      _capitalize(text),
      style: const TextStyle(
        color: Colors.white,
        fontWeight: FontWeight.w700,
        fontSize: 13,
        letterSpacing: 0.3,
      ),
    ),
  );
}

Widget _GoalChip(String text) {
  return Container(
    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
    decoration: BoxDecoration(
      gradient: const LinearGradient(
        colors: [Color(0xFF00897B), Color(0xFF26A69A)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ),
      borderRadius: BorderRadius.circular(24),
      boxShadow: [
        BoxShadow(
          color: const Color(0xFF00897B).withOpacity(0.3),
          blurRadius: 8,
          offset: const Offset(0, 3),
        ),
        BoxShadow(
          color: Colors.black.withOpacity(0.08),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        color: Colors.white.withOpacity(0.3),
        width: 1,
      ),
    ),
    child: Text(
      _capitalize(text),
      style: const TextStyle(
        color: Colors.white,
        fontWeight: FontWeight.w700,
        fontSize: 13,
        letterSpacing: 0.3,
      ),
    ),
  );
}

Widget _QualityChip(String text) {
  return Container(
    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
    decoration: BoxDecoration(
      gradient: const LinearGradient(
        colors: [Color(0xFFF57C00), Color(0xFFFFA726)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ),
      borderRadius: BorderRadius.circular(24),
      boxShadow: [
        BoxShadow(
          color: const Color(0xFFF57C00).withOpacity(0.3),
          blurRadius: 8,
          offset: const Offset(0, 3),
        ),
        BoxShadow(
          color: Colors.black.withOpacity(0.08),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        color: Colors.white.withOpacity(0.3),
        width: 1,
      ),
    ),
    child: Text(
      _capitalize(text),
      style: const TextStyle(
        color: Colors.white,
        fontWeight: FontWeight.w700,
        fontSize: 13,
        letterSpacing: 0.3,
      ),
    ),
  );
}

class _InfoRow extends StatelessWidget {
  final String label;
  final String value;
  const _InfoRow({Key? key, required this.label, required this.value}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          flex: 4,
          child: Text(
            label,
            style: const TextStyle(
              color: Colors.black54,
              fontWeight: FontWeight.w600,
              fontSize: 14,
            ),
          ),
        ),
        Expanded(
          flex: 6,
          child: Text(
            _capitalize(value),
            style: const TextStyle(
              color: Colors.black87,
              fontWeight: FontWeight.w600,
              fontSize: 14,
            ),
          ),
        ),
      ],
    );
  }
}

// Helper: capitalize each word in a string (makes first letter uppercase)
String _capitalize(String s) {
  if (s.trim().isEmpty) return s;
  return s.splitMapJoin(RegExp(r"\s+"), onNonMatch: (chunk) {
    // This branch won't run; splitMapJoin used for safety
    return chunk;
  }, onMatch: (m) => m.group(0)!).split(RegExp(r"\s+")).map((word) {
    if (word.isEmpty) return word;
    final first = word.substring(0, 1).toUpperCase();
    if (word.length == 1) return first;
    return first + word.substring(1);
  }).join(' ');
}

// Simple helper: format profile height (inches) into feet/inches string.
String _formatHeight(Profile profile) {
  try {
    // Prefer any cached raw payload for this user (AuthService stores per-user cache)
    final rawCached = AuthService().getCachedUser(profile.id);
    dynamic raw;
    if (rawCached != null && rawCached.containsKey('height')) {
      raw = rawCached['height'];
    } else {
      final map = profile.toJson();
      raw = map['height'] ?? map['height_cm'];
    }
    if (raw == null) return '-';
    final s = raw.toString().trim();
    final n = int.tryParse(s);
    if (n == null) return s.isNotEmpty ? s : '-';
    final ft = n ~/ 12;
    final rem = n % 12;
    return rem > 0 ? '$ft ft $rem in' : '$ft ft';
  } catch (_) {
    return '-';
  }
}

import 'package:flutter/material.dart';

import '../models/profile.dart';
import '../services/match_service.dart';
import '../utils/custom_snackbar.dart';

class ProfileListScreen extends StatefulWidget {
  final String currentUserId;
  const ProfileListScreen({Key? key, required this.currentUserId}) : super(key: key);

  @override
  State<ProfileListScreen> createState() => _ProfileListScreenState();
}

class _ProfileListScreenState extends State<ProfileListScreen> {
  late List<Profile> _profiles = [];

  @override
  void initState() {
    super.initState();
    _profiles = MatchService.allProfiles().where((p) => p.id != widget.currentUserId).toList();
  }

  void _removeAt(int i) {
    setState(() {
      _profiles.removeAt(i);
    });
  }

  void _like(Profile p) {
    MatchService.like(widget.currentUserId, p.id);
    final mutual = MatchService.isMutual(widget.currentUserId, p.id);
    if (mutual) {
      customSnackBar('Success', "It's a match with ${p.name}!");
    } else {
      customSnackBar('Success', 'You liked ${p.name}');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_profiles.isEmpty) return const Center(child: Text('No more profiles', style: TextStyle(color: Colors.black87)));
    return Container(
      color: Colors.white,
      child: ListView.builder(
        itemCount: _profiles.length,
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 10),
        itemBuilder: (context, i) {
          final p = _profiles[i];
          return Card(
            color: Colors.white,
            margin: const EdgeInsets.symmetric(vertical: 10),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
            child: Column(
              children: [
                ClipRRect(
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(14)),
                  child: Image.network(p.imageUrl, height: 180, width: double.infinity, fit: BoxFit.cover),
                ),
                Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Row(
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('${p.name}, ${p.age}', style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: Colors.black87)),
                            const SizedBox(height: 6),
                            Text(p.bio, maxLines: 2, overflow: TextOverflow.ellipsis, style: const TextStyle(color: Colors.black54)),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.close, color: Colors.black54),
                            onPressed: () => _removeAt(i),
                          ),
                          IconButton(
                            icon: const Icon(Icons.chat_bubble_outline, color: Colors.red),
                            onPressed: () => Navigator.of(context).pushNamed('/chat', arguments: {'id': p.id, 'name': p.name}),
                          ),
                          IconButton(
                            icon: const Icon(Icons.favorite, color: Colors.red),
                            onPressed: () {
                              _like(p);
                              _removeAt(i);
                            },
                          ),
                        ],
                      )
                    ],
                  ),
                )
              ],
            ),
          );
        },
      ),
    );
  }
}
import 'package:flutter/material.dart';

import '../models/profile.dart';
import '../services/match_service.dart';
import '../utils/custom_snackbar.dart';

class ProfileListScreen extends StatefulWidget {
  final String currentUserId;
  const ProfileListScreen({Key? key, required this.currentUserId}) : super(key: key);

  @override
  State<ProfileListScreen> createState() => _ProfileListScreenState();
}

class _ProfileListScreenState extends State<ProfileListScreen> {
  late List<Profile> _profiles = [];

  @override
  void initState() {
    super.initState();
    _profiles = MatchService.allProfiles().where((p) => p.id != widget.currentUserId).toList();
  }

  void _removeAt(int i) {
    setState(() {
      _profiles.removeAt(i);
    });
  }

  void _like(Profile p) {
    MatchService.like(widget.currentUserId, p.id);
    final mutual = MatchService.isMutual(widget.currentUserId, p.id);
    if (mutual) {
      customSnackBar('Success', "It's a match with ${p.name}!");
    } else {
      customSnackBar('Success', 'You liked ${p.name}');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_profiles.isEmpty) return const Center(child: Text('No more profiles', style: TextStyle(color: Colors.black87)));
    return Container(
      color: Colors.white,
      child: ListView.builder(
        itemCount: _profiles.length,
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 10),
        itemBuilder: (context, i) {
          final p = _profiles[i];
          return Card(
            color: Colors.white,
            margin: const EdgeInsets.symmetric(vertical: 10),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
            child: Column(
              children: [
                ClipRRect(
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(14)),
                  child: Image.network(p.imageUrl, height: 180, width: double.infinity, fit: BoxFit.cover),
                ),
                Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Row(
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('${p.name}, ${p.age}', style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: Colors.black87)),
                            const SizedBox(height: 6),
                            Text(p.bio, maxLines: 2, overflow: TextOverflow.ellipsis, style: const TextStyle(color: Colors.black54)),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.close, color: Colors.black54),
                            onPressed: () => _removeAt(i),
                          ),
                          IconButton(
                            icon: const Icon(Icons.chat_bubble_outline, color: Colors.red),
                            onPressed: () => Navigator.of(context).pushNamed('/chat', arguments: {'id': p.id, 'name': p.name}),
                          ),
                          IconButton(
                            icon: const Icon(Icons.favorite, color: Colors.red),
                            onPressed: () {
                              _like(p);
                              _removeAt(i);
                            },
                          ),
                        ],
                      )
                    ],
                  ),
                )
              ],
            ),
          );
        },
      ),
    );
  }
}
import 'package:flutter/material.dart';

import '../models/profile.dart';
import '../services/match_service.dart';
import '../utils/custom_snackbar.dart';

class ProfileListScreen extends StatefulWidget {
  final String currentUserId;
  const ProfileListScreen({Key? key, required this.currentUserId}) : super(key: key);

  @override
  State<ProfileListScreen> createState() => _ProfileListScreenState();
}

class _ProfileListScreenState extends State<ProfileListScreen> {
  late List<Profile> _profiles = [];

  @override
  void initState() {
    super.initState();
    _profiles = MatchService.allProfiles().where((p) => p.id != widget.currentUserId).toList();
  }

  void _removeAt(int i) {
    setState(() {
      _profiles.removeAt(i);
    });
  }

  void _like(Profile p) {
    MatchService.like(widget.currentUserId, p.id);
    final mutual = MatchService.isMutual(widget.currentUserId, p.id);
    if (mutual) {
      customSnackBar('Success', "It's a match with ${p.name}!");
    } else {
      customSnackBar('Success', 'You liked ${p.name}');
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_profiles.isEmpty) return const Center(child: Text('No more profiles', style: TextStyle(color: Colors.black87)));
    return Container(
      color: Colors.white,
      child: ListView.builder(
        itemCount: _profiles.length,
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 10),
        itemBuilder: (context, i) {
          final p = _profiles[i];
          return Card(
            color: Colors.white,
            margin: const EdgeInsets.symmetric(vertical: 10),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
            child: Column(
              children: [
                ClipRRect(
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(14)),
                  child: Image.network(p.imageUrl, height: 180, width: double.infinity, fit: BoxFit.cover),
                ),
                Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Row(
                    children: [
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('${p.name}, ${p.age}', style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: Colors.black87)),
                            const SizedBox(height: 6),
                            Text(p.bio, maxLines: 2, overflow: TextOverflow.ellipsis, style: const TextStyle(color: Colors.black54)),
                          ],
                        ),
                      ),
                      const SizedBox(width: 8),
                      Column(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.close, color: Colors.black54),
                            onPressed: () => _removeAt(i),
                          ),
                          IconButton(
                            icon: const Icon(Icons.chat_bubble_outline, color: Colors.red),
                            onPressed: () => Navigator.of(context).pushNamed('/chat', arguments: {'id': p.id, 'name': p.name}),
                          ),
                          IconButton(
                            icon: const Icon(Icons.favorite, color: Colors.red),
                            onPressed: () {
                              _like(p);
                              _removeAt(i);
                            },
                          ),
                        ],
                      )
                    ],
                  ),
                )
              ],
            ),
          );
        },
      ),
    );
  }
}
